// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    func uploadFile(_ input: Operations.uploadFile.Input) async throws -> Operations.uploadFile.Output
    /// List transcripts
    ///
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    func listTranscripts(_ input: Operations.listTranscripts.Input) async throws -> Operations.listTranscripts.Output
    /// Transcribe audio
    ///
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    func createTranscript(_ input: Operations.createTranscript.Input) async throws -> Operations.createTranscript.Output
    /// Get transcript
    ///
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    func getTranscript(_ input: Operations.getTranscript.Input) async throws -> Operations.getTranscript.Output
    /// Delete transcript
    ///
    /// Remove the data from the transcript and mark it as deleted.
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    func deleteTranscript(_ input: Operations.deleteTranscript.Input) async throws -> Operations.deleteTranscript.Output
    /// Get subtitles for transcript
    ///
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    func getSubtitles(_ input: Operations.getSubtitles.Input) async throws -> Operations.getSubtitles.Output
    /// Get sentences in transcript
    ///
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    func getTranscriptSentences(_ input: Operations.getTranscriptSentences.Input) async throws -> Operations.getTranscriptSentences.Output
    /// Get paragraphs in transcript
    ///
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    func getTranscriptParagraphs(_ input: Operations.getTranscriptParagraphs.Input) async throws -> Operations.getTranscriptParagraphs.Output
    /// Search words in transcript
    ///
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    func wordSearch(_ input: Operations.wordSearch.Input) async throws -> Operations.wordSearch.Output
    /// Get redacted audio
    ///
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    func getRedactedAudio(_ input: Operations.getRedactedAudio.Input) async throws -> Operations.getRedactedAudio.Output
    /// Create temporary authentication token for Streaming STT
    ///
    /// Create a temporary authentication token for Streaming Speech-to-Text
    ///
    /// - Remark: HTTP `POST /v2/realtime/token`.
    /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)`.
    func createTemporaryToken(_ input: Operations.createTemporaryToken.Input) async throws -> Operations.createTemporaryToken.Output
    /// Run a task using LeMUR
    ///
    /// Use the LeMUR task endpoint to input your own LLM prompt.
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/task`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)`.
    func lemurTask(_ input: Operations.lemurTask.Input) async throws -> Operations.lemurTask.Output
    /// Summarize a transcript using LeMUR
    ///
    /// Custom Summary allows you to distill a piece of audio into a few impactful sentences.
    /// You can give the model context to obtain more targeted results while outputting the results in a variety of formats described in human language.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/summary`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)`.
    func lemurSummary(_ input: Operations.lemurSummary.Input) async throws -> Operations.lemurSummary.Output
    /// Ask questions using LeMUR
    ///
    /// Question & Answer allows you to ask free-form questions about a single transcript or a group of transcripts.
    /// The questions can be any whose answers you find useful, such as judging whether a caller is likely to become a customer or whether all items on a meeting's agenda were covered.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/question-answer`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)`.
    func lemurQuestionAnswer(_ input: Operations.lemurQuestionAnswer.Input) async throws -> Operations.lemurQuestionAnswer.Output
    /// Extract action items
    ///
    /// Use LeMUR to generate a list of action items from a transcript
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/action-items`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)`.
    func lemurActionItems(_ input: Operations.lemurActionItems.Input) async throws -> Operations.lemurActionItems.Output
    /// Retrieve LeMUR response
    ///
    /// Retrieve a LeMUR response that was previously generated.
    ///
    ///
    /// - Remark: HTTP `GET /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)`.
    func getLemurResponse(_ input: Operations.getLemurResponse.Input) async throws -> Operations.getLemurResponse.Output
    /// Purge LeMUR request data
    ///
    /// Delete the data for a previously submitted LeMUR request.
    /// The LLM response data, as well as any context provided in the original request will be removed.
    ///
    ///
    /// - Remark: HTTP `DELETE /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)`.
    func purgeLemurRequestData(_ input: Operations.purgeLemurRequestData.Input) async throws -> Operations.purgeLemurRequestData.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    public func uploadFile(
        headers: Operations.uploadFile.Input.Headers = .init(),
        body: Operations.uploadFile.Input.Body? = nil
    ) async throws -> Operations.uploadFile.Output {
        try await uploadFile(Operations.uploadFile.Input(
            headers: headers,
            body: body
        ))
    }
    /// List transcripts
    ///
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    public func listTranscripts(
        query: Operations.listTranscripts.Input.Query = .init(),
        headers: Operations.listTranscripts.Input.Headers = .init()
    ) async throws -> Operations.listTranscripts.Output {
        try await listTranscripts(Operations.listTranscripts.Input(
            query: query,
            headers: headers
        ))
    }
    /// Transcribe audio
    ///
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    public func createTranscript(
        headers: Operations.createTranscript.Input.Headers = .init(),
        body: Operations.createTranscript.Input.Body
    ) async throws -> Operations.createTranscript.Output {
        try await createTranscript(Operations.createTranscript.Input(
            headers: headers,
            body: body
        ))
    }
    /// Get transcript
    ///
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    public func getTranscript(
        path: Operations.getTranscript.Input.Path,
        headers: Operations.getTranscript.Input.Headers = .init()
    ) async throws -> Operations.getTranscript.Output {
        try await getTranscript(Operations.getTranscript.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete transcript
    ///
    /// Remove the data from the transcript and mark it as deleted.
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    public func deleteTranscript(
        path: Operations.deleteTranscript.Input.Path,
        headers: Operations.deleteTranscript.Input.Headers = .init()
    ) async throws -> Operations.deleteTranscript.Output {
        try await deleteTranscript(Operations.deleteTranscript.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get subtitles for transcript
    ///
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    public func getSubtitles(
        path: Operations.getSubtitles.Input.Path,
        query: Operations.getSubtitles.Input.Query = .init(),
        headers: Operations.getSubtitles.Input.Headers = .init()
    ) async throws -> Operations.getSubtitles.Output {
        try await getSubtitles(Operations.getSubtitles.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get sentences in transcript
    ///
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    public func getTranscriptSentences(
        path: Operations.getTranscriptSentences.Input.Path,
        headers: Operations.getTranscriptSentences.Input.Headers = .init()
    ) async throws -> Operations.getTranscriptSentences.Output {
        try await getTranscriptSentences(Operations.getTranscriptSentences.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get paragraphs in transcript
    ///
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    public func getTranscriptParagraphs(
        path: Operations.getTranscriptParagraphs.Input.Path,
        headers: Operations.getTranscriptParagraphs.Input.Headers = .init()
    ) async throws -> Operations.getTranscriptParagraphs.Output {
        try await getTranscriptParagraphs(Operations.getTranscriptParagraphs.Input(
            path: path,
            headers: headers
        ))
    }
    /// Search words in transcript
    ///
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    public func wordSearch(
        path: Operations.wordSearch.Input.Path,
        query: Operations.wordSearch.Input.Query,
        headers: Operations.wordSearch.Input.Headers = .init()
    ) async throws -> Operations.wordSearch.Output {
        try await wordSearch(Operations.wordSearch.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get redacted audio
    ///
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    public func getRedactedAudio(
        path: Operations.getRedactedAudio.Input.Path,
        headers: Operations.getRedactedAudio.Input.Headers = .init()
    ) async throws -> Operations.getRedactedAudio.Output {
        try await getRedactedAudio(Operations.getRedactedAudio.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create temporary authentication token for Streaming STT
    ///
    /// Create a temporary authentication token for Streaming Speech-to-Text
    ///
    /// - Remark: HTTP `POST /v2/realtime/token`.
    /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)`.
    public func createTemporaryToken(
        headers: Operations.createTemporaryToken.Input.Headers = .init(),
        body: Operations.createTemporaryToken.Input.Body
    ) async throws -> Operations.createTemporaryToken.Output {
        try await createTemporaryToken(Operations.createTemporaryToken.Input(
            headers: headers,
            body: body
        ))
    }
    /// Run a task using LeMUR
    ///
    /// Use the LeMUR task endpoint to input your own LLM prompt.
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/task`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)`.
    public func lemurTask(
        headers: Operations.lemurTask.Input.Headers = .init(),
        body: Operations.lemurTask.Input.Body
    ) async throws -> Operations.lemurTask.Output {
        try await lemurTask(Operations.lemurTask.Input(
            headers: headers,
            body: body
        ))
    }
    /// Summarize a transcript using LeMUR
    ///
    /// Custom Summary allows you to distill a piece of audio into a few impactful sentences.
    /// You can give the model context to obtain more targeted results while outputting the results in a variety of formats described in human language.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/summary`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)`.
    public func lemurSummary(
        headers: Operations.lemurSummary.Input.Headers = .init(),
        body: Operations.lemurSummary.Input.Body
    ) async throws -> Operations.lemurSummary.Output {
        try await lemurSummary(Operations.lemurSummary.Input(
            headers: headers,
            body: body
        ))
    }
    /// Ask questions using LeMUR
    ///
    /// Question & Answer allows you to ask free-form questions about a single transcript or a group of transcripts.
    /// The questions can be any whose answers you find useful, such as judging whether a caller is likely to become a customer or whether all items on a meeting's agenda were covered.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/question-answer`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)`.
    public func lemurQuestionAnswer(
        headers: Operations.lemurQuestionAnswer.Input.Headers = .init(),
        body: Operations.lemurQuestionAnswer.Input.Body
    ) async throws -> Operations.lemurQuestionAnswer.Output {
        try await lemurQuestionAnswer(Operations.lemurQuestionAnswer.Input(
            headers: headers,
            body: body
        ))
    }
    /// Extract action items
    ///
    /// Use LeMUR to generate a list of action items from a transcript
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/action-items`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)`.
    public func lemurActionItems(
        headers: Operations.lemurActionItems.Input.Headers = .init(),
        body: Operations.lemurActionItems.Input.Body
    ) async throws -> Operations.lemurActionItems.Output {
        try await lemurActionItems(Operations.lemurActionItems.Input(
            headers: headers,
            body: body
        ))
    }
    /// Retrieve LeMUR response
    ///
    /// Retrieve a LeMUR response that was previously generated.
    ///
    ///
    /// - Remark: HTTP `GET /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)`.
    public func getLemurResponse(
        path: Operations.getLemurResponse.Input.Path,
        headers: Operations.getLemurResponse.Input.Headers = .init()
    ) async throws -> Operations.getLemurResponse.Output {
        try await getLemurResponse(Operations.getLemurResponse.Input(
            path: path,
            headers: headers
        ))
    }
    /// Purge LeMUR request data
    ///
    /// Delete the data for a previously submitted LeMUR request.
    /// The LLM response data, as well as any context provided in the original request will be removed.
    ///
    ///
    /// - Remark: HTTP `DELETE /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)`.
    public func purgeLemurRequestData(
        path: Operations.purgeLemurRequestData.Input.Path,
        headers: Operations.purgeLemurRequestData.Input.Headers = .init()
    ) async throws -> Operations.purgeLemurRequestData.Output {
        try await purgeLemurRequestData(Operations.purgeLemurRequestData.Input(
            path: path,
            headers: headers
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// AssemblyAI API
    public enum Server1 {
        /// AssemblyAI API
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.assemblyai.com",
                variables: []
            )
        }
    }
    /// AssemblyAI API
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://api.assemblyai.com",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// The notifications sent to the webhook URL.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification`.
        @frozen public enum TranscriptWebhookNotification: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification/case1`.
            case TranscriptReadyNotification(Components.Schemas.TranscriptReadyNotification)
            /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification/case2`.
            case RedactedAudioNotification(Components.Schemas.RedactedAudioNotification)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .TranscriptReadyNotification(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RedactedAudioNotification(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .TranscriptReadyNotification(value):
                    try value.encode(to: encoder)
                case let .RedactedAudioNotification(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// The notification when the transcript status is completed or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification`.
        public struct TranscriptReadyNotification: Codable, Hashable, Sendable {
            /// The ID of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification/transcript_id`.
            public var transcript_id: Swift.String
            /// The status of the transcript. Either completed or error.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification/status`.
            public var status: Components.Schemas.TranscriptReadyStatus
            /// Creates a new `TranscriptReadyNotification`.
            ///
            /// - Parameters:
            ///   - transcript_id: The ID of the transcript
            ///   - status: The status of the transcript. Either completed or error.
            public init(
                transcript_id: Swift.String,
                status: Components.Schemas.TranscriptReadyStatus
            ) {
                self.transcript_id = transcript_id
                self.status = status
            }
            public enum CodingKeys: String, CodingKey {
                case transcript_id
                case status
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                transcript_id = try container.decode(
                    Swift.String.self,
                    forKey: .transcript_id
                )
                status = try container.decode(
                    Components.Schemas.TranscriptReadyStatus.self,
                    forKey: .status
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "transcript_id",
                    "status"
                ])
            }
        }
        /// The notification when the redacted audio is ready.
        ///
        /// - Remark: Generated from `#/components/schemas/RedactedAudioNotification`.
        public struct RedactedAudioNotification: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/RedactedAudioNotification/value1`.
            public var value1: Components.Schemas.RedactedAudioResponse
            /// Creates a new `RedactedAudioNotification`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.RedactedAudioResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse`.
        public struct RedactedAudioResponse: Codable, Hashable, Sendable {
            /// The status of the redacted audio
            ///
            /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse/status`.
            public var status: Components.Schemas.RedactedAudioStatus
            /// The URL of the redacted audio file
            ///
            /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse/redacted_audio_url`.
            public var redacted_audio_url: Swift.String
            /// Creates a new `RedactedAudioResponse`.
            ///
            /// - Parameters:
            ///   - status: The status of the redacted audio
            ///   - redacted_audio_url: The URL of the redacted audio file
            public init(
                status: Components.Schemas.RedactedAudioStatus,
                redacted_audio_url: Swift.String
            ) {
                self.status = status
                self.redacted_audio_url = redacted_audio_url
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case redacted_audio_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                status = try container.decode(
                    Components.Schemas.RedactedAudioStatus.self,
                    forKey: .status
                )
                redacted_audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .redacted_audio_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "status",
                    "redacted_audio_url"
                ])
            }
        }
        /// The status of the redacted audio
        ///
        /// - Remark: Generated from `#/components/schemas/RedactedAudioStatus`.
        @frozen public enum RedactedAudioStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case redacted_audio_ready = "redacted_audio_ready"
        }
        /// Format of the subtitles
        ///
        /// - Remark: Generated from `#/components/schemas/SubtitleFormat`.
        @frozen public enum SubtitleFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case srt = "srt"
            case vtt = "vtt"
        }
        /// - Remark: Generated from `#/components/schemas/WordSearchResponse`.
        public struct WordSearchResponse: Codable, Hashable, Sendable {
            /// The ID of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/id`.
            public var id: Swift.String
            /// The total count of all matched instances. For e.g., word 1 matched 2 times, and word 2 matched 3 times, `total_count` will equal 5.
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/total_count`.
            public var total_count: Swift.Int
            /// The matches of the search
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/matches`.
            public var matches: [Components.Schemas.WordSearchMatch]
            /// Creates a new `WordSearchResponse`.
            ///
            /// - Parameters:
            ///   - id: The ID of the transcript
            ///   - total_count: The total count of all matched instances. For e.g., word 1 matched 2 times, and word 2 matched 3 times, `total_count` will equal 5.
            ///   - matches: The matches of the search
            public init(
                id: Swift.String,
                total_count: Swift.Int,
                matches: [Components.Schemas.WordSearchMatch]
            ) {
                self.id = id
                self.total_count = total_count
                self.matches = matches
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case total_count
                case matches
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                total_count = try container.decode(
                    Swift.Int.self,
                    forKey: .total_count
                )
                matches = try container.decode(
                    [Components.Schemas.WordSearchMatch].self,
                    forKey: .matches
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "total_count",
                    "matches"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/WordSearchMatch`.
        public struct WordSearchMatch: Codable, Hashable, Sendable {
            /// The matched word
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/text`.
            public var text: Swift.String
            /// The total amount of times the word is in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/count`.
            public var count: Swift.Int
            /// An array of timestamps
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/timestamps`.
            public var timestamps: [Components.Schemas.WordSearchTimestamp]
            /// An array of all index locations for that word within the `words` array of the completed transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/indexes`.
            public var indexes: [Swift.Int]
            /// Creates a new `WordSearchMatch`.
            ///
            /// - Parameters:
            ///   - text: The matched word
            ///   - count: The total amount of times the word is in the transcript
            ///   - timestamps: An array of timestamps
            ///   - indexes: An array of all index locations for that word within the `words` array of the completed transcript
            public init(
                text: Swift.String,
                count: Swift.Int,
                timestamps: [Components.Schemas.WordSearchTimestamp],
                indexes: [Swift.Int]
            ) {
                self.text = text
                self.count = count
                self.timestamps = timestamps
                self.indexes = indexes
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case count
                case timestamps
                case indexes
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                count = try container.decode(
                    Swift.Int.self,
                    forKey: .count
                )
                timestamps = try container.decode(
                    [Components.Schemas.WordSearchTimestamp].self,
                    forKey: .timestamps
                )
                indexes = try container.decode(
                    [Swift.Int].self,
                    forKey: .indexes
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "count",
                    "timestamps",
                    "indexes"
                ])
            }
        }
        /// An array of timestamps structured as [`start_time`, `end_time`] in milliseconds
        ///
        /// - Remark: Generated from `#/components/schemas/WordSearchTimestamp`.
        public typealias WordSearchTimestamp = [Swift.Int]
        /// Timestamp containing a start and end property in milliseconds
        ///
        /// - Remark: Generated from `#/components/schemas/Timestamp`.
        public struct Timestamp: Codable, Hashable, Sendable {
            /// The start time in milliseconds
            ///
            /// - Remark: Generated from `#/components/schemas/Timestamp/start`.
            public var start: Swift.Int
            /// The end time in milliseconds
            ///
            /// - Remark: Generated from `#/components/schemas/Timestamp/end`.
            public var end: Swift.Int
            /// Creates a new `Timestamp`.
            ///
            /// - Parameters:
            ///   - start: The start time in milliseconds
            ///   - end: The end time in milliseconds
            public init(
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "start",
                    "end"
                ])
            }
        }
        /// The parameters for creating a transcript
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams`.
        public struct TranscriptOptionalParams: Codable, Hashable, Sendable {
            /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code`.
            public struct language_codePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code/value1`.
                public var value1: Components.Schemas.TranscriptLanguageCode?
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code/value2`.
                public var value2: Swift.String?
                /// Creates a new `language_codePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.TranscriptLanguageCode? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            value1,
                            value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        value1,
                        value2
                    ])
                }
            }
            /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code`.
            public var language_code: Components.Schemas.TranscriptOptionalParams.language_codePayload?
            /// Enable [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection), either true or false.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection`.
            public var language_detection: Swift.Bool?
            /// The confidence threshold for the automatically detected language.
            /// An error will be returned if the language confidence is below this threshold.
            /// Defaults to 0.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_confidence_threshold`.
            public var language_confidence_threshold: Swift.Float?
            /// The speech model to use for the transcription. When `null`, the "best" model is used.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_model`.
            public var speech_model: Components.Schemas.SpeechModel?
            /// Enable Automatic Punctuation, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/punctuate`.
            public var punctuate: Swift.Bool?
            /// Enable Text Formatting, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/format_text`.
            public var format_text: Swift.Bool?
            /// Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/disfluencies`.
            public var disfluencies: Swift.Bool?
            /// Enable [Dual Channel](https://www.assemblyai.com/docs/models/speech-recognition#dual-channel-transcription) transcription, can be true or false.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/dual_channel`.
            @available(*, deprecated)
            public var dual_channel: Swift.Bool?
            /// The URL to which we send webhook requests.
            /// We sends two different types of webhook requests.
            /// One request when a transcript is completed or failed, and one request when the redacted audio is ready if redact_pii_audio is enabled.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_url`.
            public var webhook_url: Swift.String?
            /// The header name to be sent with the transcript completed or failed webhook requests
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_auth_header_name`.
            public var webhook_auth_header_name: Swift.String?
            /// The header value to send back with the transcript completed or failed webhook requests for added security
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_auth_header_value`.
            public var webhook_auth_header_value: Swift.String?
            /// Enable Key Phrases, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/auto_highlights`.
            public var auto_highlights: Swift.Bool?
            /// The point in time, in milliseconds, to begin transcribing in your media file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/audio_start_from`.
            public var audio_start_from: Swift.Int?
            /// The point in time, in milliseconds, to stop transcribing in your media file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/audio_end_at`.
            public var audio_end_at: Swift.Int?
            /// The list of custom vocabulary to boost transcription probability for
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/word_boost`.
            public var word_boost: [Swift.String]?
            /// How much to boost specified words
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/boost_param`.
            public var boost_param: Components.Schemas.TranscriptBoostParam?
            /// Filter profanity from the transcribed text, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/filter_profanity`.
            public var filter_profanity: Swift.Bool?
            /// Redact PII from the transcribed text using the Redact PII model, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii`.
            public var redact_pii: Swift.Bool?
            /// Generate a copy of the original media file with spoken PII "beeped" out, can be true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio`.
            public var redact_pii_audio: Swift.Bool?
            /// Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio_quality`.
            public var redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality?
            /// The list of PII Redaction policies to enable. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_policies`.
            public var redact_pii_policies: [Components.Schemas.PiiPolicy]?
            /// The replacement logic for detected PII, can be "entity_type" or "hash". See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_sub`.
            public var redact_pii_sub: Components.Schemas.SubstitutionPolicy?
            /// Enable [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_labels`.
            public var speaker_labels: Swift.Bool?
            /// Tells the speaker label model how many speakers it should attempt to identify, up to 10. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speakers_expected`.
            public var speakers_expected: Swift.Int?
            /// Enable [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/content_safety`.
            public var content_safety: Swift.Bool?
            /// The confidence threshold for the Content Moderation model. Values must be between 25 and 100.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/content_safety_confidence`.
            public var content_safety_confidence: Swift.Int?
            /// Enable [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/iab_categories`.
            public var iab_categories: Swift.Bool?
            /// Customize how words are spelled and formatted using to and from values
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/custom_spelling`.
            public var custom_spelling: [Components.Schemas.TranscriptCustomSpelling]?
            /// Enable [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/sentiment_analysis`.
            public var sentiment_analysis: Swift.Bool?
            /// Enable [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/auto_chapters`.
            public var auto_chapters: Swift.Bool?
            /// Enable [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/entity_detection`.
            public var entity_detection: Swift.Bool?
            /// Reject audio files that contain less than this fraction of speech.
            /// Valid values are in the range [0, 1] inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_threshold`.
            public var speech_threshold: Swift.Float?
            /// Enable [Summarization](https://www.assemblyai.com/docs/models/summarization), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summarization`.
            public var summarization: Swift.Bool?
            /// The model to summarize the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summary_model`.
            public var summary_model: Components.Schemas.SummaryModel?
            /// The type of summary
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summary_type`.
            public var summary_type: Components.Schemas.SummaryType?
            /// Enable custom topics, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/custom_topics`.
            public var custom_topics: Swift.Bool?
            /// The list of custom topics
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/topics`.
            public var topics: [Swift.String]?
            /// Creates a new `TranscriptOptionalParams`.
            ///
            /// - Parameters:
            ///   - language_code: The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            ///   - language_detection: Enable [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection), either true or false.
            ///   - language_confidence_threshold: The confidence threshold for the automatically detected language.
            ///   - speech_model: The speech model to use for the transcription. When `null`, the "best" model is used.
            ///   - punctuate: Enable Automatic Punctuation, can be true or false
            ///   - format_text: Enable Text Formatting, can be true or false
            ///   - disfluencies: Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///   - dual_channel: Enable [Dual Channel](https://www.assemblyai.com/docs/models/speech-recognition#dual-channel-transcription) transcription, can be true or false.
            ///   - webhook_url: The URL to which we send webhook requests.
            ///   - webhook_auth_header_name: The header name to be sent with the transcript completed or failed webhook requests
            ///   - webhook_auth_header_value: The header value to send back with the transcript completed or failed webhook requests for added security
            ///   - auto_highlights: Enable Key Phrases, either true or false
            ///   - audio_start_from: The point in time, in milliseconds, to begin transcribing in your media file
            ///   - audio_end_at: The point in time, in milliseconds, to stop transcribing in your media file
            ///   - word_boost: The list of custom vocabulary to boost transcription probability for
            ///   - boost_param: How much to boost specified words
            ///   - filter_profanity: Filter profanity from the transcribed text, can be true or false
            ///   - redact_pii: Redact PII from the transcribed text using the Redact PII model, can be true or false
            ///   - redact_pii_audio: Generate a copy of the original media file with spoken PII "beeped" out, can be true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_audio_quality: Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_policies: The list of PII Redaction policies to enable. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_sub: The replacement logic for detected PII, can be "entity_type" or "hash". See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - speaker_labels: Enable [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization), can be true or false
            ///   - speakers_expected: Tells the speaker label model how many speakers it should attempt to identify, up to 10. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///   - content_safety: Enable [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation), can be true or false
            ///   - content_safety_confidence: The confidence threshold for the Content Moderation model. Values must be between 25 and 100.
            ///   - iab_categories: Enable [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection), can be true or false
            ///   - custom_spelling: Customize how words are spelled and formatted using to and from values
            ///   - sentiment_analysis: Enable [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis), can be true or false
            ///   - auto_chapters: Enable [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters), can be true or false
            ///   - entity_detection: Enable [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection), can be true or false
            ///   - speech_threshold: Reject audio files that contain less than this fraction of speech.
            ///   - summarization: Enable [Summarization](https://www.assemblyai.com/docs/models/summarization), can be true or false
            ///   - summary_model: The model to summarize the transcript
            ///   - summary_type: The type of summary
            ///   - custom_topics: Enable custom topics, either true or false
            ///   - topics: The list of custom topics
            public init(
                language_code: Components.Schemas.TranscriptOptionalParams.language_codePayload? = nil,
                language_detection: Swift.Bool? = nil,
                language_confidence_threshold: Swift.Float? = nil,
                speech_model: Components.Schemas.SpeechModel? = nil,
                punctuate: Swift.Bool? = nil,
                format_text: Swift.Bool? = nil,
                disfluencies: Swift.Bool? = nil,
                dual_channel: Swift.Bool? = nil,
                webhook_url: Swift.String? = nil,
                webhook_auth_header_name: Swift.String? = nil,
                webhook_auth_header_value: Swift.String? = nil,
                auto_highlights: Swift.Bool? = nil,
                audio_start_from: Swift.Int? = nil,
                audio_end_at: Swift.Int? = nil,
                word_boost: [Swift.String]? = nil,
                boost_param: Components.Schemas.TranscriptBoostParam? = nil,
                filter_profanity: Swift.Bool? = nil,
                redact_pii: Swift.Bool? = nil,
                redact_pii_audio: Swift.Bool? = nil,
                redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality? = nil,
                redact_pii_policies: [Components.Schemas.PiiPolicy]? = nil,
                redact_pii_sub: Components.Schemas.SubstitutionPolicy? = nil,
                speaker_labels: Swift.Bool? = nil,
                speakers_expected: Swift.Int? = nil,
                content_safety: Swift.Bool? = nil,
                content_safety_confidence: Swift.Int? = nil,
                iab_categories: Swift.Bool? = nil,
                custom_spelling: [Components.Schemas.TranscriptCustomSpelling]? = nil,
                sentiment_analysis: Swift.Bool? = nil,
                auto_chapters: Swift.Bool? = nil,
                entity_detection: Swift.Bool? = nil,
                speech_threshold: Swift.Float? = nil,
                summarization: Swift.Bool? = nil,
                summary_model: Components.Schemas.SummaryModel? = nil,
                summary_type: Components.Schemas.SummaryType? = nil,
                custom_topics: Swift.Bool? = nil,
                topics: [Swift.String]? = nil
            ) {
                self.language_code = language_code
                self.language_detection = language_detection
                self.language_confidence_threshold = language_confidence_threshold
                self.speech_model = speech_model
                self.punctuate = punctuate
                self.format_text = format_text
                self.disfluencies = disfluencies
                self.dual_channel = dual_channel
                self.webhook_url = webhook_url
                self.webhook_auth_header_name = webhook_auth_header_name
                self.webhook_auth_header_value = webhook_auth_header_value
                self.auto_highlights = auto_highlights
                self.audio_start_from = audio_start_from
                self.audio_end_at = audio_end_at
                self.word_boost = word_boost
                self.boost_param = boost_param
                self.filter_profanity = filter_profanity
                self.redact_pii = redact_pii
                self.redact_pii_audio = redact_pii_audio
                self.redact_pii_audio_quality = redact_pii_audio_quality
                self.redact_pii_policies = redact_pii_policies
                self.redact_pii_sub = redact_pii_sub
                self.speaker_labels = speaker_labels
                self.speakers_expected = speakers_expected
                self.content_safety = content_safety
                self.content_safety_confidence = content_safety_confidence
                self.iab_categories = iab_categories
                self.custom_spelling = custom_spelling
                self.sentiment_analysis = sentiment_analysis
                self.auto_chapters = auto_chapters
                self.entity_detection = entity_detection
                self.speech_threshold = speech_threshold
                self.summarization = summarization
                self.summary_model = summary_model
                self.summary_type = summary_type
                self.custom_topics = custom_topics
                self.topics = topics
            }
            public enum CodingKeys: String, CodingKey {
                case language_code
                case language_detection
                case language_confidence_threshold
                case speech_model
                case punctuate
                case format_text
                case disfluencies
                case dual_channel
                case webhook_url
                case webhook_auth_header_name
                case webhook_auth_header_value
                case auto_highlights
                case audio_start_from
                case audio_end_at
                case word_boost
                case boost_param
                case filter_profanity
                case redact_pii
                case redact_pii_audio
                case redact_pii_audio_quality
                case redact_pii_policies
                case redact_pii_sub
                case speaker_labels
                case speakers_expected
                case content_safety
                case content_safety_confidence
                case iab_categories
                case custom_spelling
                case sentiment_analysis
                case auto_chapters
                case entity_detection
                case speech_threshold
                case summarization
                case summary_model
                case summary_type
                case custom_topics
                case topics
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                language_code = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.language_codePayload.self,
                    forKey: .language_code
                )
                language_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .language_detection
                )
                language_confidence_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .language_confidence_threshold
                )
                speech_model = try container.decodeIfPresent(
                    Components.Schemas.SpeechModel.self,
                    forKey: .speech_model
                )
                punctuate = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .punctuate
                )
                format_text = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .format_text
                )
                disfluencies = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .disfluencies
                )
                dual_channel = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .dual_channel
                )
                webhook_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_url
                )
                webhook_auth_header_name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_name
                )
                webhook_auth_header_value = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_value
                )
                auto_highlights = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_highlights
                )
                audio_start_from = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_start_from
                )
                audio_end_at = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_end_at
                )
                word_boost = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .word_boost
                )
                boost_param = try container.decodeIfPresent(
                    Components.Schemas.TranscriptBoostParam.self,
                    forKey: .boost_param
                )
                filter_profanity = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .filter_profanity
                )
                redact_pii = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii
                )
                redact_pii_audio = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii_audio
                )
                redact_pii_audio_quality = try container.decodeIfPresent(
                    Components.Schemas.RedactPiiAudioQuality.self,
                    forKey: .redact_pii_audio_quality
                )
                redact_pii_policies = try container.decodeIfPresent(
                    [Components.Schemas.PiiPolicy].self,
                    forKey: .redact_pii_policies
                )
                redact_pii_sub = try container.decodeIfPresent(
                    Components.Schemas.SubstitutionPolicy.self,
                    forKey: .redact_pii_sub
                )
                speaker_labels = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speaker_labels
                )
                speakers_expected = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .speakers_expected
                )
                content_safety = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .content_safety
                )
                content_safety_confidence = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .content_safety_confidence
                )
                iab_categories = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .iab_categories
                )
                custom_spelling = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptCustomSpelling].self,
                    forKey: .custom_spelling
                )
                sentiment_analysis = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .sentiment_analysis
                )
                auto_chapters = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_chapters
                )
                entity_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .entity_detection
                )
                speech_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .speech_threshold
                )
                summarization = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .summarization
                )
                summary_model = try container.decodeIfPresent(
                    Components.Schemas.SummaryModel.self,
                    forKey: .summary_model
                )
                summary_type = try container.decodeIfPresent(
                    Components.Schemas.SummaryType.self,
                    forKey: .summary_type
                )
                custom_topics = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .custom_topics
                )
                topics = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .topics
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "language_code",
                    "language_detection",
                    "language_confidence_threshold",
                    "speech_model",
                    "punctuate",
                    "format_text",
                    "disfluencies",
                    "dual_channel",
                    "webhook_url",
                    "webhook_auth_header_name",
                    "webhook_auth_header_value",
                    "auto_highlights",
                    "audio_start_from",
                    "audio_end_at",
                    "word_boost",
                    "boost_param",
                    "filter_profanity",
                    "redact_pii",
                    "redact_pii_audio",
                    "redact_pii_audio_quality",
                    "redact_pii_policies",
                    "redact_pii_sub",
                    "speaker_labels",
                    "speakers_expected",
                    "content_safety",
                    "content_safety_confidence",
                    "iab_categories",
                    "custom_spelling",
                    "sentiment_analysis",
                    "auto_chapters",
                    "entity_detection",
                    "speech_threshold",
                    "summarization",
                    "summary_model",
                    "summary_type",
                    "custom_topics",
                    "topics"
                ])
            }
        }
        /// The parameters for creating a transcript
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptParams`.
        public struct TranscriptParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// The URL of the audio or video file to transcribe.
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1/audio_url`.
                public var audio_url: Swift.String
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - audio_url: The URL of the audio or video file to transcribe.
                public init(audio_url: Swift.String) {
                    self.audio_url = audio_url
                }
                public enum CodingKeys: String, CodingKey {
                    case audio_url
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    audio_url = try container.decode(
                        Swift.String.self,
                        forKey: .audio_url
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "audio_url"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1`.
            public var value1: Components.Schemas.TranscriptParams.Value1Payload
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value2`.
            public var value2: Components.Schemas.TranscriptOptionalParams
            /// Creates a new `TranscriptParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.TranscriptParams.Value1Payload,
                value2: Components.Schemas.TranscriptOptionalParams
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// The model to summarize the transcript
        ///
        /// - Remark: Generated from `#/components/schemas/SummaryModel`.
        @frozen public enum SummaryModel: String, Codable, Hashable, Sendable, CaseIterable {
            case informative = "informative"
            case conversational = "conversational"
            case catchy = "catchy"
        }
        /// The type of summary
        ///
        /// - Remark: Generated from `#/components/schemas/SummaryType`.
        @frozen public enum SummaryType: String, Codable, Hashable, Sendable, CaseIterable {
            case bullets = "bullets"
            case bullets_verbose = "bullets_verbose"
            case gist = "gist"
            case headline = "headline"
            case paragraph = "paragraph"
        }
        /// How much to boost specified words
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptBoostParam`.
        @frozen public enum TranscriptBoostParam: String, Codable, Hashable, Sendable, CaseIterable {
            case low = "low"
            case _default = "default"
            case high = "high"
        }
        /// Object containing words or phrases to replace, and the word or phrase to replace with
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling`.
        public struct TranscriptCustomSpelling: Codable, Hashable, Sendable {
            /// Words or phrases to replace
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling/from`.
            public var from: [Swift.String]
            /// Word or phrase to replace with
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling/to`.
            public var to: Swift.String
            /// Creates a new `TranscriptCustomSpelling`.
            ///
            /// - Parameters:
            ///   - from: Words or phrases to replace
            ///   - to: Word or phrase to replace with
            public init(
                from: [Swift.String],
                to: Swift.String
            ) {
                self.from = from
                self.to = to
            }
            public enum CodingKeys: String, CodingKey {
                case from
                case to
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                from = try container.decode(
                    [Swift.String].self,
                    forKey: .from
                )
                to = try container.decode(
                    Swift.String.self,
                    forKey: .to
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "from",
                    "to"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptUtterance`.
        public struct TranscriptUtterance: Codable, Hashable, Sendable {
            /// The confidence score for the transcript of this utterance
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/confidence`.
            public var confidence: Swift.Double
            /// The starting time, in milliseconds, of the utterance in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the utterance in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/end`.
            public var end: Swift.Int
            /// The text for this utterance
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/text`.
            public var text: Swift.String
            /// The words in the utterance.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/channel`.
            public var channel: Swift.String?
            /// The speaker of this utterance, where each speaker is assigned a sequential capital letter - e.g. "A" for Speaker A, "B" for Speaker B, etc.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/speaker`.
            public var speaker: Swift.String
            /// Creates a new `TranscriptUtterance`.
            ///
            /// - Parameters:
            ///   - confidence: The confidence score for the transcript of this utterance
            ///   - start: The starting time, in milliseconds, of the utterance in the audio file
            ///   - end: The ending time, in milliseconds, of the utterance in the audio file
            ///   - text: The text for this utterance
            ///   - words: The words in the utterance.
            ///   - channel: The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of this utterance, where each speaker is assigned a sequential capital letter - e.g. "A" for Speaker A, "B" for Speaker B, etc.
            public init(
                confidence: Swift.Double,
                start: Swift.Int,
                end: Swift.Int,
                text: Swift.String,
                words: [Components.Schemas.TranscriptWord],
                channel: Swift.String? = nil,
                speaker: Swift.String
            ) {
                self.confidence = confidence
                self.start = start
                self.end = end
                self.text = text
                self.words = words
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case confidence
                case start
                case end
                case text
                case words
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                speaker = try container.decode(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "confidence",
                    "start",
                    "end",
                    "text",
                    "words",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// The replacement logic for detected PII, can be "entity_name" or "hash". See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
        ///
        /// - Remark: Generated from `#/components/schemas/SubstitutionPolicy`.
        @frozen public enum SubstitutionPolicy: String, Codable, Hashable, Sendable, CaseIterable {
            case entity_name = "entity_name"
            case hash = "hash"
        }
        /// Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
        ///
        /// - Remark: Generated from `#/components/schemas/RedactPiiAudioQuality`.
        @frozen public enum RedactPiiAudioQuality: String, Codable, Hashable, Sendable, CaseIterable {
            case mp3 = "mp3"
            case wav = "wav"
        }
        /// The type of PII to redact
        ///
        /// - Remark: Generated from `#/components/schemas/PiiPolicy`.
        @frozen public enum PiiPolicy: String, Codable, Hashable, Sendable, CaseIterable {
            case account_number = "account_number"
            case banking_information = "banking_information"
            case blood_type = "blood_type"
            case credit_card_cvv = "credit_card_cvv"
            case credit_card_expiration = "credit_card_expiration"
            case credit_card_number = "credit_card_number"
            case date = "date"
            case date_interval = "date_interval"
            case date_of_birth = "date_of_birth"
            case drivers_license = "drivers_license"
            case drug = "drug"
            case duration = "duration"
            case email_address = "email_address"
            case event = "event"
            case filename = "filename"
            case gender_sexuality = "gender_sexuality"
            case healthcare_number = "healthcare_number"
            case injury = "injury"
            case ip_address = "ip_address"
            case language = "language"
            case location = "location"
            case marital_status = "marital_status"
            case medical_condition = "medical_condition"
            case medical_process = "medical_process"
            case money_amount = "money_amount"
            case nationality = "nationality"
            case number_sequence = "number_sequence"
            case occupation = "occupation"
            case organization = "organization"
            case passport_number = "passport_number"
            case password = "password"
            case person_age = "person_age"
            case person_name = "person_name"
            case phone_number = "phone_number"
            case physical_attribute = "physical_attribute"
            case political_affiliation = "political_affiliation"
            case religion = "religion"
            case statistics = "statistics"
            case time = "time"
            case url = "url"
            case us_social_security_number = "us_social_security_number"
            case username = "username"
            case vehicle_id = "vehicle_id"
            case zodiac_sign = "zodiac_sign"
        }
        /// The speech model to use for the transcription.
        ///
        /// - Remark: Generated from `#/components/schemas/SpeechModel`.
        @frozen public enum SpeechModel: String, Codable, Hashable, Sendable, CaseIterable {
            case best = "best"
            case nano = "nano"
        }
        /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
        /// The default value is 'en_us'.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptLanguageCode`.
        @frozen public enum TranscriptLanguageCode: String, Codable, Hashable, Sendable, CaseIterable {
            case en = "en"
            case en_au = "en_au"
            case en_uk = "en_uk"
            case en_us = "en_us"
            case es = "es"
            case fr = "fr"
            case de = "de"
            case it = "it"
            case pt = "pt"
            case nl = "nl"
            case af = "af"
            case sq = "sq"
            case am = "am"
            case ar = "ar"
            case hy = "hy"
            case _as = "as"
            case az = "az"
            case ba = "ba"
            case eu = "eu"
            case be = "be"
            case bn = "bn"
            case bs = "bs"
            case br = "br"
            case bg = "bg"
            case my = "my"
            case ca = "ca"
            case zh = "zh"
            case hr = "hr"
            case cs = "cs"
            case da = "da"
            case et = "et"
            case fo = "fo"
            case fi = "fi"
            case gl = "gl"
            case ka = "ka"
            case el = "el"
            case gu = "gu"
            case ht = "ht"
            case ha = "ha"
            case haw = "haw"
            case he = "he"
            case hi = "hi"
            case hu = "hu"
            case _is = "is"
            case id = "id"
            case ja = "ja"
            case jw = "jw"
            case kn = "kn"
            case kk = "kk"
            case km = "km"
            case ko = "ko"
            case lo = "lo"
            case la = "la"
            case lv = "lv"
            case ln = "ln"
            case lt = "lt"
            case lb = "lb"
            case mk = "mk"
            case mg = "mg"
            case ms = "ms"
            case ml = "ml"
            case mt = "mt"
            case mi = "mi"
            case mr = "mr"
            case mn = "mn"
            case ne = "ne"
            case no = "no"
            case nn = "nn"
            case oc = "oc"
            case pa = "pa"
            case ps = "ps"
            case fa = "fa"
            case pl = "pl"
            case ro = "ro"
            case ru = "ru"
            case sa = "sa"
            case sr = "sr"
            case sn = "sn"
            case sd = "sd"
            case si = "si"
            case sk = "sk"
            case sl = "sl"
            case so = "so"
            case su = "su"
            case sw = "sw"
            case sv = "sv"
            case tl = "tl"
            case tg = "tg"
            case ta = "ta"
            case tt = "tt"
            case te = "te"
            case th = "th"
            case bo = "bo"
            case tr = "tr"
            case tk = "tk"
            case uk = "uk"
            case ur = "ur"
            case uz = "uz"
            case vi = "vi"
            case cy = "cy"
            case yi = "yi"
            case yo = "yo"
        }
        /// The status of your transcript. Possible values are queued, processing, completed, or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptStatus`.
        @frozen public enum TranscriptStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case queued = "queued"
            case processing = "processing"
            case completed = "completed"
            case error = "error"
        }
        /// The status of the transcript. Either completed or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptReadyStatus`.
        @frozen public enum TranscriptReadyStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case completed = "completed"
            case error = "error"
        }
        /// A transcript object
        ///
        /// - Remark: Generated from `#/components/schemas/Transcript`.
        public struct Transcript: Codable, Hashable, Sendable {
            /// The unique identifier of your transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/id`.
            public var id: Swift.String
            /// The URL of the media that was transcribed
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_url`.
            public var audio_url: Swift.String
            /// The status of your transcript. Possible values are queued, processing, completed, or error.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/status`.
            public var status: Components.Schemas.TranscriptStatus
            /// The language of your audio file.
            /// Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_code`.
            public struct language_codePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/Transcript/language_code/value1`.
                public var value1: Components.Schemas.TranscriptLanguageCode?
                /// - Remark: Generated from `#/components/schemas/Transcript/language_code/value2`.
                public var value2: Swift.String?
                /// Creates a new `language_codePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.TranscriptLanguageCode? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            value1,
                            value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        value1,
                        value2
                    ])
                }
            }
            /// The language of your audio file.
            /// Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_code`.
            public var language_code: Components.Schemas.Transcript.language_codePayload?
            /// Whether [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_detection`.
            public var language_detection: Swift.Bool?
            /// The confidence threshold for the automatically detected language.
            /// An error will be returned if the language confidence is below this threshold.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_confidence_threshold`.
            public var language_confidence_threshold: Swift.Float?
            /// The confidence score for the detected language, between 0.0 (low confidence) and 1.0 (high confidence)
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_confidence`.
            public var language_confidence: Swift.Double?
            /// The speech model used for the transcription. When `null`, the default model is used.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_model`.
            public var speech_model: Components.Schemas.SpeechModel?
            /// The textual transcript of your media file
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/text`.
            public var text: Swift.String?
            /// An array of temporally-sequential word objects, one for each word in the transcript.
            /// See [Speech recognition](https://www.assemblyai.com/docs/models/speech-recognition) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/words`.
            public var words: [Components.Schemas.TranscriptWord]?
            /// When dual_channel or speaker_labels is enabled, a list of turn-by-turn utterance objects.
            /// See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/utterances`.
            public var utterances: [Components.Schemas.TranscriptUtterance]?
            /// The confidence score for the transcript, between 0.0 (low confidence) and 1.0 (high confidence)
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/confidence`.
            public var confidence: Swift.Double?
            /// The duration of this transcript object's media file, in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_duration`.
            public var audio_duration: Swift.Int?
            /// Whether Automatic Punctuation is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/punctuate`.
            public var punctuate: Swift.Bool?
            /// Whether Text Formatting is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/format_text`.
            public var format_text: Swift.Bool?
            /// Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/disfluencies`.
            public var disfluencies: Swift.Bool?
            /// Whether [Dual channel transcription](https://www.assemblyai.com/docs/models/speech-recognition#dual-channel-transcription) was enabled in the transcription request, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/dual_channel`.
            @available(*, deprecated)
            public var dual_channel: Swift.Bool?
            /// The URL to which we send webhook requests.
            /// We sends two different types of webhook requests.
            /// One request when a transcript is completed or failed, and one request when the redacted audio is ready if redact_pii_audio is enabled.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_url`.
            public var webhook_url: Swift.String?
            /// The status code we received from your server when delivering the transcript completed or failed webhook request, if a webhook URL was provided
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_status_code`.
            public var webhook_status_code: Swift.Int?
            /// Whether webhook authentication details were provided
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_auth`.
            public var webhook_auth: Swift.Bool
            /// The header name to be sent with the transcript completed or failed webhook requests
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_auth_header_name`.
            public var webhook_auth_header_name: Swift.String?
            /// Whether speed boost is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speed_boost`.
            @available(*, deprecated)
            public var speed_boost: Swift.Bool?
            /// Whether Key Phrases is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_highlights`.
            public var auto_highlights: Swift.Bool
            /// An array of results for the Key Phrases model, if it is enabled.
            /// See [Key Phrases](https://www.assemblyai.com/docs/models/key-phrases) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_highlights_result`.
            public var auto_highlights_result: Components.Schemas.AutoHighlightsResult?
            /// The point in time, in milliseconds, in the file at which the transcription was started
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_start_from`.
            public var audio_start_from: Swift.Int?
            /// The point in time, in milliseconds, in the file at which the transcription was terminated
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_end_at`.
            public var audio_end_at: Swift.Int?
            /// The list of custom vocabulary to boost transcription probability for
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/word_boost`.
            public var word_boost: [Swift.String]?
            /// The word boost parameter value
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/boost_param`.
            public var boost_param: Swift.String?
            /// Whether [Profanity Filtering](https://www.assemblyai.com/docs/models/speech-recognition#profanity-filtering) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/filter_profanity`.
            public var filter_profanity: Swift.Bool?
            /// Whether [PII Redaction](https://www.assemblyai.com/docs/models/pii-redaction) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii`.
            public var redact_pii: Swift.Bool
            /// Whether a redacted version of the audio file was generated,
            /// either true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_audio`.
            public var redact_pii_audio: Swift.Bool?
            /// The audio quality of the PII-redacted audio file, if redact_pii_audio is enabled.
            /// See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_audio_quality`.
            public var redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality?
            /// The list of PII Redaction policies that were enabled, if PII Redaction is enabled.
            /// See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_policies`.
            public var redact_pii_policies: [Components.Schemas.PiiPolicy]?
            /// The replacement logic for detected PII, can be "entity_type" or "hash". See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_sub`.
            public var redact_pii_sub: Components.Schemas.SubstitutionPolicy?
            /// Whether [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speaker_labels`.
            public var speaker_labels: Swift.Bool?
            /// Tell the speaker label model how many speakers it should attempt to identify, up to 10. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speakers_expected`.
            public var speakers_expected: Swift.Int?
            /// Whether [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/content_safety`.
            public var content_safety: Swift.Bool?
            /// An array of results for the Content Moderation model, if it is enabled.
            /// See [Content moderation](https://www.assemblyai.com/docs/models/content-moderation) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/content_safety_labels`.
            public var content_safety_labels: Components.Schemas.ContentSafetyLabelsResult?
            /// Whether [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/iab_categories`.
            public var iab_categories: Swift.Bool?
            /// The result of the Topic Detection model, if it is enabled.
            /// See [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/iab_categories_result`.
            public var iab_categories_result: Components.Schemas.TopicDetectionModelResult?
            /// Customize how words are spelled and formatted using to and from values
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/custom_spelling`.
            public var custom_spelling: [Components.Schemas.TranscriptCustomSpelling]?
            /// Whether [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_chapters`.
            public var auto_chapters: Swift.Bool?
            /// An array of temporally sequential chapters for the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/chapters`.
            public var chapters: [Components.Schemas.Chapter]?
            /// Whether [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summarization`.
            public var summarization: Swift.Bool
            /// The type of summary generated, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary_type`.
            public var summary_type: Swift.String?
            /// The Summarization model used to generate the summary,
            /// if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary_model`.
            public var summary_model: Swift.String?
            /// The generated summary of the media file, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary`.
            public var summary: Swift.String?
            /// Whether custom topics is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/custom_topics`.
            public var custom_topics: Swift.Bool?
            /// The list of custom topics provided if custom topics is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/topics`.
            public var topics: [Swift.String]?
            /// Whether [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/sentiment_analysis`.
            public var sentiment_analysis: Swift.Bool?
            /// An array of results for the Sentiment Analysis model, if it is enabled.
            /// See [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/sentiment_analysis_results`.
            public var sentiment_analysis_results: [Components.Schemas.SentimentAnalysisResult]?
            /// Whether [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/entity_detection`.
            public var entity_detection: Swift.Bool?
            /// An array of results for the Entity Detection model, if it is enabled.
            /// See [Entity detection](https://www.assemblyai.com/docs/models/entity-detection) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/entities`.
            public var entities: [Components.Schemas.Entity]?
            /// Defaults to null. Reject audio files that contain less than this fraction of speech.
            /// Valid values are in the range [0, 1] inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_threshold`.
            public var speech_threshold: Swift.Float?
            /// True while a request is throttled and false when a request is no longer throttled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/throttled`.
            public var throttled: Swift.Bool?
            /// Error message of why the transcript failed
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/error`.
            public var error: Swift.String?
            /// The language model that was used for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_model`.
            @available(*, deprecated)
            public var language_model: Swift.String?
            /// The acoustic model that was used for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/acoustic_model`.
            @available(*, deprecated)
            public var acoustic_model: Swift.String?
            /// A container of undocumented properties.
            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
            /// Creates a new `Transcript`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of your transcript
            ///   - audio_url: The URL of the media that was transcribed
            ///   - status: The status of your transcript. Possible values are queued, processing, completed, or error.
            ///   - language_code: The language of your audio file.
            ///   - language_detection: Whether [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection) is enabled, either true or false
            ///   - language_confidence_threshold: The confidence threshold for the automatically detected language.
            ///   - language_confidence: The confidence score for the detected language, between 0.0 (low confidence) and 1.0 (high confidence)
            ///   - speech_model: The speech model used for the transcription. When `null`, the default model is used.
            ///   - text: The textual transcript of your media file
            ///   - words: An array of temporally-sequential word objects, one for each word in the transcript.
            ///   - utterances: When dual_channel or speaker_labels is enabled, a list of turn-by-turn utterance objects.
            ///   - confidence: The confidence score for the transcript, between 0.0 (low confidence) and 1.0 (high confidence)
            ///   - audio_duration: The duration of this transcript object's media file, in seconds
            ///   - punctuate: Whether Automatic Punctuation is enabled, either true or false
            ///   - format_text: Whether Text Formatting is enabled, either true or false
            ///   - disfluencies: Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///   - dual_channel: Whether [Dual channel transcription](https://www.assemblyai.com/docs/models/speech-recognition#dual-channel-transcription) was enabled in the transcription request, either true or false
            ///   - webhook_url: The URL to which we send webhook requests.
            ///   - webhook_status_code: The status code we received from your server when delivering the transcript completed or failed webhook request, if a webhook URL was provided
            ///   - webhook_auth: Whether webhook authentication details were provided
            ///   - webhook_auth_header_name: The header name to be sent with the transcript completed or failed webhook requests
            ///   - speed_boost: Whether speed boost is enabled
            ///   - auto_highlights: Whether Key Phrases is enabled, either true or false
            ///   - auto_highlights_result: An array of results for the Key Phrases model, if it is enabled.
            ///   - audio_start_from: The point in time, in milliseconds, in the file at which the transcription was started
            ///   - audio_end_at: The point in time, in milliseconds, in the file at which the transcription was terminated
            ///   - word_boost: The list of custom vocabulary to boost transcription probability for
            ///   - boost_param: The word boost parameter value
            ///   - filter_profanity: Whether [Profanity Filtering](https://www.assemblyai.com/docs/models/speech-recognition#profanity-filtering) is enabled, either true or false
            ///   - redact_pii: Whether [PII Redaction](https://www.assemblyai.com/docs/models/pii-redaction) is enabled, either true or false
            ///   - redact_pii_audio: Whether a redacted version of the audio file was generated,
            ///   - redact_pii_audio_quality: The audio quality of the PII-redacted audio file, if redact_pii_audio is enabled.
            ///   - redact_pii_policies: The list of PII Redaction policies that were enabled, if PII Redaction is enabled.
            ///   - redact_pii_sub: The replacement logic for detected PII, can be "entity_type" or "hash". See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - speaker_labels: Whether [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, can be true or false
            ///   - speakers_expected: Tell the speaker label model how many speakers it should attempt to identify, up to 10. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///   - content_safety: Whether [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation) is enabled, can be true or false
            ///   - content_safety_labels: An array of results for the Content Moderation model, if it is enabled.
            ///   - iab_categories: Whether [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) is enabled, can be true or false
            ///   - iab_categories_result: The result of the Topic Detection model, if it is enabled.
            ///   - custom_spelling: Customize how words are spelled and formatted using to and from values
            ///   - auto_chapters: Whether [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters) is enabled, can be true or false
            ///   - chapters: An array of temporally sequential chapters for the audio file
            ///   - summarization: Whether [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled, either true or false
            ///   - summary_type: The type of summary generated, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///   - summary_model: The Summarization model used to generate the summary,
            ///   - summary: The generated summary of the media file, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///   - custom_topics: Whether custom topics is enabled, either true or false
            ///   - topics: The list of custom topics provided if custom topics is enabled
            ///   - sentiment_analysis: Whether [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) is enabled, can be true or false
            ///   - sentiment_analysis_results: An array of results for the Sentiment Analysis model, if it is enabled.
            ///   - entity_detection: Whether [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection) is enabled, can be true or false
            ///   - entities: An array of results for the Entity Detection model, if it is enabled.
            ///   - speech_threshold: Defaults to null. Reject audio files that contain less than this fraction of speech.
            ///   - throttled: True while a request is throttled and false when a request is no longer throttled
            ///   - error: Error message of why the transcript failed
            ///   - language_model: The language model that was used for the transcript
            ///   - acoustic_model: The acoustic model that was used for the transcript
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                id: Swift.String,
                audio_url: Swift.String,
                status: Components.Schemas.TranscriptStatus,
                language_code: Components.Schemas.Transcript.language_codePayload? = nil,
                language_detection: Swift.Bool? = nil,
                language_confidence_threshold: Swift.Float? = nil,
                language_confidence: Swift.Double? = nil,
                speech_model: Components.Schemas.SpeechModel? = nil,
                text: Swift.String? = nil,
                words: [Components.Schemas.TranscriptWord]? = nil,
                utterances: [Components.Schemas.TranscriptUtterance]? = nil,
                confidence: Swift.Double? = nil,
                audio_duration: Swift.Int? = nil,
                punctuate: Swift.Bool? = nil,
                format_text: Swift.Bool? = nil,
                disfluencies: Swift.Bool? = nil,
                dual_channel: Swift.Bool? = nil,
                webhook_url: Swift.String? = nil,
                webhook_status_code: Swift.Int? = nil,
                webhook_auth: Swift.Bool,
                webhook_auth_header_name: Swift.String? = nil,
                speed_boost: Swift.Bool? = nil,
                auto_highlights: Swift.Bool,
                auto_highlights_result: Components.Schemas.AutoHighlightsResult? = nil,
                audio_start_from: Swift.Int? = nil,
                audio_end_at: Swift.Int? = nil,
                word_boost: [Swift.String]? = nil,
                boost_param: Swift.String? = nil,
                filter_profanity: Swift.Bool? = nil,
                redact_pii: Swift.Bool,
                redact_pii_audio: Swift.Bool? = nil,
                redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality? = nil,
                redact_pii_policies: [Components.Schemas.PiiPolicy]? = nil,
                redact_pii_sub: Components.Schemas.SubstitutionPolicy? = nil,
                speaker_labels: Swift.Bool? = nil,
                speakers_expected: Swift.Int? = nil,
                content_safety: Swift.Bool? = nil,
                content_safety_labels: Components.Schemas.ContentSafetyLabelsResult? = nil,
                iab_categories: Swift.Bool? = nil,
                iab_categories_result: Components.Schemas.TopicDetectionModelResult? = nil,
                custom_spelling: [Components.Schemas.TranscriptCustomSpelling]? = nil,
                auto_chapters: Swift.Bool? = nil,
                chapters: [Components.Schemas.Chapter]? = nil,
                summarization: Swift.Bool,
                summary_type: Swift.String? = nil,
                summary_model: Swift.String? = nil,
                summary: Swift.String? = nil,
                custom_topics: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                sentiment_analysis: Swift.Bool? = nil,
                sentiment_analysis_results: [Components.Schemas.SentimentAnalysisResult]? = nil,
                entity_detection: Swift.Bool? = nil,
                entities: [Components.Schemas.Entity]? = nil,
                speech_threshold: Swift.Float? = nil,
                throttled: Swift.Bool? = nil,
                error: Swift.String? = nil,
                language_model: Swift.String? = nil,
                acoustic_model: Swift.String? = nil,
                additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()
            ) {
                self.id = id
                self.audio_url = audio_url
                self.status = status
                self.language_code = language_code
                self.language_detection = language_detection
                self.language_confidence_threshold = language_confidence_threshold
                self.language_confidence = language_confidence
                self.speech_model = speech_model
                self.text = text
                self.words = words
                self.utterances = utterances
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.punctuate = punctuate
                self.format_text = format_text
                self.disfluencies = disfluencies
                self.dual_channel = dual_channel
                self.webhook_url = webhook_url
                self.webhook_status_code = webhook_status_code
                self.webhook_auth = webhook_auth
                self.webhook_auth_header_name = webhook_auth_header_name
                self.speed_boost = speed_boost
                self.auto_highlights = auto_highlights
                self.auto_highlights_result = auto_highlights_result
                self.audio_start_from = audio_start_from
                self.audio_end_at = audio_end_at
                self.word_boost = word_boost
                self.boost_param = boost_param
                self.filter_profanity = filter_profanity
                self.redact_pii = redact_pii
                self.redact_pii_audio = redact_pii_audio
                self.redact_pii_audio_quality = redact_pii_audio_quality
                self.redact_pii_policies = redact_pii_policies
                self.redact_pii_sub = redact_pii_sub
                self.speaker_labels = speaker_labels
                self.speakers_expected = speakers_expected
                self.content_safety = content_safety
                self.content_safety_labels = content_safety_labels
                self.iab_categories = iab_categories
                self.iab_categories_result = iab_categories_result
                self.custom_spelling = custom_spelling
                self.auto_chapters = auto_chapters
                self.chapters = chapters
                self.summarization = summarization
                self.summary_type = summary_type
                self.summary_model = summary_model
                self.summary = summary
                self.custom_topics = custom_topics
                self.topics = topics
                self.sentiment_analysis = sentiment_analysis
                self.sentiment_analysis_results = sentiment_analysis_results
                self.entity_detection = entity_detection
                self.entities = entities
                self.speech_threshold = speech_threshold
                self.throttled = throttled
                self.error = error
                self.language_model = language_model
                self.acoustic_model = acoustic_model
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case audio_url
                case status
                case language_code
                case language_detection
                case language_confidence_threshold
                case language_confidence
                case speech_model
                case text
                case words
                case utterances
                case confidence
                case audio_duration
                case punctuate
                case format_text
                case disfluencies
                case dual_channel
                case webhook_url
                case webhook_status_code
                case webhook_auth
                case webhook_auth_header_name
                case speed_boost
                case auto_highlights
                case auto_highlights_result
                case audio_start_from
                case audio_end_at
                case word_boost
                case boost_param
                case filter_profanity
                case redact_pii
                case redact_pii_audio
                case redact_pii_audio_quality
                case redact_pii_policies
                case redact_pii_sub
                case speaker_labels
                case speakers_expected
                case content_safety
                case content_safety_labels
                case iab_categories
                case iab_categories_result
                case custom_spelling
                case auto_chapters
                case chapters
                case summarization
                case summary_type
                case summary_model
                case summary
                case custom_topics
                case topics
                case sentiment_analysis
                case sentiment_analysis_results
                case entity_detection
                case entities
                case speech_threshold
                case throttled
                case error
                case language_model
                case acoustic_model
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .audio_url
                )
                status = try container.decode(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                language_code = try container.decodeIfPresent(
                    Components.Schemas.Transcript.language_codePayload.self,
                    forKey: .language_code
                )
                language_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .language_detection
                )
                language_confidence_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .language_confidence_threshold
                )
                language_confidence = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .language_confidence
                )
                speech_model = try container.decodeIfPresent(
                    Components.Schemas.SpeechModel.self,
                    forKey: .speech_model
                )
                text = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .text
                )
                words = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                utterances = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptUtterance].self,
                    forKey: .utterances
                )
                confidence = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .confidence
                )
                audio_duration = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_duration
                )
                punctuate = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .punctuate
                )
                format_text = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .format_text
                )
                disfluencies = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .disfluencies
                )
                dual_channel = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .dual_channel
                )
                webhook_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_url
                )
                webhook_status_code = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .webhook_status_code
                )
                webhook_auth = try container.decode(
                    Swift.Bool.self,
                    forKey: .webhook_auth
                )
                webhook_auth_header_name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_name
                )
                speed_boost = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speed_boost
                )
                auto_highlights = try container.decode(
                    Swift.Bool.self,
                    forKey: .auto_highlights
                )
                auto_highlights_result = try container.decodeIfPresent(
                    Components.Schemas.AutoHighlightsResult.self,
                    forKey: .auto_highlights_result
                )
                audio_start_from = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_start_from
                )
                audio_end_at = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_end_at
                )
                word_boost = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .word_boost
                )
                boost_param = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .boost_param
                )
                filter_profanity = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .filter_profanity
                )
                redact_pii = try container.decode(
                    Swift.Bool.self,
                    forKey: .redact_pii
                )
                redact_pii_audio = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii_audio
                )
                redact_pii_audio_quality = try container.decodeIfPresent(
                    Components.Schemas.RedactPiiAudioQuality.self,
                    forKey: .redact_pii_audio_quality
                )
                redact_pii_policies = try container.decodeIfPresent(
                    [Components.Schemas.PiiPolicy].self,
                    forKey: .redact_pii_policies
                )
                redact_pii_sub = try container.decodeIfPresent(
                    Components.Schemas.SubstitutionPolicy.self,
                    forKey: .redact_pii_sub
                )
                speaker_labels = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speaker_labels
                )
                speakers_expected = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .speakers_expected
                )
                content_safety = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .content_safety
                )
                content_safety_labels = try container.decodeIfPresent(
                    Components.Schemas.ContentSafetyLabelsResult.self,
                    forKey: .content_safety_labels
                )
                iab_categories = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .iab_categories
                )
                iab_categories_result = try container.decodeIfPresent(
                    Components.Schemas.TopicDetectionModelResult.self,
                    forKey: .iab_categories_result
                )
                custom_spelling = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptCustomSpelling].self,
                    forKey: .custom_spelling
                )
                auto_chapters = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_chapters
                )
                chapters = try container.decodeIfPresent(
                    [Components.Schemas.Chapter].self,
                    forKey: .chapters
                )
                summarization = try container.decode(
                    Swift.Bool.self,
                    forKey: .summarization
                )
                summary_type = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary_type
                )
                summary_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary_model
                )
                summary = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary
                )
                custom_topics = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .custom_topics
                )
                topics = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .topics
                )
                sentiment_analysis = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .sentiment_analysis
                )
                sentiment_analysis_results = try container.decodeIfPresent(
                    [Components.Schemas.SentimentAnalysisResult].self,
                    forKey: .sentiment_analysis_results
                )
                entity_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .entity_detection
                )
                entities = try container.decodeIfPresent(
                    [Components.Schemas.Entity].self,
                    forKey: .entities
                )
                speech_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .speech_threshold
                )
                throttled = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .throttled
                )
                error = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .error
                )
                language_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .language_model
                )
                acoustic_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .acoustic_model
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "id",
                    "audio_url",
                    "status",
                    "language_code",
                    "language_detection",
                    "language_confidence_threshold",
                    "language_confidence",
                    "speech_model",
                    "text",
                    "words",
                    "utterances",
                    "confidence",
                    "audio_duration",
                    "punctuate",
                    "format_text",
                    "disfluencies",
                    "dual_channel",
                    "webhook_url",
                    "webhook_status_code",
                    "webhook_auth",
                    "webhook_auth_header_name",
                    "speed_boost",
                    "auto_highlights",
                    "auto_highlights_result",
                    "audio_start_from",
                    "audio_end_at",
                    "word_boost",
                    "boost_param",
                    "filter_profanity",
                    "redact_pii",
                    "redact_pii_audio",
                    "redact_pii_audio_quality",
                    "redact_pii_policies",
                    "redact_pii_sub",
                    "speaker_labels",
                    "speakers_expected",
                    "content_safety",
                    "content_safety_labels",
                    "iab_categories",
                    "iab_categories_result",
                    "custom_spelling",
                    "auto_chapters",
                    "chapters",
                    "summarization",
                    "summary_type",
                    "summary_model",
                    "summary",
                    "custom_topics",
                    "topics",
                    "sentiment_analysis",
                    "sentiment_analysis_results",
                    "entity_detection",
                    "entities",
                    "speech_threshold",
                    "throttled",
                    "error",
                    "language_model",
                    "acoustic_model"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(
                    id,
                    forKey: .id
                )
                try container.encode(
                    audio_url,
                    forKey: .audio_url
                )
                try container.encode(
                    status,
                    forKey: .status
                )
                try container.encodeIfPresent(
                    language_code,
                    forKey: .language_code
                )
                try container.encodeIfPresent(
                    language_detection,
                    forKey: .language_detection
                )
                try container.encodeIfPresent(
                    language_confidence_threshold,
                    forKey: .language_confidence_threshold
                )
                try container.encodeIfPresent(
                    language_confidence,
                    forKey: .language_confidence
                )
                try container.encodeIfPresent(
                    speech_model,
                    forKey: .speech_model
                )
                try container.encodeIfPresent(
                    text,
                    forKey: .text
                )
                try container.encodeIfPresent(
                    words,
                    forKey: .words
                )
                try container.encodeIfPresent(
                    utterances,
                    forKey: .utterances
                )
                try container.encodeIfPresent(
                    confidence,
                    forKey: .confidence
                )
                try container.encodeIfPresent(
                    audio_duration,
                    forKey: .audio_duration
                )
                try container.encodeIfPresent(
                    punctuate,
                    forKey: .punctuate
                )
                try container.encodeIfPresent(
                    format_text,
                    forKey: .format_text
                )
                try container.encodeIfPresent(
                    disfluencies,
                    forKey: .disfluencies
                )
                try container.encodeIfPresent(
                    dual_channel,
                    forKey: .dual_channel
                )
                try container.encodeIfPresent(
                    webhook_url,
                    forKey: .webhook_url
                )
                try container.encodeIfPresent(
                    webhook_status_code,
                    forKey: .webhook_status_code
                )
                try container.encode(
                    webhook_auth,
                    forKey: .webhook_auth
                )
                try container.encodeIfPresent(
                    webhook_auth_header_name,
                    forKey: .webhook_auth_header_name
                )
                try container.encodeIfPresent(
                    speed_boost,
                    forKey: .speed_boost
                )
                try container.encode(
                    auto_highlights,
                    forKey: .auto_highlights
                )
                try container.encodeIfPresent(
                    auto_highlights_result,
                    forKey: .auto_highlights_result
                )
                try container.encodeIfPresent(
                    audio_start_from,
                    forKey: .audio_start_from
                )
                try container.encodeIfPresent(
                    audio_end_at,
                    forKey: .audio_end_at
                )
                try container.encodeIfPresent(
                    word_boost,
                    forKey: .word_boost
                )
                try container.encodeIfPresent(
                    boost_param,
                    forKey: .boost_param
                )
                try container.encodeIfPresent(
                    filter_profanity,
                    forKey: .filter_profanity
                )
                try container.encode(
                    redact_pii,
                    forKey: .redact_pii
                )
                try container.encodeIfPresent(
                    redact_pii_audio,
                    forKey: .redact_pii_audio
                )
                try container.encodeIfPresent(
                    redact_pii_audio_quality,
                    forKey: .redact_pii_audio_quality
                )
                try container.encodeIfPresent(
                    redact_pii_policies,
                    forKey: .redact_pii_policies
                )
                try container.encodeIfPresent(
                    redact_pii_sub,
                    forKey: .redact_pii_sub
                )
                try container.encodeIfPresent(
                    speaker_labels,
                    forKey: .speaker_labels
                )
                try container.encodeIfPresent(
                    speakers_expected,
                    forKey: .speakers_expected
                )
                try container.encodeIfPresent(
                    content_safety,
                    forKey: .content_safety
                )
                try container.encodeIfPresent(
                    content_safety_labels,
                    forKey: .content_safety_labels
                )
                try container.encodeIfPresent(
                    iab_categories,
                    forKey: .iab_categories
                )
                try container.encodeIfPresent(
                    iab_categories_result,
                    forKey: .iab_categories_result
                )
                try container.encodeIfPresent(
                    custom_spelling,
                    forKey: .custom_spelling
                )
                try container.encodeIfPresent(
                    auto_chapters,
                    forKey: .auto_chapters
                )
                try container.encodeIfPresent(
                    chapters,
                    forKey: .chapters
                )
                try container.encode(
                    summarization,
                    forKey: .summarization
                )
                try container.encodeIfPresent(
                    summary_type,
                    forKey: .summary_type
                )
                try container.encodeIfPresent(
                    summary_model,
                    forKey: .summary_model
                )
                try container.encodeIfPresent(
                    summary,
                    forKey: .summary
                )
                try container.encodeIfPresent(
                    custom_topics,
                    forKey: .custom_topics
                )
                try container.encodeIfPresent(
                    topics,
                    forKey: .topics
                )
                try container.encodeIfPresent(
                    sentiment_analysis,
                    forKey: .sentiment_analysis
                )
                try container.encodeIfPresent(
                    sentiment_analysis_results,
                    forKey: .sentiment_analysis_results
                )
                try container.encodeIfPresent(
                    entity_detection,
                    forKey: .entity_detection
                )
                try container.encodeIfPresent(
                    entities,
                    forKey: .entities
                )
                try container.encodeIfPresent(
                    speech_threshold,
                    forKey: .speech_threshold
                )
                try container.encodeIfPresent(
                    throttled,
                    forKey: .throttled
                )
                try container.encodeIfPresent(
                    error,
                    forKey: .error
                )
                try container.encodeIfPresent(
                    language_model,
                    forKey: .language_model
                )
                try container.encodeIfPresent(
                    acoustic_model,
                    forKey: .acoustic_model
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// The result of the Topic Detection model, if it is enabled.
        /// See [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult`.
        public struct TopicDetectionModelResult: Codable, Hashable, Sendable {
            /// The status of the Topic Detection model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus?
            /// An array of results for the Topic Detection model
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/results`.
            public var results: [Components.Schemas.TopicDetectionResult]?
            /// The overall relevance of topic to the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/summary`.
            public struct summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.Double]
                /// Creates a new `summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.Double] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// The overall relevance of topic to the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/summary`.
            public var summary: Components.Schemas.TopicDetectionModelResult.summaryPayload?
            /// Creates a new `TopicDetectionModelResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Topic Detection model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: An array of results for the Topic Detection model
            ///   - summary: The overall relevance of topic to the entire audio file
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus? = nil,
                results: [Components.Schemas.TopicDetectionResult]? = nil,
                summary: Components.Schemas.TopicDetectionModelResult.summaryPayload? = nil
            ) {
                self.status = status
                self.results = results
                self.summary = summary
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
                case summary
            }
        }
        /// An array of results for the Content Moderation model, if it is enabled.
        /// See [Content moderation](https://www.assemblyai.com/docs/models/content-moderation) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult`.
        public struct ContentSafetyLabelsResult: Codable, Hashable, Sendable {
            /// The status of the Content Moderation model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus?
            /// An array of results for the Content Moderation model
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/results`.
            public var results: [Components.Schemas.ContentSafetyLabelResult]?
            /// A summary of the Content Moderation confidence results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/summary`.
            public struct summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.Double]
                /// Creates a new `summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.Double] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A summary of the Content Moderation confidence results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/summary`.
            public var summary: Components.Schemas.ContentSafetyLabelsResult.summaryPayload?
            /// A summary of the Content Moderation severity results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/severity_score_summary`.
            public struct severity_score_summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.SeverityScoreSummary]
                /// Creates a new `severity_score_summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.SeverityScoreSummary] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A summary of the Content Moderation severity results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/severity_score_summary`.
            public var severity_score_summary: Components.Schemas.ContentSafetyLabelsResult.severity_score_summaryPayload?
            /// Creates a new `ContentSafetyLabelsResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Content Moderation model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: An array of results for the Content Moderation model
            ///   - summary: A summary of the Content Moderation confidence results for the entire audio file
            ///   - severity_score_summary: A summary of the Content Moderation severity results for the entire audio file
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus? = nil,
                results: [Components.Schemas.ContentSafetyLabelResult]? = nil,
                summary: Components.Schemas.ContentSafetyLabelsResult.summaryPayload? = nil,
                severity_score_summary: Components.Schemas.ContentSafetyLabelsResult.severity_score_summaryPayload? = nil
            ) {
                self.status = status
                self.results = results
                self.summary = summary
                self.severity_score_summary = severity_score_summary
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
                case summary
                case severity_score_summary
            }
        }
        /// Chapter of the audio file
        ///
        /// - Remark: Generated from `#/components/schemas/Chapter`.
        public struct Chapter: Codable, Hashable, Sendable {
            /// An ultra-short summary (just a few words) of the content spoken in the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/gist`.
            public var gist: Swift.String
            /// A single sentence summary of the content spoken during the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/headline`.
            public var headline: Swift.String
            /// A one paragraph summary of the content spoken during the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/summary`.
            public var summary: Swift.String
            /// The starting time, in milliseconds, for the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/start`.
            public var start: Swift.Int
            /// The starting time, in milliseconds, for the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/end`.
            public var end: Swift.Int
            /// Creates a new `Chapter`.
            ///
            /// - Parameters:
            ///   - gist: An ultra-short summary (just a few words) of the content spoken in the chapter
            ///   - headline: A single sentence summary of the content spoken during the chapter
            ///   - summary: A one paragraph summary of the content spoken during the chapter
            ///   - start: The starting time, in milliseconds, for the chapter
            ///   - end: The starting time, in milliseconds, for the chapter
            public init(
                gist: Swift.String,
                headline: Swift.String,
                summary: Swift.String,
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.gist = gist
                self.headline = headline
                self.summary = summary
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case gist
                case headline
                case summary
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                gist = try container.decode(
                    Swift.String.self,
                    forKey: .gist
                )
                headline = try container.decode(
                    Swift.String.self,
                    forKey: .headline
                )
                summary = try container.decode(
                    Swift.String.self,
                    forKey: .summary
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "gist",
                    "headline",
                    "summary",
                    "start",
                    "end"
                ])
            }
        }
        /// A detected entity
        ///
        /// - Remark: Generated from `#/components/schemas/Entity`.
        public struct Entity: Codable, Hashable, Sendable {
            /// The type of entity for the detected entity
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/entity_type`.
            public var entity_type: Components.Schemas.EntityType
            /// The text for the detected entity
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, at which the detected entity appears in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the detected entity in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/end`.
            public var end: Swift.Int
            /// Creates a new `Entity`.
            ///
            /// - Parameters:
            ///   - entity_type: The type of entity for the detected entity
            ///   - text: The text for the detected entity
            ///   - start: The starting time, in milliseconds, at which the detected entity appears in the audio file
            ///   - end: The ending time, in milliseconds, for the detected entity in the audio file
            public init(
                entity_type: Components.Schemas.EntityType,
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.entity_type = entity_type
                self.text = text
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case entity_type
                case text
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                entity_type = try container.decode(
                    Components.Schemas.EntityType.self,
                    forKey: .entity_type
                )
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "entity_type",
                    "text",
                    "start",
                    "end"
                ])
            }
        }
        /// The type of entity for the detected entity
        ///
        /// - Remark: Generated from `#/components/schemas/EntityType`.
        @frozen public enum EntityType: String, Codable, Hashable, Sendable, CaseIterable {
            case account_number = "account_number"
            case banking_information = "banking_information"
            case blood_type = "blood_type"
            case credit_card_cvv = "credit_card_cvv"
            case credit_card_expiration = "credit_card_expiration"
            case credit_card_number = "credit_card_number"
            case date = "date"
            case date_interval = "date_interval"
            case date_of_birth = "date_of_birth"
            case drivers_license = "drivers_license"
            case drug = "drug"
            case duration = "duration"
            case email_address = "email_address"
            case event = "event"
            case filename = "filename"
            case gender_sexuality = "gender_sexuality"
            case healthcare_number = "healthcare_number"
            case injury = "injury"
            case ip_address = "ip_address"
            case language = "language"
            case location = "location"
            case marital_status = "marital_status"
            case medical_condition = "medical_condition"
            case medical_process = "medical_process"
            case money_amount = "money_amount"
            case nationality = "nationality"
            case number_sequence = "number_sequence"
            case occupation = "occupation"
            case organization = "organization"
            case passport_number = "passport_number"
            case password = "password"
            case person_age = "person_age"
            case person_name = "person_name"
            case phone_number = "phone_number"
            case physical_attribute = "physical_attribute"
            case political_affiliation = "political_affiliation"
            case religion = "religion"
            case statistics = "statistics"
            case time = "time"
            case url = "url"
            case us_social_security_number = "us_social_security_number"
            case username = "username"
            case vehicle_id = "vehicle_id"
            case zodiac_sign = "zodiac_sign"
        }
        /// The result of the Sentiment Analysis model
        ///
        /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult`.
        public struct SentimentAnalysisResult: Codable, Hashable, Sendable {
            /// The transcript of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/end`.
            public var end: Swift.Int
            /// The detected sentiment for the sentence, one of POSITIVE, NEUTRAL, NEGATIVE
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/sentiment`.
            public var sentiment: Components.Schemas.Sentiment
            /// The confidence score for the detected sentiment of the sentence, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/confidence`.
            public var confidence: Swift.Double
            /// The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/channel`.
            public var channel: Swift.String?
            /// The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/speaker`.
            public var speaker: Swift.String
            /// Creates a new `SentimentAnalysisResult`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the sentence
            ///   - start: The starting time, in milliseconds, of the sentence
            ///   - end: The ending time, in milliseconds, of the sentence
            ///   - sentiment: The detected sentiment for the sentence, one of POSITIVE, NEUTRAL, NEGATIVE
            ///   - confidence: The confidence score for the detected sentiment of the sentence, from 0 to 1
            ///   - channel: The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                sentiment: Components.Schemas.Sentiment,
                confidence: Swift.Double,
                channel: Swift.String? = nil,
                speaker: Swift.String
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.sentiment = sentiment
                self.confidence = confidence
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case sentiment
                case confidence
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                sentiment = try container.decode(
                    Components.Schemas.Sentiment.self,
                    forKey: .sentiment
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                speaker = try container.decode(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "sentiment",
                    "confidence",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/Sentiment`.
        public typealias Sentiment = OpenAPIRuntime.OpenAPIValueContainer
        /// The result of the topic detection model
        ///
        /// - Remark: Generated from `#/components/schemas/TopicDetectionResult`.
        public struct TopicDetectionResult: Codable, Hashable, Sendable {
            /// The text in the transcript in which a detected topic occurs
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload`.
            public struct labelsPayloadPayload: Codable, Hashable, Sendable {
                /// How relevant the detected topic is of a detected topic
                ///
                /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload/relevance`.
                public var relevance: Swift.Double
                /// The IAB taxonomical label for the label of the detected topic, where > denotes supertopic/subtopic relationship
                ///
                /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload/label`.
                public var label: Swift.String
                /// Creates a new `labelsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - relevance: How relevant the detected topic is of a detected topic
                ///   - label: The IAB taxonomical label for the label of the detected topic, where > denotes supertopic/subtopic relationship
                public init(
                    relevance: Swift.Double,
                    label: Swift.String
                ) {
                    self.relevance = relevance
                    self.label = label
                }
                public enum CodingKeys: String, CodingKey {
                    case relevance
                    case label
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    relevance = try container.decode(
                        Swift.Double.self,
                        forKey: .relevance
                    )
                    label = try container.decode(
                        Swift.String.self,
                        forKey: .label
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "relevance",
                        "label"
                    ])
                }
            }
            /// An array of detected topics in the text
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labels`.
            public typealias labelsPayload = [Components.Schemas.TopicDetectionResult.labelsPayloadPayload]
            /// An array of detected topics in the text
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labels`.
            public var labels: Components.Schemas.TopicDetectionResult.labelsPayload?
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/timestamp`.
            public var timestamp: Components.Schemas.Timestamp?
            /// Creates a new `TopicDetectionResult`.
            ///
            /// - Parameters:
            ///   - text: The text in the transcript in which a detected topic occurs
            ///   - labels: An array of detected topics in the text
            ///   - timestamp:
            public init(
                text: Swift.String,
                labels: Components.Schemas.TopicDetectionResult.labelsPayload? = nil,
                timestamp: Components.Schemas.Timestamp? = nil
            ) {
                self.text = text
                self.labels = labels
                self.timestamp = timestamp
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case labels
                case timestamp
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                labels = try container.decodeIfPresent(
                    Components.Schemas.TopicDetectionResult.labelsPayload.self,
                    forKey: .labels
                )
                timestamp = try container.decodeIfPresent(
                    Components.Schemas.Timestamp.self,
                    forKey: .timestamp
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "labels",
                    "timestamp"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel`.
        public struct ContentSafetyLabel: Codable, Hashable, Sendable {
            /// The label of the sensitive topic
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/label`.
            public var label: Swift.String
            /// The confidence score for the topic being discussed, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/confidence`.
            public var confidence: Swift.Double
            /// How severely the topic is discussed in the section, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/severity`.
            public var severity: Swift.Double
            /// Creates a new `ContentSafetyLabel`.
            ///
            /// - Parameters:
            ///   - label: The label of the sensitive topic
            ///   - confidence: The confidence score for the topic being discussed, from 0 to 1
            ///   - severity: How severely the topic is discussed in the section, from 0 to 1
            public init(
                label: Swift.String,
                confidence: Swift.Double,
                severity: Swift.Double
            ) {
                self.label = label
                self.confidence = confidence
                self.severity = severity
            }
            public enum CodingKeys: String, CodingKey {
                case label
                case confidence
                case severity
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                label = try container.decode(
                    Swift.String.self,
                    forKey: .label
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                severity = try container.decode(
                    Swift.Double.self,
                    forKey: .severity
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "label",
                    "confidence",
                    "severity"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult`.
        public struct ContentSafetyLabelResult: Codable, Hashable, Sendable {
            /// The transcript of the section flagged by the Content Moderation model
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/text`.
            public var text: Swift.String
            /// An array of safety labels, one per sensitive topic that was detected in the section
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/labels`.
            public var labels: [Components.Schemas.ContentSafetyLabel]
            /// The sentence index at which the section begins
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/sentences_idx_start`.
            public var sentences_idx_start: Swift.Int
            /// The sentence index at which the section ends
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/sentences_idx_end`.
            public var sentences_idx_end: Swift.Int
            /// Timestamp information for the section
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/timestamp`.
            public var timestamp: Components.Schemas.Timestamp
            /// Creates a new `ContentSafetyLabelResult`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the section flagged by the Content Moderation model
            ///   - labels: An array of safety labels, one per sensitive topic that was detected in the section
            ///   - sentences_idx_start: The sentence index at which the section begins
            ///   - sentences_idx_end: The sentence index at which the section ends
            ///   - timestamp: Timestamp information for the section
            public init(
                text: Swift.String,
                labels: [Components.Schemas.ContentSafetyLabel],
                sentences_idx_start: Swift.Int,
                sentences_idx_end: Swift.Int,
                timestamp: Components.Schemas.Timestamp
            ) {
                self.text = text
                self.labels = labels
                self.sentences_idx_start = sentences_idx_start
                self.sentences_idx_end = sentences_idx_end
                self.timestamp = timestamp
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case labels
                case sentences_idx_start
                case sentences_idx_end
                case timestamp
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                labels = try container.decode(
                    [Components.Schemas.ContentSafetyLabel].self,
                    forKey: .labels
                )
                sentences_idx_start = try container.decode(
                    Swift.Int.self,
                    forKey: .sentences_idx_start
                )
                sentences_idx_end = try container.decode(
                    Swift.Int.self,
                    forKey: .sentences_idx_end
                )
                timestamp = try container.decode(
                    Components.Schemas.Timestamp.self,
                    forKey: .timestamp
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "labels",
                    "sentences_idx_start",
                    "sentences_idx_end",
                    "timestamp"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary`.
        public struct SeverityScoreSummary: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/low`.
            public var low: Swift.Double
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/medium`.
            public var medium: Swift.Double
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/high`.
            public var high: Swift.Double
            /// Creates a new `SeverityScoreSummary`.
            ///
            /// - Parameters:
            ///   - low:
            ///   - medium:
            ///   - high:
            public init(
                low: Swift.Double,
                medium: Swift.Double,
                high: Swift.Double
            ) {
                self.low = low
                self.medium = medium
                self.high = high
            }
            public enum CodingKeys: String, CodingKey {
                case low
                case medium
                case high
            }
        }
        /// An array of results for the Key Phrases model, if it is enabled.
        /// See [Key phrases](https://www.assemblyai.com/docs/models/key-phrases) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult`.
        public struct AutoHighlightsResult: Codable, Hashable, Sendable {
            /// The status of the Key Phrases model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus
            /// A temporally-sequential array of Key Phrases
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult/results`.
            public var results: [Components.Schemas.AutoHighlightResult]
            /// Creates a new `AutoHighlightsResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Key Phrases model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: A temporally-sequential array of Key Phrases
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus,
                results: [Components.Schemas.AutoHighlightResult]
            ) {
                self.status = status
                self.results = results
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
            }
        }
        /// - Remark: Generated from `#/components/schemas/AutoHighlightResult`.
        public struct AutoHighlightResult: Codable, Hashable, Sendable {
            /// The total number of times the key phrase appears in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/count`.
            public var count: Swift.Int
            /// The total relevancy to the overall audio file of this key phrase - a greater number means more relevant
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/rank`.
            public var rank: Swift.Float
            /// The text itself of the key phrase
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/text`.
            public var text: Swift.String
            /// The timestamp of the of the key phrase
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/timestamps`.
            public var timestamps: [Components.Schemas.Timestamp]
            /// Creates a new `AutoHighlightResult`.
            ///
            /// - Parameters:
            ///   - count: The total number of times the key phrase appears in the audio file
            ///   - rank: The total relevancy to the overall audio file of this key phrase - a greater number means more relevant
            ///   - text: The text itself of the key phrase
            ///   - timestamps: The timestamp of the of the key phrase
            public init(
                count: Swift.Int,
                rank: Swift.Float,
                text: Swift.String,
                timestamps: [Components.Schemas.Timestamp]
            ) {
                self.count = count
                self.rank = rank
                self.text = text
                self.timestamps = timestamps
            }
            public enum CodingKeys: String, CodingKey {
                case count
                case rank
                case text
                case timestamps
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                count = try container.decode(
                    Swift.Int.self,
                    forKey: .count
                )
                rank = try container.decode(
                    Swift.Float.self,
                    forKey: .rank
                )
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                timestamps = try container.decode(
                    [Components.Schemas.Timestamp].self,
                    forKey: .timestamps
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "count",
                    "rank",
                    "text",
                    "timestamps"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptWord`.
        public struct TranscriptWord: Codable, Hashable, Sendable {
            /// The confidence score for the transcript of this word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/confidence`.
            public var confidence: Swift.Double
            /// The starting time, in milliseconds, for the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/end`.
            public var end: Swift.Int
            /// The text of the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/text`.
            public var text: Swift.String
            /// The channel of the word. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/channel`.
            public var channel: Swift.String?
            /// The speaker of the word if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/speaker`.
            public var speaker: Swift.String?
            /// Creates a new `TranscriptWord`.
            ///
            /// - Parameters:
            ///   - confidence: The confidence score for the transcript of this word
            ///   - start: The starting time, in milliseconds, for the word
            ///   - end: The ending time, in milliseconds, for the word
            ///   - text: The text of the word
            ///   - channel: The channel of the word. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the word if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                confidence: Swift.Double,
                start: Swift.Int,
                end: Swift.Int,
                text: Swift.String,
                channel: Swift.String? = nil,
                speaker: Swift.String? = nil
            ) {
                self.confidence = confidence
                self.start = start
                self.end = end
                self.text = text
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case confidence
                case start
                case end
                case text
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                speaker = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "confidence",
                    "start",
                    "end",
                    "text",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptSentence`.
        public struct TranscriptSentence: Codable, Hashable, Sendable {
            /// The transcript of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, for the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/end`.
            public var end: Swift.Int
            /// The confidence score for the transcript of this sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/confidence`.
            public var confidence: Swift.Double
            /// An array of words in the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// The channel of the sentence. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/channel`.
            public var channel: Swift.String?
            /// The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/speaker`.
            public var speaker: Swift.String
            /// Creates a new `TranscriptSentence`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the sentence
            ///   - start: The starting time, in milliseconds, for the sentence
            ///   - end: The ending time, in milliseconds, for the sentence
            ///   - confidence: The confidence score for the transcript of this sentence
            ///   - words: An array of words in the sentence
            ///   - channel: The channel of the sentence. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                confidence: Swift.Double,
                words: [Components.Schemas.TranscriptWord],
                channel: Swift.String? = nil,
                speaker: Swift.String
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.confidence = confidence
                self.words = words
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case confidence
                case words
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                speaker = try container.decode(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "confidence",
                    "words",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/SentencesResponse`.
        public struct SentencesResponse: Codable, Hashable, Sendable {
            /// The unique identifier for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/id`.
            public var id: Swift.String
            /// The confidence score for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/confidence`.
            public var confidence: Swift.Double
            /// The duration of the audio file in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/audio_duration`.
            public var audio_duration: Swift.Double
            /// An array of sentences in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/sentences`.
            public var sentences: [Components.Schemas.TranscriptSentence]
            /// Creates a new `SentencesResponse`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier for the transcript
            ///   - confidence: The confidence score for the transcript
            ///   - audio_duration: The duration of the audio file in seconds
            ///   - sentences: An array of sentences in the transcript
            public init(
                id: Swift.String,
                confidence: Swift.Double,
                audio_duration: Swift.Double,
                sentences: [Components.Schemas.TranscriptSentence]
            ) {
                self.id = id
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.sentences = sentences
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case confidence
                case audio_duration
                case sentences
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                audio_duration = try container.decode(
                    Swift.Double.self,
                    forKey: .audio_duration
                )
                sentences = try container.decode(
                    [Components.Schemas.TranscriptSentence].self,
                    forKey: .sentences
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "confidence",
                    "audio_duration",
                    "sentences"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptParagraph`.
        public struct TranscriptParagraph: Codable, Hashable, Sendable {
            /// The transcript of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/end`.
            public var end: Swift.Int
            /// The confidence score for the transcript of this paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/confidence`.
            public var confidence: Swift.Double
            /// An array of words in the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// Creates a new `TranscriptParagraph`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the paragraph
            ///   - start: The starting time, in milliseconds, of the paragraph
            ///   - end: The ending time, in milliseconds, of the paragraph
            ///   - confidence: The confidence score for the transcript of this paragraph
            ///   - words: An array of words in the paragraph
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                confidence: Swift.Double,
                words: [Components.Schemas.TranscriptWord]
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.confidence = confidence
                self.words = words
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case confidence
                case words
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "confidence",
                    "words"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ParagraphsResponse`.
        public struct ParagraphsResponse: Codable, Hashable, Sendable {
            /// The unique identifier of your transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/id`.
            public var id: Swift.String
            /// The confidence score for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/confidence`.
            public var confidence: Swift.Double
            /// The duration of the audio file in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/audio_duration`.
            public var audio_duration: Swift.Double
            /// An array of paragraphs in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/paragraphs`.
            public var paragraphs: [Components.Schemas.TranscriptParagraph]
            /// Creates a new `ParagraphsResponse`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of your transcript
            ///   - confidence: The confidence score for the transcript
            ///   - audio_duration: The duration of the audio file in seconds
            ///   - paragraphs: An array of paragraphs in the transcript
            public init(
                id: Swift.String,
                confidence: Swift.Double,
                audio_duration: Swift.Double,
                paragraphs: [Components.Schemas.TranscriptParagraph]
            ) {
                self.id = id
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.paragraphs = paragraphs
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case confidence
                case audio_duration
                case paragraphs
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                audio_duration = try container.decode(
                    Swift.Double.self,
                    forKey: .audio_duration
                )
                paragraphs = try container.decode(
                    [Components.Schemas.TranscriptParagraph].self,
                    forKey: .paragraphs
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "confidence",
                    "audio_duration",
                    "paragraphs"
                ])
            }
        }
        /// Details of the transcript page. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
        ///
        /// - Remark: Generated from `#/components/schemas/PageDetails`.
        public struct PageDetails: Codable, Hashable, Sendable {
            /// The number of results this page is limited to
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/limit`.
            public var limit: Swift.Int
            /// The actual number of results in the page
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/result_count`.
            public var result_count: Swift.Int
            /// The URL used to retrieve the current page of transcripts
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/current_url`.
            public var current_url: Swift.String
            /// The URL to the next page of transcripts. The previous URL always points to a page with older transcripts.
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/prev_url`.
            public var prev_url: Swift.String
            /// The URL to the next page of transcripts. The next URL always points to a page with newer transcripts.
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/next_url`.
            public var next_url: Swift.String
            /// Creates a new `PageDetails`.
            ///
            /// - Parameters:
            ///   - limit: The number of results this page is limited to
            ///   - result_count: The actual number of results in the page
            ///   - current_url: The URL used to retrieve the current page of transcripts
            ///   - prev_url: The URL to the next page of transcripts. The previous URL always points to a page with older transcripts.
            ///   - next_url: The URL to the next page of transcripts. The next URL always points to a page with newer transcripts.
            public init(
                limit: Swift.Int,
                result_count: Swift.Int,
                current_url: Swift.String,
                prev_url: Swift.String,
                next_url: Swift.String
            ) {
                self.limit = limit
                self.result_count = result_count
                self.current_url = current_url
                self.prev_url = prev_url
                self.next_url = next_url
            }
            public enum CodingKeys: String, CodingKey {
                case limit
                case result_count
                case current_url
                case prev_url
                case next_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                limit = try container.decode(
                    Swift.Int.self,
                    forKey: .limit
                )
                result_count = try container.decode(
                    Swift.Int.self,
                    forKey: .result_count
                )
                current_url = try container.decode(
                    Swift.String.self,
                    forKey: .current_url
                )
                prev_url = try container.decode(
                    Swift.String.self,
                    forKey: .prev_url
                )
                next_url = try container.decode(
                    Swift.String.self,
                    forKey: .next_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "limit",
                    "result_count",
                    "current_url",
                    "prev_url",
                    "next_url"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ListTranscriptParams`.
        public struct ListTranscriptParams: Codable, Hashable, Sendable {
            /// Maximum amount of transcripts to retrieve
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/limit`.
            public var limit: Swift.Int?
            /// Filter by transcript status
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/status`.
            public var status: Components.Schemas.TranscriptStatus?
            /// Only get transcripts created on this date
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/created_on`.
            public var created_on: Swift.String?
            /// Get transcripts that were created before this transcript ID
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/before_id`.
            public var before_id: Swift.String?
            /// Get transcripts that were created after this transcript ID
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/after_id`.
            public var after_id: Swift.String?
            /// Only get throttled transcripts, overrides the status filter
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/throttled_only`.
            public var throttled_only: Swift.Bool?
            /// Creates a new `ListTranscriptParams`.
            ///
            /// - Parameters:
            ///   - limit: Maximum amount of transcripts to retrieve
            ///   - status: Filter by transcript status
            ///   - created_on: Only get transcripts created on this date
            ///   - before_id: Get transcripts that were created before this transcript ID
            ///   - after_id: Get transcripts that were created after this transcript ID
            ///   - throttled_only: Only get throttled transcripts, overrides the status filter
            public init(
                limit: Swift.Int? = nil,
                status: Components.Schemas.TranscriptStatus? = nil,
                created_on: Swift.String? = nil,
                before_id: Swift.String? = nil,
                after_id: Swift.String? = nil,
                throttled_only: Swift.Bool? = nil
            ) {
                self.limit = limit
                self.status = status
                self.created_on = created_on
                self.before_id = before_id
                self.after_id = after_id
                self.throttled_only = throttled_only
            }
            public enum CodingKeys: String, CodingKey {
                case limit
                case status
                case created_on
                case before_id
                case after_id
                case throttled_only
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                limit = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .limit
                )
                status = try container.decodeIfPresent(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                created_on = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .created_on
                )
                before_id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .before_id
                )
                after_id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .after_id
                )
                throttled_only = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .throttled_only
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "limit",
                    "status",
                    "created_on",
                    "before_id",
                    "after_id",
                    "throttled_only"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptListItem`.
        public struct TranscriptListItem: Codable, Hashable, Sendable {
            /// The unique identifier for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/id`.
            public var id: Swift.String
            /// The URL to retrieve the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/resource_url`.
            public var resource_url: Swift.String
            /// The status of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/status`.
            public var status: Components.Schemas.TranscriptStatus
            /// The date and time the transcript was created
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/created`.
            public var created: Swift.String
            /// The date and time the transcript was completed
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/completed`.
            public var completed: Swift.String
            /// The URL to the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/audio_url`.
            public var audio_url: Swift.String
            /// Error message of why the transcript failed
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/error`.
            public var error: Swift.String
            /// Creates a new `TranscriptListItem`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier for the transcript
            ///   - resource_url: The URL to retrieve the transcript
            ///   - status: The status of the transcript
            ///   - created: The date and time the transcript was created
            ///   - completed: The date and time the transcript was completed
            ///   - audio_url: The URL to the audio file
            ///   - error: Error message of why the transcript failed
            public init(
                id: Swift.String,
                resource_url: Swift.String,
                status: Components.Schemas.TranscriptStatus,
                created: Swift.String,
                completed: Swift.String,
                audio_url: Swift.String,
                error: Swift.String
            ) {
                self.id = id
                self.resource_url = resource_url
                self.status = status
                self.created = created
                self.completed = completed
                self.audio_url = audio_url
                self.error = error
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case resource_url
                case status
                case created
                case completed
                case audio_url
                case error
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                resource_url = try container.decode(
                    Swift.String.self,
                    forKey: .resource_url
                )
                status = try container.decode(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                created = try container.decode(
                    Swift.String.self,
                    forKey: .created
                )
                completed = try container.decode(
                    Swift.String.self,
                    forKey: .completed
                )
                audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .audio_url
                )
                error = try container.decode(
                    Swift.String.self,
                    forKey: .error
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "resource_url",
                    "status",
                    "created",
                    "completed",
                    "audio_url",
                    "error"
                ])
            }
        }
        /// A list of transcripts. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptList`.
        public struct TranscriptList: Codable, Hashable, Sendable {
            /// Details of the transcript page
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptList/page_details`.
            public var page_details: Components.Schemas.PageDetails
            /// An array of transcripts
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptList/transcripts`.
            public var transcripts: [Components.Schemas.TranscriptListItem]
            /// Creates a new `TranscriptList`.
            ///
            /// - Parameters:
            ///   - page_details: Details of the transcript page
            ///   - transcripts: An array of transcripts
            public init(
                page_details: Components.Schemas.PageDetails,
                transcripts: [Components.Schemas.TranscriptListItem]
            ) {
                self.page_details = page_details
                self.transcripts = transcripts
            }
            public enum CodingKeys: String, CodingKey {
                case page_details
                case transcripts
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                page_details = try container.decode(
                    Components.Schemas.PageDetails.self,
                    forKey: .page_details
                )
                transcripts = try container.decode(
                    [Components.Schemas.TranscriptListItem].self,
                    forKey: .transcripts
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "page_details",
                    "transcripts"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/UploadedFile`.
        public struct UploadedFile: Codable, Hashable, Sendable {
            /// A URL that points to your audio file, accessible only by AssemblyAI's servers
            ///
            /// - Remark: Generated from `#/components/schemas/UploadedFile/upload_url`.
            public var upload_url: Swift.String
            /// Creates a new `UploadedFile`.
            ///
            /// - Parameters:
            ///   - upload_url: A URL that points to your audio file, accessible only by AssemblyAI's servers
            public init(upload_url: Swift.String) {
                self.upload_url = upload_url
            }
            public enum CodingKeys: String, CodingKey {
                case upload_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                upload_url = try container.decode(
                    Swift.String.self,
                    forKey: .upload_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "upload_url"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/CreateRealtimeTemporaryTokenParams`.
        public struct CreateRealtimeTemporaryTokenParams: Codable, Hashable, Sendable {
            /// The amount of time until the token expires in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/CreateRealtimeTemporaryTokenParams/expires_in`.
            public var expires_in: Swift.Int
            /// Creates a new `CreateRealtimeTemporaryTokenParams`.
            ///
            /// - Parameters:
            ///   - expires_in: The amount of time until the token expires in seconds
            public init(expires_in: Swift.Int) {
                self.expires_in = expires_in
            }
            public enum CodingKeys: String, CodingKey {
                case expires_in
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                expires_in = try container.decode(
                    Swift.Int.self,
                    forKey: .expires_in
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "expires_in"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/RealtimeTemporaryTokenResponse`.
        public struct RealtimeTemporaryTokenResponse: Codable, Hashable, Sendable {
            /// The temporary authentication token for Streaming Speech-to-Text
            ///
            /// - Remark: Generated from `#/components/schemas/RealtimeTemporaryTokenResponse/token`.
            public var token: Swift.String
            /// Creates a new `RealtimeTemporaryTokenResponse`.
            ///
            /// - Parameters:
            ///   - token: The temporary authentication token for Streaming Speech-to-Text
            public init(token: Swift.String) {
                self.token = token
            }
            public enum CodingKeys: String, CodingKey {
                case token
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                token = try container.decode(
                    Swift.String.self,
                    forKey: .token
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "token"
                ])
            }
        }
        /// Either success, or unavailable in the rare case that the model failed
        ///
        /// - Remark: Generated from `#/components/schemas/AudioIntelligenceModelStatus`.
        @frozen public enum AudioIntelligenceModelStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case success = "success"
            case unavailable = "unavailable"
        }
        /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse`.
        public struct PurgeLemurRequestDataResponse: Codable, Hashable, Sendable {
            /// The ID of the deletion request of the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/request_id`.
            public var request_id: Swift.String
            /// The ID of the LeMUR request to purge the data for
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/request_id_to_purge`.
            public var request_id_to_purge: Swift.String
            /// Whether the request data was deleted
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/deleted`.
            public var deleted: Swift.Bool
            /// Creates a new `PurgeLemurRequestDataResponse`.
            ///
            /// - Parameters:
            ///   - request_id: The ID of the deletion request of the LeMUR request
            ///   - request_id_to_purge: The ID of the LeMUR request to purge the data for
            ///   - deleted: Whether the request data was deleted
            public init(
                request_id: Swift.String,
                request_id_to_purge: Swift.String,
                deleted: Swift.Bool
            ) {
                self.request_id = request_id
                self.request_id_to_purge = request_id_to_purge
                self.deleted = deleted
            }
            public enum CodingKeys: String, CodingKey {
                case request_id
                case request_id_to_purge
                case deleted
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                request_id = try container.decode(
                    Swift.String.self,
                    forKey: .request_id
                )
                request_id_to_purge = try container.decode(
                    Swift.String.self,
                    forKey: .request_id_to_purge
                )
                deleted = try container.decode(
                    Swift.Bool.self,
                    forKey: .deleted
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "request_id",
                    "request_id_to_purge",
                    "deleted"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurBaseResponse`.
        public struct LemurBaseResponse: Codable, Hashable, Sendable {
            /// The ID of the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseResponse/request_id`.
            public var request_id: Swift.String
            /// The usage numbers for the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseResponse/usage`.
            public var usage: Components.Schemas.LemurUsage
            /// Creates a new `LemurBaseResponse`.
            ///
            /// - Parameters:
            ///   - request_id: The ID of the LeMUR request
            ///   - usage: The usage numbers for the LeMUR request
            public init(
                request_id: Swift.String,
                usage: Components.Schemas.LemurUsage
            ) {
                self.request_id = request_id
                self.usage = usage
            }
            public enum CodingKeys: String, CodingKey {
                case request_id
                case usage
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                request_id = try container.decode(
                    Swift.String.self,
                    forKey: .request_id
                )
                usage = try container.decode(
                    Components.Schemas.LemurUsage.self,
                    forKey: .usage
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "request_id",
                    "usage"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurStringResponse`.
        public struct LemurStringResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// The response generated by LeMUR.
                ///
                /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1/response`.
                public var response: Swift.String
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - response: The response generated by LeMUR.
                public init(response: Swift.String) {
                    self.response = response
                }
                public enum CodingKeys: String, CodingKey {
                    case response
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    response = try container.decode(
                        Swift.String.self,
                        forKey: .response
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "response"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse.Value1Payload
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value2`.
            public var value2: Components.Schemas.LemurBaseResponse
            /// Creates a new `LemurStringResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurStringResponse.Value1Payload,
                value2: Components.Schemas.LemurBaseResponse
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurTaskResponse`.
        public struct LemurTaskResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurTaskResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurTaskResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurSummaryResponse`.
        public struct LemurSummaryResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurSummaryResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurSummaryResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurActionItemsResponse`.
        public struct LemurActionItemsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurActionItemsResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse`.
        public struct LemurQuestionAnswerResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value1`.
            public var value1: Components.Schemas.LemurBaseResponse
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// The answers generated by LeMUR and their questions
                ///
                /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2/response`.
                public var response: [Components.Schemas.LemurQuestionAnswer]
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - response: The answers generated by LeMUR and their questions
                public init(response: [Components.Schemas.LemurQuestionAnswer]) {
                    self.response = response
                }
                public enum CodingKeys: String, CodingKey {
                    case response
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    response = try container.decode(
                        [Components.Schemas.LemurQuestionAnswer].self,
                        forKey: .response
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "response"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2`.
            public var value2: Components.Schemas.LemurQuestionAnswerResponse.Value2Payload
            /// Creates a new `LemurQuestionAnswerResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseResponse,
                value2: Components.Schemas.LemurQuestionAnswerResponse.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// An answer generated by LeMUR and its question
        ///
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer`.
        public struct LemurQuestionAnswer: Codable, Hashable, Sendable {
            /// The question for LeMUR to answer
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer/question`.
            public var question: Swift.String
            /// The answer generated by LeMUR
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer/answer`.
            public var answer: Swift.String
            /// Creates a new `LemurQuestionAnswer`.
            ///
            /// - Parameters:
            ///   - question: The question for LeMUR to answer
            ///   - answer: The answer generated by LeMUR
            public init(
                question: Swift.String,
                answer: Swift.String
            ) {
                self.question = question
                self.answer = answer
            }
            public enum CodingKeys: String, CodingKey {
                case question
                case answer
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                question = try container.decode(
                    Swift.String.self,
                    forKey: .question
                )
                answer = try container.decode(
                    Swift.String.self,
                    forKey: .answer
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "question",
                    "answer"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurResponse`.
        @frozen public enum LemurResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurResponse/case1`.
            case LemurStringResponse(Components.Schemas.LemurStringResponse)
            /// - Remark: Generated from `#/components/schemas/LemurResponse/case2`.
            case LemurQuestionAnswerResponse(Components.Schemas.LemurQuestionAnswerResponse)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .LemurStringResponse(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .LemurQuestionAnswerResponse(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .LemurStringResponse(value):
                    try value.encode(to: encoder)
                case let .LemurQuestionAnswerResponse(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurBaseParams`.
        public struct LemurBaseParams: Codable, Hashable, Sendable {
            /// A list of completed transcripts with text. Up to a maximum of 100 files or 100 hours, whichever is lower.
            /// Use either transcript_ids or input_text as input into LeMUR.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/transcript_ids`.
            public var transcript_ids: [Swift.String]?
            /// Custom formatted transcript data. Maximum size is the context limit of the selected model, which defaults to 100000.
            /// Use either transcript_ids or input_text as input into LeMUR.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/input_text`.
            public var input_text: Swift.String?
            /// Context to provide the model. This can be a string or a free-form JSON value.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context`.
            @frozen public enum contextPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case1`.
                case case1(Swift.String)
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case2`.
                public struct Case2Payload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `Case2Payload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case2`.
                case case2(Components.Schemas.LemurBaseParams.contextPayload.Case2Payload)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// Context to provide the model. This can be a string or a free-form JSON value.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context`.
            public var context: Components.Schemas.LemurBaseParams.contextPayload?
            /// The model that is used for the final prompt after compression is performed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model`.
            public struct final_modelPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model/value1`.
                public var value1: Components.Schemas.LemurModel?
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model/value2`.
                public var value2: Swift.String?
                /// Creates a new `final_modelPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.LemurModel? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            value1,
                            value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        value1,
                        value2
                    ])
                }
            }
            /// The model that is used for the final prompt after compression is performed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model`.
            public var final_model: Components.Schemas.LemurBaseParams.final_modelPayload?
            /// Max output size in tokens, up to 4000
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/max_output_size`.
            public var max_output_size: Swift.Int?
            /// The temperature to use for the model.
            /// Higher values result in answers that are more creative, lower values are more conservative.
            /// Can be any value between 0.0 and 1.0 inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/temperature`.
            public var temperature: Swift.Float?
            /// Creates a new `LemurBaseParams`.
            ///
            /// - Parameters:
            ///   - transcript_ids: A list of completed transcripts with text. Up to a maximum of 100 files or 100 hours, whichever is lower.
            ///   - input_text: Custom formatted transcript data. Maximum size is the context limit of the selected model, which defaults to 100000.
            ///   - context: Context to provide the model. This can be a string or a free-form JSON value.
            ///   - final_model: The model that is used for the final prompt after compression is performed.
            ///   - max_output_size: Max output size in tokens, up to 4000
            ///   - temperature: The temperature to use for the model.
            public init(
                transcript_ids: [Swift.String]? = nil,
                input_text: Swift.String? = nil,
                context: Components.Schemas.LemurBaseParams.contextPayload? = nil,
                final_model: Components.Schemas.LemurBaseParams.final_modelPayload? = nil,
                max_output_size: Swift.Int? = nil,
                temperature: Swift.Float? = nil
            ) {
                self.transcript_ids = transcript_ids
                self.input_text = input_text
                self.context = context
                self.final_model = final_model
                self.max_output_size = max_output_size
                self.temperature = temperature
            }
            public enum CodingKeys: String, CodingKey {
                case transcript_ids
                case input_text
                case context
                case final_model
                case max_output_size
                case temperature
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                transcript_ids = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .transcript_ids
                )
                input_text = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .input_text
                )
                context = try container.decodeIfPresent(
                    Components.Schemas.LemurBaseParams.contextPayload.self,
                    forKey: .context
                )
                final_model = try container.decodeIfPresent(
                    Components.Schemas.LemurBaseParams.final_modelPayload.self,
                    forKey: .final_model
                )
                max_output_size = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .max_output_size
                )
                temperature = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .temperature
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "transcript_ids",
                    "input_text",
                    "context",
                    "final_model",
                    "max_output_size",
                    "temperature"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurTaskParams`.
        public struct LemurTaskParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// Your text to prompt the model to produce a desired output, including any context you want to pass into the model.
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/prompt`.
                public var prompt: Swift.String
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - prompt: Your text to prompt the model to produce a desired output, including any context you want to pass into the model.
                public init(prompt: Swift.String) {
                    self.prompt = prompt
                }
                public enum CodingKeys: String, CodingKey {
                    case prompt
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    prompt = try container.decode(
                        Swift.String.self,
                        forKey: .prompt
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "prompt"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1`.
            public var value1: Components.Schemas.LemurTaskParams.Value1Payload
            /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value2`.
            public var value2: Components.Schemas.LemurBaseParams
            /// Creates a new `LemurTaskParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurTaskParams.Value1Payload,
                value2: Components.Schemas.LemurBaseParams
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurSummaryParams`.
        public struct LemurSummaryParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// How you want the summary to be returned. This can be any text. Examples: "TLDR", "bullet points"
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2/answer_format`.
                public var answer_format: Swift.String?
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - answer_format: How you want the summary to be returned. This can be any text. Examples: "TLDR", "bullet points"
                public init(answer_format: Swift.String? = nil) {
                    self.answer_format = answer_format
                }
                public enum CodingKeys: String, CodingKey {
                    case answer_format
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    answer_format = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .answer_format
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "answer_format"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2`.
            public var value2: Components.Schemas.LemurSummaryParams.Value2Payload
            /// Creates a new `LemurSummaryParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurSummaryParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams`.
        public struct LemurQuestionAnswerParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// A list of questions to ask
                ///
                /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2/questions`.
                public var questions: [Components.Schemas.LemurQuestion]
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - questions: A list of questions to ask
                public init(questions: [Components.Schemas.LemurQuestion]) {
                    self.questions = questions
                }
                public enum CodingKeys: String, CodingKey {
                    case questions
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    questions = try container.decode(
                        [Components.Schemas.LemurQuestion].self,
                        forKey: .questions
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "questions"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2`.
            public var value2: Components.Schemas.LemurQuestionAnswerParams.Value2Payload
            /// Creates a new `LemurQuestionAnswerParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurQuestionAnswerParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestion`.
        public struct LemurQuestion: Codable, Hashable, Sendable {
            /// The question you wish to ask. For more complex questions use default model.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/question`.
            public var question: Swift.String
            /// Any context about the transcripts you wish to provide. This can be a string or any object.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/context`.
            @frozen public enum contextPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case1`.
                case case1(Swift.String)
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case2`.
                public struct Case2Payload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `Case2Payload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case2`.
                case case2(Components.Schemas.LemurQuestion.contextPayload.Case2Payload)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// Any context about the transcripts you wish to provide. This can be a string or any object.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/context`.
            public var context: Components.Schemas.LemurQuestion.contextPayload?
            /// How you want the answer to be returned. This can be any text. Can't be used with answer_options. Examples: "short sentence", "bullet points"
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/answer_format`.
            public var answer_format: Swift.String?
            /// What discrete options to return. Useful for precise responses. Can't be used with answer_format. Example: ["Yes", "No"]
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/answer_options`.
            public var answer_options: [Swift.String]?
            /// Creates a new `LemurQuestion`.
            ///
            /// - Parameters:
            ///   - question: The question you wish to ask. For more complex questions use default model.
            ///   - context: Any context about the transcripts you wish to provide. This can be a string or any object.
            ///   - answer_format: How you want the answer to be returned. This can be any text. Can't be used with answer_options. Examples: "short sentence", "bullet points"
            ///   - answer_options: What discrete options to return. Useful for precise responses. Can't be used with answer_format. Example: ["Yes", "No"]
            public init(
                question: Swift.String,
                context: Components.Schemas.LemurQuestion.contextPayload? = nil,
                answer_format: Swift.String? = nil,
                answer_options: [Swift.String]? = nil
            ) {
                self.question = question
                self.context = context
                self.answer_format = answer_format
                self.answer_options = answer_options
            }
            public enum CodingKeys: String, CodingKey {
                case question
                case context
                case answer_format
                case answer_options
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                question = try container.decode(
                    Swift.String.self,
                    forKey: .question
                )
                context = try container.decodeIfPresent(
                    Components.Schemas.LemurQuestion.contextPayload.self,
                    forKey: .context
                )
                answer_format = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .answer_format
                )
                answer_options = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .answer_options
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "question",
                    "context",
                    "answer_format",
                    "answer_options"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams`.
        public struct LemurActionItemsParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// How you want the action items to be returned. This can be any text.
                /// Defaults to "Bullet Points".
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2/answer_format`.
                public var answer_format: Swift.String?
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - answer_format: How you want the action items to be returned. This can be any text.
                public init(answer_format: Swift.String? = nil) {
                    self.answer_format = answer_format
                }
                public enum CodingKeys: String, CodingKey {
                    case answer_format
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    answer_format = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .answer_format
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "answer_format"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2`.
            public var value2: Components.Schemas.LemurActionItemsParams.Value2Payload
            /// Creates a new `LemurActionItemsParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurActionItemsParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                value1 = try .init(from: decoder)
                value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try value1.encode(to: encoder)
                try value2.encode(to: encoder)
            }
        }
        /// The model that is used for the final prompt after compression is performed.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/LemurModel`.
        @frozen public enum LemurModel: String, Codable, Hashable, Sendable, CaseIterable {
            case anthropic_sol_claude_hyphen_3_hyphen_5_hyphen_sonnet = "anthropic/claude-3-5-sonnet"
            case anthropic_sol_claude_hyphen_3_hyphen_opus = "anthropic/claude-3-opus"
            case anthropic_sol_claude_hyphen_3_hyphen_haiku = "anthropic/claude-3-haiku"
            case anthropic_sol_claude_hyphen_3_hyphen_sonnet = "anthropic/claude-3-sonnet"
            case anthropic_sol_claude_hyphen_2_hyphen_1 = "anthropic/claude-2-1"
            case anthropic_sol_claude_hyphen_2 = "anthropic/claude-2"
            case _default = "default"
            case anthropic_sol_claude_hyphen_instant_hyphen_1_hyphen_2 = "anthropic/claude-instant-1-2"
            case basic = "basic"
            case assemblyai_sol_mistral_hyphen_7b = "assemblyai/mistral-7b"
        }
        /// The usage numbers for the LeMUR request
        ///
        /// - Remark: Generated from `#/components/schemas/LemurUsage`.
        public struct LemurUsage: Codable, Hashable, Sendable {
            /// The number of input tokens used by the model
            ///
            /// - Remark: Generated from `#/components/schemas/LemurUsage/input_tokens`.
            public var input_tokens: Swift.Int
            /// The number of output tokens generated by the model
            ///
            /// - Remark: Generated from `#/components/schemas/LemurUsage/output_tokens`.
            public var output_tokens: Swift.Int
            /// Creates a new `LemurUsage`.
            ///
            /// - Parameters:
            ///   - input_tokens: The number of input tokens used by the model
            ///   - output_tokens: The number of output tokens generated by the model
            public init(
                input_tokens: Swift.Int,
                output_tokens: Swift.Int
            ) {
                self.input_tokens = input_tokens
                self.output_tokens = output_tokens
            }
            public enum CodingKeys: String, CodingKey {
                case input_tokens
                case output_tokens
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                input_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .input_tokens
                )
                output_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .output_tokens
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "input_tokens",
                    "output_tokens"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/Error`.
        public struct _Error: Codable, Hashable, Sendable {
            /// Error message
            ///
            /// - Remark: Generated from `#/components/schemas/Error/error`.
            public var error: Swift.String
            /// - Remark: Generated from `#/components/schemas/Error/status`.
            @frozen public enum statusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case error = "error"
            }
            /// - Remark: Generated from `#/components/schemas/Error/status`.
            public var status: Components.Schemas._Error.statusPayload?
            /// A container of undocumented properties.
            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
            /// Creates a new `_Error`.
            ///
            /// - Parameters:
            ///   - error: Error message
            ///   - status:
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                error: Swift.String,
                status: Components.Schemas._Error.statusPayload? = nil,
                additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()
            ) {
                self.error = error
                self.status = status
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case error
                case status
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                error = try container.decode(
                    Swift.String.self,
                    forKey: .error
                )
                status = try container.decodeIfPresent(
                    Components.Schemas._Error.statusPayload.self,
                    forKey: .status
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "error",
                    "status"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(
                    error,
                    forKey: .error
                )
                try container.encodeIfPresent(
                    status,
                    forKey: .status
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {
        public struct BadRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/BadRequest/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/BadRequest/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.BadRequest.Body
            /// Creates a new `BadRequest`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.BadRequest.Body) {
                self.body = body
            }
        }
        public struct Unauthorized: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/Unauthorized/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/Unauthorized/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Unauthorized.Body
            /// Creates a new `Unauthorized`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Unauthorized.Body) {
                self.body = body
            }
        }
        public struct NotFound: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/NotFound/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/NotFound/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.NotFound.Body
            /// Creates a new `NotFound`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.NotFound.Body) {
                self.body = body
            }
        }
        public struct TooManyRequests: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/TooManyRequests/headers`.
            public struct Headers: Sendable, Hashable {
                /// The number of seconds to wait before retrying the request
                ///
                /// - Remark: Generated from `#/components/responses/TooManyRequests/headers/Retry-After`.
                public var Retry_hyphen_After: Swift.Int?
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - Retry_hyphen_After: The number of seconds to wait before retrying the request
                public init(Retry_hyphen_After: Swift.Int? = nil) {
                    self.Retry_hyphen_After = Retry_hyphen_After
                }
            }
            /// Received HTTP response headers
            public var headers: Components.Responses.TooManyRequests.Headers
            /// - Remark: Generated from `#/components/responses/TooManyRequests/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/TooManyRequests/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.TooManyRequests.Body
            /// Creates a new `TooManyRequests`.
            ///
            /// - Parameters:
            ///   - headers: Received HTTP response headers
            ///   - body: Received HTTP response body
            public init(
                headers: Components.Responses.TooManyRequests.Headers = .init(),
                body: Components.Responses.TooManyRequests.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        public struct InternalServerError: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/InternalServerError/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/InternalServerError/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.InternalServerError.Body
            /// Creates a new `InternalServerError`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.InternalServerError.Body) {
                self.body = body
            }
        }
        public struct ServiceUnavailable: Sendable, Hashable {
            /// Creates a new `ServiceUnavailable`.
            public init() {}
        }
        public struct GatewayTimeout: Sendable, Hashable {
            /// Creates a new `GatewayTimeout`.
            public init() {}
        }
    }
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    public enum uploadFile {
        public static let id: Swift.String = "uploadFile"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/upload/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.uploadFile.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.uploadFile.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.uploadFile.Input.Headers
            /// - Remark: Generated from `#/paths/v2/upload/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/upload/POST/requestBody/content/application\/octet-stream`.
                case binary(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.uploadFile.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.uploadFile.Input.Headers = .init(),
                body: Operations.uploadFile.Input.Body? = nil
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/upload/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/upload/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.UploadedFile)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UploadedFile {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.uploadFile.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.uploadFile.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Media file uploaded successfully
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.uploadFile.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.uploadFile.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List transcripts
    ///
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    public enum listTranscripts {
        public static let id: Swift.String = "listTranscripts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Maximum amount of transcripts to retrieve
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/limit`.
                public var limit: OpenAPIRuntime.OpenAPIValueContainer?
                /// Filter by transcript status
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/status`.
                public var status: Components.Schemas.TranscriptStatus?
                /// Only get transcripts created on this date
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/created_on`.
                public var created_on: OpenAPIRuntime.OpenAPIValueContainer?
                /// Get transcripts that were created before this transcript ID
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/before_id`.
                public var before_id: OpenAPIRuntime.OpenAPIValueContainer?
                /// Get transcripts that were created after this transcript ID
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/after_id`.
                public var after_id: OpenAPIRuntime.OpenAPIValueContainer?
                /// Only get throttled transcripts, overrides the status filter
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/throttled_only`.
                public var throttled_only: OpenAPIRuntime.OpenAPIValueContainer?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - limit: Maximum amount of transcripts to retrieve
                ///   - status: Filter by transcript status
                ///   - created_on: Only get transcripts created on this date
                ///   - before_id: Get transcripts that were created before this transcript ID
                ///   - after_id: Get transcripts that were created after this transcript ID
                ///   - throttled_only: Only get throttled transcripts, overrides the status filter
                public init(
                    limit: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    status: Components.Schemas.TranscriptStatus? = nil,
                    created_on: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    before_id: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    after_id: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    throttled_only: OpenAPIRuntime.OpenAPIValueContainer? = nil
                ) {
                    self.limit = limit
                    self.status = status
                    self.created_on = created_on
                    self.before_id = before_id
                    self.after_id = after_id
                    self.throttled_only = throttled_only
                }
            }
            public var query: Operations.listTranscripts.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listTranscripts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listTranscripts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.listTranscripts.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.listTranscripts.Input.Query = .init(),
                headers: Operations.listTranscripts.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TranscriptList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TranscriptList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.listTranscripts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.listTranscripts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// A list of transcripts. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
            ///
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.listTranscripts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.listTranscripts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Transcribe audio
    ///
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    public enum createTranscript {
        public static let id: Swift.String = "createTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createTranscript.Input.Headers
            /// - Remark: Generated from `#/paths/v2/transcript/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.TranscriptParams)
            }
            public var body: Operations.createTranscript.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createTranscript.Input.Headers = .init(),
                body: Operations.createTranscript.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Transcript created and queued for processing
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.createTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.createTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get transcript
    ///
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    public enum getTranscript {
        public static let id: Swift.String = "getTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscript.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscript.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscript.Input.Path,
                headers: Operations.getTranscript.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The transcript resource
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete transcript
    ///
    /// Remove the data from the transcript and mark it as deleted.
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    public enum deleteTranscript {
        public static let id: Swift.String = "deleteTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.deleteTranscript.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.deleteTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.deleteTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.deleteTranscript.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.deleteTranscript.Input.Path,
                headers: Operations.deleteTranscript.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.deleteTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.deleteTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The deleted transcript response
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.deleteTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.deleteTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get subtitles for transcript
    ///
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    public enum getSubtitles {
        public static let id: Swift.String = "getSubtitles"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// The format of the captions
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path/subtitle_format`.
                public var subtitle_format: Components.Schemas.SubtitleFormat
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                ///   - subtitle_format: The format of the captions
                public init(
                    transcript_id: Swift.String,
                    subtitle_format: Components.Schemas.SubtitleFormat
                ) {
                    self.transcript_id = transcript_id
                    self.subtitle_format = subtitle_format
                }
            }
            public var path: Operations.getSubtitles.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The maximum number of characters per caption
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/query/chars_per_caption`.
                public var chars_per_caption: Swift.Int?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - chars_per_caption: The maximum number of characters per caption
                public init(chars_per_caption: Swift.Int? = nil) {
                    self.chars_per_caption = chars_per_caption
                }
            }
            public var query: Operations.getSubtitles.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSubtitles.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSubtitles.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSubtitles.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getSubtitles.Input.Path,
                query: Operations.getSubtitles.Input.Query = .init(),
                headers: Operations.getSubtitles.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/responses/200/content/text\/plain`.
                    case plainText(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.plainText`.
                    ///
                    /// - Throws: An error if `self` is not `.plainText`.
                    /// - SeeAlso: `.plainText`.
                    public var plainText: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .plainText(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSubtitles.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSubtitles.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The exported captions as text
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSubtitles.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSubtitles.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case plainText
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "text/plain":
                    self = .plainText
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .plainText:
                    return "text/plain"
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .plainText,
                    .json
                ]
            }
        }
    }
    /// Get sentences in transcript
    ///
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    public enum getTranscriptSentences {
        public static let id: Swift.String = "getTranscriptSentences"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscriptSentences.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptSentences.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptSentences.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscriptSentences.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscriptSentences.Input.Path,
                headers: Operations.getTranscriptSentences.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.SentencesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.SentencesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscriptSentences.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscriptSentences.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Exported sentences
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscriptSentences.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscriptSentences.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get paragraphs in transcript
    ///
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    public enum getTranscriptParagraphs {
        public static let id: Swift.String = "getTranscriptParagraphs"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscriptParagraphs.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptParagraphs.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptParagraphs.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscriptParagraphs.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscriptParagraphs.Input.Path,
                headers: Operations.getTranscriptParagraphs.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ParagraphsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ParagraphsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscriptParagraphs.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscriptParagraphs.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Exported paragraphs
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscriptParagraphs.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscriptParagraphs.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Search words in transcript
    ///
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    public enum wordSearch {
        public static let id: Swift.String = "wordSearch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.wordSearch.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Keywords to search for
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/query/words`.
                public var words: [Swift.String]
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - words: Keywords to search for
                public init(words: [Swift.String]) {
                    self.words = words
                }
            }
            public var query: Operations.wordSearch.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.wordSearch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.wordSearch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.wordSearch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.wordSearch.Input.Path,
                query: Operations.wordSearch.Input.Query,
                headers: Operations.wordSearch.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.WordSearchResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.WordSearchResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.wordSearch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.wordSearch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Word search response
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.wordSearch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.wordSearch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get redacted audio
    ///
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    public enum getRedactedAudio {
        public static let id: Swift.String = "getRedactedAudio"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getRedactedAudio.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getRedactedAudio.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getRedactedAudio.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getRedactedAudio.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getRedactedAudio.Input.Path,
                headers: Operations.getRedactedAudio.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RedactedAudioResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RedactedAudioResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getRedactedAudio.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getRedactedAudio.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The redacted audio object containing the status and URL to the redacted audio
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getRedactedAudio.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getRedactedAudio.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create temporary authentication token for Streaming STT
    ///
    /// Create a temporary authentication token for Streaming Speech-to-Text
    ///
    /// - Remark: HTTP `POST /v2/realtime/token`.
    /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)`.
    public enum createTemporaryToken {
        public static let id: Swift.String = "createTemporaryToken"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/realtime/token/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTemporaryToken.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTemporaryToken.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createTemporaryToken.Input.Headers
            /// - Remark: Generated from `#/paths/v2/realtime/token/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/realtime/token/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.CreateRealtimeTemporaryTokenParams)
            }
            public var body: Operations.createTemporaryToken.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createTemporaryToken.Input.Headers = .init(),
                body: Operations.createTemporaryToken.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/realtime/token/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/realtime/token/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.RealtimeTemporaryTokenResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RealtimeTemporaryTokenResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createTemporaryToken.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createTemporaryToken.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Temporary authentication token generated
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.createTemporaryToken.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.createTemporaryToken.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/realtime/token/post(createTemporaryToken)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Run a task using LeMUR
    ///
    /// Use the LeMUR task endpoint to input your own LLM prompt.
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/task`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)`.
    public enum lemurTask {
        public static let id: Swift.String = "lemurTask"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurTask.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurTask.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.lemurTask.Input.Headers
            /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.LemurTaskParams)
            }
            public var body: Operations.lemurTask.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.lemurTask.Input.Headers = .init(),
                body: Operations.lemurTask.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// Maximum number of allowed requests in a 60 second window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/headers/X-RateLimit-Limit`.
                    public var X_hyphen_RateLimit_hyphen_Limit: Swift.Int?
                    /// Number of remaining requests in the current time window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/headers/X-RateLimit-Remaining`.
                    public var X_hyphen_RateLimit_hyphen_Remaining: Swift.Int?
                    /// Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/headers/X-RateLimit-Reset`.
                    public var X_hyphen_RateLimit_hyphen_Reset: Swift.Int?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - X_hyphen_RateLimit_hyphen_Limit: Maximum number of allowed requests in a 60 second window.
                    ///   - X_hyphen_RateLimit_hyphen_Remaining: Number of remaining requests in the current time window.
                    ///   - X_hyphen_RateLimit_hyphen_Reset: Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    public init(
                        X_hyphen_RateLimit_hyphen_Limit: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Remaining: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Reset: Swift.Int? = nil
                    ) {
                        self.X_hyphen_RateLimit_hyphen_Limit = X_hyphen_RateLimit_hyphen_Limit
                        self.X_hyphen_RateLimit_hyphen_Remaining = X_hyphen_RateLimit_hyphen_Remaining
                        self.X_hyphen_RateLimit_hyphen_Reset = X_hyphen_RateLimit_hyphen_Reset
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.lemurTask.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/task/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.LemurTaskResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LemurTaskResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.lemurTask.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.lemurTask.Output.Ok.Headers = .init(),
                    body: Operations.lemurTask.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// LeMUR task response
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.lemurTask.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.lemurTask.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/task/post(lemurTask)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Summarize a transcript using LeMUR
    ///
    /// Custom Summary allows you to distill a piece of audio into a few impactful sentences.
    /// You can give the model context to obtain more targeted results while outputting the results in a variety of formats described in human language.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/summary`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)`.
    public enum lemurSummary {
        public static let id: Swift.String = "lemurSummary"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurSummary.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurSummary.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.lemurSummary.Input.Headers
            /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.LemurSummaryParams)
            }
            public var body: Operations.lemurSummary.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.lemurSummary.Input.Headers = .init(),
                body: Operations.lemurSummary.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// Maximum number of allowed requests in a 60 second window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/headers/X-RateLimit-Limit`.
                    public var X_hyphen_RateLimit_hyphen_Limit: Swift.Int?
                    /// Number of remaining requests in the current time window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/headers/X-RateLimit-Remaining`.
                    public var X_hyphen_RateLimit_hyphen_Remaining: Swift.Int?
                    /// Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/headers/X-RateLimit-Reset`.
                    public var X_hyphen_RateLimit_hyphen_Reset: Swift.Int?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - X_hyphen_RateLimit_hyphen_Limit: Maximum number of allowed requests in a 60 second window.
                    ///   - X_hyphen_RateLimit_hyphen_Remaining: Number of remaining requests in the current time window.
                    ///   - X_hyphen_RateLimit_hyphen_Reset: Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    public init(
                        X_hyphen_RateLimit_hyphen_Limit: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Remaining: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Reset: Swift.Int? = nil
                    ) {
                        self.X_hyphen_RateLimit_hyphen_Limit = X_hyphen_RateLimit_hyphen_Limit
                        self.X_hyphen_RateLimit_hyphen_Remaining = X_hyphen_RateLimit_hyphen_Remaining
                        self.X_hyphen_RateLimit_hyphen_Reset = X_hyphen_RateLimit_hyphen_Reset
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.lemurSummary.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/summary/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.LemurSummaryResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LemurSummaryResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.lemurSummary.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.lemurSummary.Output.Ok.Headers = .init(),
                    body: Operations.lemurSummary.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// LeMUR summary response
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.lemurSummary.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.lemurSummary.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/summary/post(lemurSummary)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Ask questions using LeMUR
    ///
    /// Question & Answer allows you to ask free-form questions about a single transcript or a group of transcripts.
    /// The questions can be any whose answers you find useful, such as judging whether a caller is likely to become a customer or whether all items on a meeting's agenda were covered.
    ///
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/question-answer`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)`.
    public enum lemurQuestionAnswer {
        public static let id: Swift.String = "lemurQuestionAnswer"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurQuestionAnswer.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurQuestionAnswer.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.lemurQuestionAnswer.Input.Headers
            /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.LemurQuestionAnswerParams)
            }
            public var body: Operations.lemurQuestionAnswer.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.lemurQuestionAnswer.Input.Headers = .init(),
                body: Operations.lemurQuestionAnswer.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// Maximum number of allowed requests in a 60 second window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/headers/X-RateLimit-Limit`.
                    public var X_hyphen_RateLimit_hyphen_Limit: Swift.Int?
                    /// Number of remaining requests in the current time window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/headers/X-RateLimit-Remaining`.
                    public var X_hyphen_RateLimit_hyphen_Remaining: Swift.Int?
                    /// Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/headers/X-RateLimit-Reset`.
                    public var X_hyphen_RateLimit_hyphen_Reset: Swift.Int?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - X_hyphen_RateLimit_hyphen_Limit: Maximum number of allowed requests in a 60 second window.
                    ///   - X_hyphen_RateLimit_hyphen_Remaining: Number of remaining requests in the current time window.
                    ///   - X_hyphen_RateLimit_hyphen_Reset: Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    public init(
                        X_hyphen_RateLimit_hyphen_Limit: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Remaining: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Reset: Swift.Int? = nil
                    ) {
                        self.X_hyphen_RateLimit_hyphen_Limit = X_hyphen_RateLimit_hyphen_Limit
                        self.X_hyphen_RateLimit_hyphen_Remaining = X_hyphen_RateLimit_hyphen_Remaining
                        self.X_hyphen_RateLimit_hyphen_Reset = X_hyphen_RateLimit_hyphen_Reset
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.lemurQuestionAnswer.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/question-answer/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.LemurQuestionAnswerResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LemurQuestionAnswerResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.lemurQuestionAnswer.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.lemurQuestionAnswer.Output.Ok.Headers = .init(),
                    body: Operations.lemurQuestionAnswer.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// LeMUR question & answer response
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.lemurQuestionAnswer.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.lemurQuestionAnswer.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/question-answer/post(lemurQuestionAnswer)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Extract action items
    ///
    /// Use LeMUR to generate a list of action items from a transcript
    ///
    /// - Remark: HTTP `POST /lemur/v3/generate/action-items`.
    /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)`.
    public enum lemurActionItems {
        public static let id: Swift.String = "lemurActionItems"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurActionItems.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.lemurActionItems.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.lemurActionItems.Input.Headers
            /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.LemurActionItemsParams)
            }
            public var body: Operations.lemurActionItems.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.lemurActionItems.Input.Headers = .init(),
                body: Operations.lemurActionItems.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// Maximum number of allowed requests in a 60 second window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/headers/X-RateLimit-Limit`.
                    public var X_hyphen_RateLimit_hyphen_Limit: Swift.Int?
                    /// Number of remaining requests in the current time window.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/headers/X-RateLimit-Remaining`.
                    public var X_hyphen_RateLimit_hyphen_Remaining: Swift.Int?
                    /// Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    ///
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/headers/X-RateLimit-Reset`.
                    public var X_hyphen_RateLimit_hyphen_Reset: Swift.Int?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - X_hyphen_RateLimit_hyphen_Limit: Maximum number of allowed requests in a 60 second window.
                    ///   - X_hyphen_RateLimit_hyphen_Remaining: Number of remaining requests in the current time window.
                    ///   - X_hyphen_RateLimit_hyphen_Reset: Number of seconds until the remaining requests resets to the value of X-RateLimit-Limit.
                    public init(
                        X_hyphen_RateLimit_hyphen_Limit: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Remaining: Swift.Int? = nil,
                        X_hyphen_RateLimit_hyphen_Reset: Swift.Int? = nil
                    ) {
                        self.X_hyphen_RateLimit_hyphen_Limit = X_hyphen_RateLimit_hyphen_Limit
                        self.X_hyphen_RateLimit_hyphen_Remaining = X_hyphen_RateLimit_hyphen_Remaining
                        self.X_hyphen_RateLimit_hyphen_Reset = X_hyphen_RateLimit_hyphen_Reset
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.lemurActionItems.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/generate/action-items/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.LemurActionItemsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LemurActionItemsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.lemurActionItems.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.lemurActionItems.Output.Ok.Headers = .init(),
                    body: Operations.lemurActionItems.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// LeMUR action items response
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.lemurActionItems.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.lemurActionItems.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/generate/action-items/post(lemurActionItems)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Retrieve LeMUR response
    ///
    /// Retrieve a LeMUR response that was previously generated.
    ///
    ///
    /// - Remark: HTTP `GET /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)`.
    public enum getLemurResponse {
        public static let id: Swift.String = "getLemurResponse"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the LeMUR request you previously made.
                /// This would be found in the response of the original request.
                ///
                ///
                /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/GET/path/request_id`.
                public var request_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - request_id: The ID of the LeMUR request you previously made.
                public init(request_id: Swift.String) {
                    self.request_id = request_id
                }
            }
            public var path: Operations.getLemurResponse.Input.Path
            /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLemurResponse.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getLemurResponse.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getLemurResponse.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getLemurResponse.Input.Path,
                headers: Operations.getLemurResponse.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LemurResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LemurResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getLemurResponse.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getLemurResponse.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// LeMUR response
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getLemurResponse.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getLemurResponse.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/get(getLemurResponse)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Purge LeMUR request data
    ///
    /// Delete the data for a previously submitted LeMUR request.
    /// The LLM response data, as well as any context provided in the original request will be removed.
    ///
    ///
    /// - Remark: HTTP `DELETE /lemur/v3/{request_id}`.
    /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)`.
    public enum purgeLemurRequestData {
        public static let id: Swift.String = "purgeLemurRequestData"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the LeMUR request whose data you want to delete. This would be found in the response of the original request.
                ///
                /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/DELETE/path/request_id`.
                public var request_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - request_id: The ID of the LeMUR request whose data you want to delete. This would be found in the response of the original request.
                public init(request_id: Swift.String) {
                    self.request_id = request_id
                }
            }
            public var path: Operations.purgeLemurRequestData.Input.Path
            /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.purgeLemurRequestData.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.purgeLemurRequestData.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.purgeLemurRequestData.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.purgeLemurRequestData.Input.Path,
                headers: Operations.purgeLemurRequestData.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/lemur/v3/{request_id}/DELETE/responses/200/content/application\/json`.
                    case json(Components.Schemas.PurgeLemurRequestDataResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PurgeLemurRequestDataResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.purgeLemurRequestData.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.purgeLemurRequestData.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// LeMUR request data deleted
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.purgeLemurRequestData.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.purgeLemurRequestData.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//lemur/v3/{request_id}/delete(purgeLemurRequestData)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
