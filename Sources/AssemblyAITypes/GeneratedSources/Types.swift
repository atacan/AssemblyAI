// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// <Note>To upload a media file to our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// <Warning>Requests to transcribe uploaded files must use an API key from the same project as the key that was used to upload the file. If you use an API key from a different project you will get a `403` error and "Cannot access uploaded file" message.</Warning>
    ///
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    func uploadFile(_ input: Operations.uploadFile.Input) async throws -> Operations.uploadFile.Output
    /// List transcripts
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest and can be retrieved for the last 90 days of usage. The previous URL always points to a page with older transcripts.
    ///
    /// If you need to retrieve transcripts from more than 90 days ago please reach out to our Support team at support@assemblyai.com.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    func listTranscripts(_ input: Operations.listTranscripts.Input) async throws -> Operations.listTranscripts.Output
    /// Transcribe audio
    ///
    /// <Note>To use our EU server for transcription, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    func createTranscript(_ input: Operations.createTranscript.Input) async throws -> Operations.createTranscript.Output
    /// Get transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    func getTranscript(_ input: Operations.getTranscript.Input) async throws -> Operations.getTranscript.Output
    /// Delete transcript
    ///
    /// <Note>To delete your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Remove the data from the transcript and mark it as deleted.
    ///
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    func deleteTranscript(_ input: Operations.deleteTranscript.Input) async throws -> Operations.deleteTranscript.Output
    /// Get subtitles for transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    func getSubtitles(_ input: Operations.getSubtitles.Input) async throws -> Operations.getSubtitles.Output
    /// Get sentences in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    func getTranscriptSentences(_ input: Operations.getTranscriptSentences.Input) async throws -> Operations.getTranscriptSentences.Output
    /// Get paragraphs in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    func getTranscriptParagraphs(_ input: Operations.getTranscriptParagraphs.Input) async throws -> Operations.getTranscriptParagraphs.Output
    /// Search words in transcript
    ///
    /// <Note>To search through a transcription created on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    func wordSearch(_ input: Operations.wordSearch.Input) async throws -> Operations.wordSearch.Output
    /// Get redacted audio
    ///
    /// <Note>To retrieve the redacted audio on the EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com` in the `GET` request above.</Note>
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    func getRedactedAudio(_ input: Operations.getRedactedAudio.Input) async throws -> Operations.getRedactedAudio.Output
    /// Generate temporary streaming token
    ///
    /// Generates a temporary authentication token for use with streaming services.
    ///
    ///
    /// - Remark: HTTP `GET /v3/token`.
    /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)`.
    func generateStreamingToken(_ input: Operations.generateStreamingToken.Input) async throws -> Operations.generateStreamingToken.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// <Note>To upload a media file to our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// <Warning>Requests to transcribe uploaded files must use an API key from the same project as the key that was used to upload the file. If you use an API key from a different project you will get a `403` error and "Cannot access uploaded file" message.</Warning>
    ///
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    public func uploadFile(
        headers: Operations.uploadFile.Input.Headers = .init(),
        body: Operations.uploadFile.Input.Body? = nil
    ) async throws -> Operations.uploadFile.Output {
        try await uploadFile(Operations.uploadFile.Input(
            headers: headers,
            body: body
        ))
    }
    /// List transcripts
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest and can be retrieved for the last 90 days of usage. The previous URL always points to a page with older transcripts.
    ///
    /// If you need to retrieve transcripts from more than 90 days ago please reach out to our Support team at support@assemblyai.com.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    public func listTranscripts(
        query: Operations.listTranscripts.Input.Query = .init(),
        headers: Operations.listTranscripts.Input.Headers = .init()
    ) async throws -> Operations.listTranscripts.Output {
        try await listTranscripts(Operations.listTranscripts.Input(
            query: query,
            headers: headers
        ))
    }
    /// Transcribe audio
    ///
    /// <Note>To use our EU server for transcription, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    public func createTranscript(
        headers: Operations.createTranscript.Input.Headers = .init(),
        body: Operations.createTranscript.Input.Body
    ) async throws -> Operations.createTranscript.Output {
        try await createTranscript(Operations.createTranscript.Input(
            headers: headers,
            body: body
        ))
    }
    /// Get transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    public func getTranscript(
        path: Operations.getTranscript.Input.Path,
        headers: Operations.getTranscript.Input.Headers = .init()
    ) async throws -> Operations.getTranscript.Output {
        try await getTranscript(Operations.getTranscript.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete transcript
    ///
    /// <Note>To delete your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Remove the data from the transcript and mark it as deleted.
    ///
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    public func deleteTranscript(
        path: Operations.deleteTranscript.Input.Path,
        headers: Operations.deleteTranscript.Input.Headers = .init()
    ) async throws -> Operations.deleteTranscript.Output {
        try await deleteTranscript(Operations.deleteTranscript.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get subtitles for transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    public func getSubtitles(
        path: Operations.getSubtitles.Input.Path,
        query: Operations.getSubtitles.Input.Query = .init(),
        headers: Operations.getSubtitles.Input.Headers = .init()
    ) async throws -> Operations.getSubtitles.Output {
        try await getSubtitles(Operations.getSubtitles.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get sentences in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    public func getTranscriptSentences(
        path: Operations.getTranscriptSentences.Input.Path,
        headers: Operations.getTranscriptSentences.Input.Headers = .init()
    ) async throws -> Operations.getTranscriptSentences.Output {
        try await getTranscriptSentences(Operations.getTranscriptSentences.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get paragraphs in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    public func getTranscriptParagraphs(
        path: Operations.getTranscriptParagraphs.Input.Path,
        headers: Operations.getTranscriptParagraphs.Input.Headers = .init()
    ) async throws -> Operations.getTranscriptParagraphs.Output {
        try await getTranscriptParagraphs(Operations.getTranscriptParagraphs.Input(
            path: path,
            headers: headers
        ))
    }
    /// Search words in transcript
    ///
    /// <Note>To search through a transcription created on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    public func wordSearch(
        path: Operations.wordSearch.Input.Path,
        query: Operations.wordSearch.Input.Query,
        headers: Operations.wordSearch.Input.Headers = .init()
    ) async throws -> Operations.wordSearch.Output {
        try await wordSearch(Operations.wordSearch.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get redacted audio
    ///
    /// <Note>To retrieve the redacted audio on the EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com` in the `GET` request above.</Note>
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    public func getRedactedAudio(
        path: Operations.getRedactedAudio.Input.Path,
        headers: Operations.getRedactedAudio.Input.Headers = .init()
    ) async throws -> Operations.getRedactedAudio.Output {
        try await getRedactedAudio(Operations.getRedactedAudio.Input(
            path: path,
            headers: headers
        ))
    }
    /// Generate temporary streaming token
    ///
    /// Generates a temporary authentication token for use with streaming services.
    ///
    ///
    /// - Remark: HTTP `GET /v3/token`.
    /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)`.
    public func generateStreamingToken(
        query: Operations.generateStreamingToken.Input.Query,
        headers: Operations.generateStreamingToken.Input.Headers = .init()
    ) async throws -> Operations.generateStreamingToken.Output {
        try await generateStreamingToken(Operations.generateStreamingToken.Input(
            query: query,
            headers: headers
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// AssemblyAI API
    public enum Server1 {
        /// AssemblyAI API
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.assemblyai.com",
                variables: []
            )
        }
    }
    /// AssemblyAI API
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://api.assemblyai.com",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// The notifications sent to the webhook URL.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification`.
        @frozen public enum TranscriptWebhookNotification: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification/case1`.
            case TranscriptReadyNotification(Components.Schemas.TranscriptReadyNotification)
            /// - Remark: Generated from `#/components/schemas/TranscriptWebhookNotification/case2`.
            case RedactedAudioNotification(Components.Schemas.RedactedAudioNotification)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .TranscriptReadyNotification(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RedactedAudioNotification(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .TranscriptReadyNotification(value):
                    try value.encode(to: encoder)
                case let .RedactedAudioNotification(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// The notification when the transcript status is completed or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification`.
        public struct TranscriptReadyNotification: Codable, Hashable, Sendable {
            /// The ID of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification/transcript_id`.
            public var transcript_id: Swift.String
            /// The status of the transcript. Either completed or error.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptReadyNotification/status`.
            public var status: Components.Schemas.TranscriptReadyStatus
            /// Creates a new `TranscriptReadyNotification`.
            ///
            /// - Parameters:
            ///   - transcript_id: The ID of the transcript
            ///   - status: The status of the transcript. Either completed or error.
            public init(
                transcript_id: Swift.String,
                status: Components.Schemas.TranscriptReadyStatus
            ) {
                self.transcript_id = transcript_id
                self.status = status
            }
            public enum CodingKeys: String, CodingKey {
                case transcript_id
                case status
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.transcript_id = try container.decode(
                    Swift.String.self,
                    forKey: .transcript_id
                )
                self.status = try container.decode(
                    Components.Schemas.TranscriptReadyStatus.self,
                    forKey: .status
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "transcript_id",
                    "status"
                ])
            }
        }
        /// The notification when the redacted audio is ready.
        ///
        /// - Remark: Generated from `#/components/schemas/RedactedAudioNotification`.
        public struct RedactedAudioNotification: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/RedactedAudioNotification/value1`.
            public var value1: Components.Schemas.RedactedAudioResponse
            /// Creates a new `RedactedAudioNotification`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.RedactedAudioResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse`.
        public struct RedactedAudioResponse: Codable, Hashable, Sendable {
            /// The status of the redacted audio
            ///
            /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse/status`.
            public var status: Components.Schemas.RedactedAudioStatus
            /// The URL of the redacted audio file
            ///
            /// - Remark: Generated from `#/components/schemas/RedactedAudioResponse/redacted_audio_url`.
            public var redacted_audio_url: Swift.String
            /// Creates a new `RedactedAudioResponse`.
            ///
            /// - Parameters:
            ///   - status: The status of the redacted audio
            ///   - redacted_audio_url: The URL of the redacted audio file
            public init(
                status: Components.Schemas.RedactedAudioStatus,
                redacted_audio_url: Swift.String
            ) {
                self.status = status
                self.redacted_audio_url = redacted_audio_url
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case redacted_audio_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.status = try container.decode(
                    Components.Schemas.RedactedAudioStatus.self,
                    forKey: .status
                )
                self.redacted_audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .redacted_audio_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "status",
                    "redacted_audio_url"
                ])
            }
        }
        /// The status of the redacted audio
        ///
        /// - Remark: Generated from `#/components/schemas/RedactedAudioStatus`.
        @frozen public enum RedactedAudioStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case redacted_audio_ready = "redacted_audio_ready"
        }
        /// Format of the subtitles
        ///
        /// - Remark: Generated from `#/components/schemas/SubtitleFormat`.
        @frozen public enum SubtitleFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case srt = "srt"
            case vtt = "vtt"
        }
        /// - Remark: Generated from `#/components/schemas/WordSearchResponse`.
        public struct WordSearchResponse: Codable, Hashable, Sendable {
            /// The ID of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/id`.
            public var id: Swift.String
            /// The total count of all matched instances. For e.g., word 1 matched 2 times, and word 2 matched 3 times, `total_count` will equal 5.
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/total_count`.
            public var total_count: Swift.Int
            /// The matches of the search
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchResponse/matches`.
            public var matches: [Components.Schemas.WordSearchMatch]
            /// Creates a new `WordSearchResponse`.
            ///
            /// - Parameters:
            ///   - id: The ID of the transcript
            ///   - total_count: The total count of all matched instances. For e.g., word 1 matched 2 times, and word 2 matched 3 times, `total_count` will equal 5.
            ///   - matches: The matches of the search
            public init(
                id: Swift.String,
                total_count: Swift.Int,
                matches: [Components.Schemas.WordSearchMatch]
            ) {
                self.id = id
                self.total_count = total_count
                self.matches = matches
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case total_count
                case matches
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                self.total_count = try container.decode(
                    Swift.Int.self,
                    forKey: .total_count
                )
                self.matches = try container.decode(
                    [Components.Schemas.WordSearchMatch].self,
                    forKey: .matches
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "total_count",
                    "matches"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/WordSearchMatch`.
        public struct WordSearchMatch: Codable, Hashable, Sendable {
            /// The matched word
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/text`.
            public var text: Swift.String
            /// The total amount of times the word is in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/count`.
            public var count: Swift.Int
            /// An array of timestamps
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/timestamps`.
            public var timestamps: [Components.Schemas.WordSearchTimestamp]
            /// An array of all index locations for that word within the `words` array of the completed transcript
            ///
            /// - Remark: Generated from `#/components/schemas/WordSearchMatch/indexes`.
            public var indexes: [Swift.Int]
            /// Creates a new `WordSearchMatch`.
            ///
            /// - Parameters:
            ///   - text: The matched word
            ///   - count: The total amount of times the word is in the transcript
            ///   - timestamps: An array of timestamps
            ///   - indexes: An array of all index locations for that word within the `words` array of the completed transcript
            public init(
                text: Swift.String,
                count: Swift.Int,
                timestamps: [Components.Schemas.WordSearchTimestamp],
                indexes: [Swift.Int]
            ) {
                self.text = text
                self.count = count
                self.timestamps = timestamps
                self.indexes = indexes
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case count
                case timestamps
                case indexes
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.count = try container.decode(
                    Swift.Int.self,
                    forKey: .count
                )
                self.timestamps = try container.decode(
                    [Components.Schemas.WordSearchTimestamp].self,
                    forKey: .timestamps
                )
                self.indexes = try container.decode(
                    [Swift.Int].self,
                    forKey: .indexes
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "count",
                    "timestamps",
                    "indexes"
                ])
            }
        }
        /// An array of timestamps structured as [`start_time`, `end_time`] in milliseconds
        ///
        /// - Remark: Generated from `#/components/schemas/WordSearchTimestamp`.
        public typealias WordSearchTimestamp = [Swift.Int]
        /// Timestamp containing a start and end property in milliseconds
        ///
        /// - Remark: Generated from `#/components/schemas/Timestamp`.
        public struct Timestamp: Codable, Hashable, Sendable {
            /// The start time in milliseconds
            ///
            /// - Remark: Generated from `#/components/schemas/Timestamp/start`.
            public var start: Swift.Int
            /// The end time in milliseconds
            ///
            /// - Remark: Generated from `#/components/schemas/Timestamp/end`.
            public var end: Swift.Int
            /// Creates a new `Timestamp`.
            ///
            /// - Parameters:
            ///   - start: The start time in milliseconds
            ///   - end: The end time in milliseconds
            public init(
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "start",
                    "end"
                ])
            }
        }
        /// The parameters for creating a transcript
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams`.
        public struct TranscriptOptionalParams: Codable, Hashable, Sendable {
            /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code`.
            public struct language_codePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code/value1`.
                public var value1: Components.Schemas.TranscriptLanguageCode?
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code/value2`.
                public var value2: Swift.String?
                /// Creates a new `language_codePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.TranscriptLanguageCode? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        self.value1,
                        self.value2
                    ])
                }
            }
            /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_code`.
            public var language_code: Components.Schemas.TranscriptOptionalParams.language_codePayload?
            /// The language codes of your audio file. Used for [Code switching](/docs/speech-to-text/pre-recorded-audio/code-switching)
            /// One of the values specified must be `en`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_codes`.
            public var language_codes: [Components.Schemas.TranscriptLanguageCode]?
            /// Enable [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection), either true or false.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection`.
            public var language_detection: Swift.Bool?
            /// Specify options for Automatic Language Detection.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options`.
            public struct language_detection_optionsPayload: Codable, Hashable, Sendable {
                /// List of languages expected in the audio file. Defaults to `["all"]` when unspecified.
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options/expected_languages`.
                public var expected_languages: [Swift.String]?
                /// If the detected language of the audio file is not in the list of expected languages, the `fallback_language` is used. Specify `["auto"]` to let our model choose the fallback language from `expected_languages` with the highest confidence score.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options/fallback_language`.
                public var fallback_language: Swift.String?
                /// Whether code switching should be detected.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options/code_switching`.
                public var code_switching: Swift.Bool?
                /// The confidence threshold for code switching detection. If the code switching confidence is below this threshold, the transcript will be processed in the language with the highest `language_detection_confidence` score.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options/code_switching_confidence_threshold`.
                public var code_switching_confidence_threshold: Swift.Float?
                /// Creates a new `language_detection_optionsPayload`.
                ///
                /// - Parameters:
                ///   - expected_languages: List of languages expected in the audio file. Defaults to `["all"]` when unspecified.
                ///   - fallback_language: If the detected language of the audio file is not in the list of expected languages, the `fallback_language` is used. Specify `["auto"]` to let our model choose the fallback language from `expected_languages` with the highest confidence score.
                ///   - code_switching: Whether code switching should be detected.
                ///   - code_switching_confidence_threshold: The confidence threshold for code switching detection. If the code switching confidence is below this threshold, the transcript will be processed in the language with the highest `language_detection_confidence` score.
                public init(
                    expected_languages: [Swift.String]? = nil,
                    fallback_language: Swift.String? = nil,
                    code_switching: Swift.Bool? = nil,
                    code_switching_confidence_threshold: Swift.Float? = nil
                ) {
                    self.expected_languages = expected_languages
                    self.fallback_language = fallback_language
                    self.code_switching = code_switching
                    self.code_switching_confidence_threshold = code_switching_confidence_threshold
                }
                public enum CodingKeys: String, CodingKey {
                    case expected_languages
                    case fallback_language
                    case code_switching
                    case code_switching_confidence_threshold
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.expected_languages = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .expected_languages
                    )
                    self.fallback_language = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .fallback_language
                    )
                    self.code_switching = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .code_switching
                    )
                    self.code_switching_confidence_threshold = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .code_switching_confidence_threshold
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "expected_languages",
                        "fallback_language",
                        "code_switching",
                        "code_switching_confidence_threshold"
                    ])
                }
            }
            /// Specify options for Automatic Language Detection.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_detection_options`.
            public var language_detection_options: Components.Schemas.TranscriptOptionalParams.language_detection_optionsPayload?
            /// The confidence threshold for the automatically detected language.
            /// An error will be returned if the language confidence is below this threshold.
            /// Defaults to 0.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/language_confidence_threshold`.
            public var language_confidence_threshold: Swift.Float?
            /// The speech model to use for the transcription. When `null`, the `universal` model is used.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_model`.
            @available(*, deprecated)
            public var speech_model: Components.Schemas.SpeechModel?
            /// List multiple speech models in priority order, allowing our system to automatically route your audio to the best available option.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_models`.
            public var speech_models: [Components.Schemas.SpeechModel]?
            /// Enable Automatic Punctuation, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/punctuate`.
            public var punctuate: Swift.Bool?
            /// Enable Text Formatting, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/format_text`.
            public var format_text: Swift.Bool?
            /// Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/disfluencies`.
            public var disfluencies: Swift.Bool?
            /// Enable [Multichannel](https://www.assemblyai.com/docs/models/speech-recognition#multichannel-transcription) transcription, can be true or false.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/multichannel`.
            public var multichannel: Swift.Bool?
            /// The URL to which we send webhook requests.
            /// We sends two different types of webhook requests.
            /// One request when a transcript is completed or failed, and one request when the redacted audio is ready if redact_pii_audio is enabled.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_url`.
            public var webhook_url: Swift.String?
            /// The header name to be sent with the transcript completed or failed webhook requests
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_auth_header_name`.
            public var webhook_auth_header_name: Swift.String?
            /// The header value to send back with the transcript completed or failed webhook requests for added security
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/webhook_auth_header_value`.
            public var webhook_auth_header_value: Swift.String?
            /// Enable Key Phrases, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/auto_highlights`.
            public var auto_highlights: Swift.Bool?
            /// The point in time, in milliseconds, to begin transcribing in your media file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/audio_start_from`.
            public var audio_start_from: Swift.Int?
            /// The point in time, in milliseconds, to stop transcribing in your media file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/audio_end_at`.
            public var audio_end_at: Swift.Int?
            /// Filter profanity from the transcribed text, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/filter_profanity`.
            public var filter_profanity: Swift.Bool?
            /// Redact PII from the transcribed text using the Redact PII model, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii`.
            public var redact_pii: Swift.Bool?
            /// Generate a copy of the original media file with spoken PII "beeped" out, can be true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio`.
            public var redact_pii_audio: Swift.Bool?
            /// Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio_quality`.
            public var redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality?
            /// The list of PII Redaction policies to enable. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_policies`.
            public var redact_pii_policies: [Components.Schemas.PiiPolicy]?
            /// The replacement logic for detected PII, can be `entity_type` or `hash`. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_sub`.
            public var redact_pii_sub: Components.Schemas.SubstitutionPolicy?
            /// Specify options for PII redacted audio files.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio_options`.
            public struct redact_pii_audio_optionsPayload: Codable, Hashable, Sendable {
                /// By default, audio redaction provides redacted audio URLs only when speech is detected. However, if your use-case specifically requires redacted audio files even for silent audio files without any dialogue, you can opt to receive these URLs by setting this parameter to `true`.
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio_options/return_redacted_no_speech_audio`.
                public var return_redacted_no_speech_audio: Swift.Bool?
                /// Creates a new `redact_pii_audio_optionsPayload`.
                ///
                /// - Parameters:
                ///   - return_redacted_no_speech_audio: By default, audio redaction provides redacted audio URLs only when speech is detected. However, if your use-case specifically requires redacted audio files even for silent audio files without any dialogue, you can opt to receive these URLs by setting this parameter to `true`.
                public init(return_redacted_no_speech_audio: Swift.Bool? = nil) {
                    self.return_redacted_no_speech_audio = return_redacted_no_speech_audio
                }
                public enum CodingKeys: String, CodingKey {
                    case return_redacted_no_speech_audio
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.return_redacted_no_speech_audio = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .return_redacted_no_speech_audio
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "return_redacted_no_speech_audio"
                    ])
                }
            }
            /// Specify options for PII redacted audio files.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/redact_pii_audio_options`.
            public var redact_pii_audio_options: Components.Schemas.TranscriptOptionalParams.redact_pii_audio_optionsPayload?
            /// Enable [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_labels`.
            public var speaker_labels: Swift.Bool?
            /// Tells the speaker label model how many speakers it should attempt to identify. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speakers_expected`.
            public var speakers_expected: Swift.Int?
            /// Specify options for speaker diarization.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_options`.
            public struct speaker_optionsPayload: Codable, Hashable, Sendable {
                /// The minimum number of speakers expected in the audio file.
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_options/min_speakers_expected`.
                public var min_speakers_expected: Swift.Int?
                /// <Warning>Setting this parameter too high may hurt model accuracy</Warning>
                /// The maximum number of speakers expected in the audio file.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_options/max_speakers_expected`.
                public var max_speakers_expected: Swift.Int?
                /// Creates a new `speaker_optionsPayload`.
                ///
                /// - Parameters:
                ///   - min_speakers_expected: The minimum number of speakers expected in the audio file.
                ///   - max_speakers_expected: <Warning>Setting this parameter too high may hurt model accuracy</Warning>
                public init(
                    min_speakers_expected: Swift.Int? = nil,
                    max_speakers_expected: Swift.Int? = nil
                ) {
                    self.min_speakers_expected = min_speakers_expected
                    self.max_speakers_expected = max_speakers_expected
                }
                public enum CodingKeys: String, CodingKey {
                    case min_speakers_expected
                    case max_speakers_expected
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.min_speakers_expected = try container.decodeIfPresent(
                        Swift.Int.self,
                        forKey: .min_speakers_expected
                    )
                    self.max_speakers_expected = try container.decodeIfPresent(
                        Swift.Int.self,
                        forKey: .max_speakers_expected
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "min_speakers_expected",
                        "max_speakers_expected"
                    ])
                }
            }
            /// Specify options for speaker diarization.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speaker_options`.
            public var speaker_options: Components.Schemas.TranscriptOptionalParams.speaker_optionsPayload?
            /// Enable [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/content_safety`.
            public var content_safety: Swift.Bool?
            /// The confidence threshold for the Content Moderation model. Values must be between 25 and 100.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/content_safety_confidence`.
            public var content_safety_confidence: Swift.Int?
            /// Enable [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/iab_categories`.
            public var iab_categories: Swift.Bool?
            /// Customize how words are spelled and formatted using to and from values
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/custom_spelling`.
            public var custom_spelling: [Components.Schemas.TranscriptCustomSpelling]?
            /// Improve accuracy with up to 200 (for Universal) or 1000 (for Slam-1) domain-specific words or phrases (maximum 6 words per phrase).
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/keyterms_prompt`.
            public var keyterms_prompt: [Swift.String]?
            /// This parameter does not currently have any functionality attached to it.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/prompt`.
            @available(*, deprecated)
            public var prompt: Swift.String?
            /// Enable [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/sentiment_analysis`.
            public var sentiment_analysis: Swift.Bool?
            /// Enable [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/auto_chapters`.
            public var auto_chapters: Swift.Bool?
            /// Enable [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/entity_detection`.
            public var entity_detection: Swift.Bool?
            /// Reject audio files that contain less than this fraction of speech.
            /// Valid values are in the range [0, 1] inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_threshold`.
            public var speech_threshold: Swift.Float?
            /// Enable [Summarization](https://www.assemblyai.com/docs/models/summarization), can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summarization`.
            public var summarization: Swift.Bool?
            /// The model to summarize the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summary_model`.
            public var summary_model: Components.Schemas.SummaryModel?
            /// The type of summary
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/summary_type`.
            public var summary_type: Components.Schemas.SummaryType?
            /// Enable custom topics, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/custom_topics`.
            @available(*, deprecated)
            public var custom_topics: Swift.Bool?
            /// The list of custom topics
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/topics`.
            @available(*, deprecated)
            public var topics: [Swift.String]?
            /// Enable speech understanding tasks like translation, speaker identification, and custom formatting
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding`.
            public struct speech_understandingPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding/request`.
                @frozen public enum requestPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding/request/case1`.
                    case TranslationRequestBody(Components.Schemas.TranslationRequestBody)
                    /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding/request/case2`.
                    case SpeakerIdentificationRequestBody(Components.Schemas.SpeakerIdentificationRequestBody)
                    /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding/request/case3`.
                    case CustomFormattingRequestBody(Components.Schemas.CustomFormattingRequestBody)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .TranslationRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .SpeakerIdentificationRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .CustomFormattingRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .TranslationRequestBody(value):
                            try value.encode(to: encoder)
                        case let .SpeakerIdentificationRequestBody(value):
                            try value.encode(to: encoder)
                        case let .CustomFormattingRequestBody(value):
                            try value.encode(to: encoder)
                        }
                    }
                }
                /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding/request`.
                public var request: Components.Schemas.TranscriptOptionalParams.speech_understandingPayload.requestPayload
                /// Creates a new `speech_understandingPayload`.
                ///
                /// - Parameters:
                ///   - request:
                public init(request: Components.Schemas.TranscriptOptionalParams.speech_understandingPayload.requestPayload) {
                    self.request = request
                }
                public enum CodingKeys: String, CodingKey {
                    case request
                }
            }
            /// Enable speech understanding tasks like translation, speaker identification, and custom formatting
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptOptionalParams/speech_understanding`.
            public var speech_understanding: Components.Schemas.TranscriptOptionalParams.speech_understandingPayload?
            /// Creates a new `TranscriptOptionalParams`.
            ///
            /// - Parameters:
            ///   - language_code: The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            ///   - language_codes: The language codes of your audio file. Used for [Code switching](/docs/speech-to-text/pre-recorded-audio/code-switching)
            ///   - language_detection: Enable [Automatic language detection](https://www.assemblyai.com/docs/models/speech-recognition#automatic-language-detection), either true or false.
            ///   - language_detection_options: Specify options for Automatic Language Detection.
            ///   - language_confidence_threshold: The confidence threshold for the automatically detected language.
            ///   - speech_model: The speech model to use for the transcription. When `null`, the `universal` model is used.
            ///   - speech_models: List multiple speech models in priority order, allowing our system to automatically route your audio to the best available option.
            ///   - punctuate: Enable Automatic Punctuation, can be true or false
            ///   - format_text: Enable Text Formatting, can be true or false
            ///   - disfluencies: Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///   - multichannel: Enable [Multichannel](https://www.assemblyai.com/docs/models/speech-recognition#multichannel-transcription) transcription, can be true or false.
            ///   - webhook_url: The URL to which we send webhook requests.
            ///   - webhook_auth_header_name: The header name to be sent with the transcript completed or failed webhook requests
            ///   - webhook_auth_header_value: The header value to send back with the transcript completed or failed webhook requests for added security
            ///   - auto_highlights: Enable Key Phrases, either true or false
            ///   - audio_start_from: The point in time, in milliseconds, to begin transcribing in your media file
            ///   - audio_end_at: The point in time, in milliseconds, to stop transcribing in your media file
            ///   - filter_profanity: Filter profanity from the transcribed text, can be true or false
            ///   - redact_pii: Redact PII from the transcribed text using the Redact PII model, can be true or false
            ///   - redact_pii_audio: Generate a copy of the original media file with spoken PII "beeped" out, can be true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_audio_quality: Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_policies: The list of PII Redaction policies to enable. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_sub: The replacement logic for detected PII, can be `entity_type` or `hash`. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - redact_pii_audio_options: Specify options for PII redacted audio files.
            ///   - speaker_labels: Enable [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization), can be true or false
            ///   - speakers_expected: Tells the speaker label model how many speakers it should attempt to identify. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///   - speaker_options: Specify options for speaker diarization.
            ///   - content_safety: Enable [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation), can be true or false
            ///   - content_safety_confidence: The confidence threshold for the Content Moderation model. Values must be between 25 and 100.
            ///   - iab_categories: Enable [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection), can be true or false
            ///   - custom_spelling: Customize how words are spelled and formatted using to and from values
            ///   - keyterms_prompt: Improve accuracy with up to 200 (for Universal) or 1000 (for Slam-1) domain-specific words or phrases (maximum 6 words per phrase).
            ///   - prompt: This parameter does not currently have any functionality attached to it.
            ///   - sentiment_analysis: Enable [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis), can be true or false
            ///   - auto_chapters: Enable [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters), can be true or false
            ///   - entity_detection: Enable [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection), can be true or false
            ///   - speech_threshold: Reject audio files that contain less than this fraction of speech.
            ///   - summarization: Enable [Summarization](https://www.assemblyai.com/docs/models/summarization), can be true or false
            ///   - summary_model: The model to summarize the transcript
            ///   - summary_type: The type of summary
            ///   - custom_topics: Enable custom topics, either true or false
            ///   - topics: The list of custom topics
            ///   - speech_understanding: Enable speech understanding tasks like translation, speaker identification, and custom formatting
            public init(
                language_code: Components.Schemas.TranscriptOptionalParams.language_codePayload? = nil,
                language_codes: [Components.Schemas.TranscriptLanguageCode]? = nil,
                language_detection: Swift.Bool? = nil,
                language_detection_options: Components.Schemas.TranscriptOptionalParams.language_detection_optionsPayload? = nil,
                language_confidence_threshold: Swift.Float? = nil,
                speech_model: Components.Schemas.SpeechModel? = nil,
                speech_models: [Components.Schemas.SpeechModel]? = nil,
                punctuate: Swift.Bool? = nil,
                format_text: Swift.Bool? = nil,
                disfluencies: Swift.Bool? = nil,
                multichannel: Swift.Bool? = nil,
                webhook_url: Swift.String? = nil,
                webhook_auth_header_name: Swift.String? = nil,
                webhook_auth_header_value: Swift.String? = nil,
                auto_highlights: Swift.Bool? = nil,
                audio_start_from: Swift.Int? = nil,
                audio_end_at: Swift.Int? = nil,
                filter_profanity: Swift.Bool? = nil,
                redact_pii: Swift.Bool? = nil,
                redact_pii_audio: Swift.Bool? = nil,
                redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality? = nil,
                redact_pii_policies: [Components.Schemas.PiiPolicy]? = nil,
                redact_pii_sub: Components.Schemas.SubstitutionPolicy? = nil,
                redact_pii_audio_options: Components.Schemas.TranscriptOptionalParams.redact_pii_audio_optionsPayload? = nil,
                speaker_labels: Swift.Bool? = nil,
                speakers_expected: Swift.Int? = nil,
                speaker_options: Components.Schemas.TranscriptOptionalParams.speaker_optionsPayload? = nil,
                content_safety: Swift.Bool? = nil,
                content_safety_confidence: Swift.Int? = nil,
                iab_categories: Swift.Bool? = nil,
                custom_spelling: [Components.Schemas.TranscriptCustomSpelling]? = nil,
                keyterms_prompt: [Swift.String]? = nil,
                prompt: Swift.String? = nil,
                sentiment_analysis: Swift.Bool? = nil,
                auto_chapters: Swift.Bool? = nil,
                entity_detection: Swift.Bool? = nil,
                speech_threshold: Swift.Float? = nil,
                summarization: Swift.Bool? = nil,
                summary_model: Components.Schemas.SummaryModel? = nil,
                summary_type: Components.Schemas.SummaryType? = nil,
                custom_topics: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                speech_understanding: Components.Schemas.TranscriptOptionalParams.speech_understandingPayload? = nil
            ) {
                self.language_code = language_code
                self.language_codes = language_codes
                self.language_detection = language_detection
                self.language_detection_options = language_detection_options
                self.language_confidence_threshold = language_confidence_threshold
                self.speech_model = speech_model
                self.speech_models = speech_models
                self.punctuate = punctuate
                self.format_text = format_text
                self.disfluencies = disfluencies
                self.multichannel = multichannel
                self.webhook_url = webhook_url
                self.webhook_auth_header_name = webhook_auth_header_name
                self.webhook_auth_header_value = webhook_auth_header_value
                self.auto_highlights = auto_highlights
                self.audio_start_from = audio_start_from
                self.audio_end_at = audio_end_at
                self.filter_profanity = filter_profanity
                self.redact_pii = redact_pii
                self.redact_pii_audio = redact_pii_audio
                self.redact_pii_audio_quality = redact_pii_audio_quality
                self.redact_pii_policies = redact_pii_policies
                self.redact_pii_sub = redact_pii_sub
                self.redact_pii_audio_options = redact_pii_audio_options
                self.speaker_labels = speaker_labels
                self.speakers_expected = speakers_expected
                self.speaker_options = speaker_options
                self.content_safety = content_safety
                self.content_safety_confidence = content_safety_confidence
                self.iab_categories = iab_categories
                self.custom_spelling = custom_spelling
                self.keyterms_prompt = keyterms_prompt
                self.prompt = prompt
                self.sentiment_analysis = sentiment_analysis
                self.auto_chapters = auto_chapters
                self.entity_detection = entity_detection
                self.speech_threshold = speech_threshold
                self.summarization = summarization
                self.summary_model = summary_model
                self.summary_type = summary_type
                self.custom_topics = custom_topics
                self.topics = topics
                self.speech_understanding = speech_understanding
            }
            public enum CodingKeys: String, CodingKey {
                case language_code
                case language_codes
                case language_detection
                case language_detection_options
                case language_confidence_threshold
                case speech_model
                case speech_models
                case punctuate
                case format_text
                case disfluencies
                case multichannel
                case webhook_url
                case webhook_auth_header_name
                case webhook_auth_header_value
                case auto_highlights
                case audio_start_from
                case audio_end_at
                case filter_profanity
                case redact_pii
                case redact_pii_audio
                case redact_pii_audio_quality
                case redact_pii_policies
                case redact_pii_sub
                case redact_pii_audio_options
                case speaker_labels
                case speakers_expected
                case speaker_options
                case content_safety
                case content_safety_confidence
                case iab_categories
                case custom_spelling
                case keyterms_prompt
                case prompt
                case sentiment_analysis
                case auto_chapters
                case entity_detection
                case speech_threshold
                case summarization
                case summary_model
                case summary_type
                case custom_topics
                case topics
                case speech_understanding
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.language_code = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.language_codePayload.self,
                    forKey: .language_code
                )
                self.language_codes = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptLanguageCode].self,
                    forKey: .language_codes
                )
                self.language_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .language_detection
                )
                self.language_detection_options = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.language_detection_optionsPayload.self,
                    forKey: .language_detection_options
                )
                self.language_confidence_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .language_confidence_threshold
                )
                self.speech_model = try container.decodeIfPresent(
                    Components.Schemas.SpeechModel.self,
                    forKey: .speech_model
                )
                self.speech_models = try container.decodeIfPresent(
                    [Components.Schemas.SpeechModel].self,
                    forKey: .speech_models
                )
                self.punctuate = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .punctuate
                )
                self.format_text = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .format_text
                )
                self.disfluencies = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .disfluencies
                )
                self.multichannel = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .multichannel
                )
                self.webhook_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_url
                )
                self.webhook_auth_header_name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_name
                )
                self.webhook_auth_header_value = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_value
                )
                self.auto_highlights = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_highlights
                )
                self.audio_start_from = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_start_from
                )
                self.audio_end_at = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_end_at
                )
                self.filter_profanity = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .filter_profanity
                )
                self.redact_pii = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii
                )
                self.redact_pii_audio = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii_audio
                )
                self.redact_pii_audio_quality = try container.decodeIfPresent(
                    Components.Schemas.RedactPiiAudioQuality.self,
                    forKey: .redact_pii_audio_quality
                )
                self.redact_pii_policies = try container.decodeIfPresent(
                    [Components.Schemas.PiiPolicy].self,
                    forKey: .redact_pii_policies
                )
                self.redact_pii_sub = try container.decodeIfPresent(
                    Components.Schemas.SubstitutionPolicy.self,
                    forKey: .redact_pii_sub
                )
                self.redact_pii_audio_options = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.redact_pii_audio_optionsPayload.self,
                    forKey: .redact_pii_audio_options
                )
                self.speaker_labels = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speaker_labels
                )
                self.speakers_expected = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .speakers_expected
                )
                self.speaker_options = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.speaker_optionsPayload.self,
                    forKey: .speaker_options
                )
                self.content_safety = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .content_safety
                )
                self.content_safety_confidence = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .content_safety_confidence
                )
                self.iab_categories = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .iab_categories
                )
                self.custom_spelling = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptCustomSpelling].self,
                    forKey: .custom_spelling
                )
                self.keyterms_prompt = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .keyterms_prompt
                )
                self.prompt = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .prompt
                )
                self.sentiment_analysis = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .sentiment_analysis
                )
                self.auto_chapters = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_chapters
                )
                self.entity_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .entity_detection
                )
                self.speech_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .speech_threshold
                )
                self.summarization = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .summarization
                )
                self.summary_model = try container.decodeIfPresent(
                    Components.Schemas.SummaryModel.self,
                    forKey: .summary_model
                )
                self.summary_type = try container.decodeIfPresent(
                    Components.Schemas.SummaryType.self,
                    forKey: .summary_type
                )
                self.custom_topics = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .custom_topics
                )
                self.topics = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .topics
                )
                self.speech_understanding = try container.decodeIfPresent(
                    Components.Schemas.TranscriptOptionalParams.speech_understandingPayload.self,
                    forKey: .speech_understanding
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "language_code",
                    "language_codes",
                    "language_detection",
                    "language_detection_options",
                    "language_confidence_threshold",
                    "speech_model",
                    "speech_models",
                    "punctuate",
                    "format_text",
                    "disfluencies",
                    "multichannel",
                    "webhook_url",
                    "webhook_auth_header_name",
                    "webhook_auth_header_value",
                    "auto_highlights",
                    "audio_start_from",
                    "audio_end_at",
                    "filter_profanity",
                    "redact_pii",
                    "redact_pii_audio",
                    "redact_pii_audio_quality",
                    "redact_pii_policies",
                    "redact_pii_sub",
                    "redact_pii_audio_options",
                    "speaker_labels",
                    "speakers_expected",
                    "speaker_options",
                    "content_safety",
                    "content_safety_confidence",
                    "iab_categories",
                    "custom_spelling",
                    "keyterms_prompt",
                    "prompt",
                    "sentiment_analysis",
                    "auto_chapters",
                    "entity_detection",
                    "speech_threshold",
                    "summarization",
                    "summary_model",
                    "summary_type",
                    "custom_topics",
                    "topics",
                    "speech_understanding"
                ])
            }
        }
        /// The parameters for creating a transcript
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptParams`.
        public struct TranscriptParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// The URL of the audio or video file to transcribe.
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1/audio_url`.
                public var audio_url: Swift.String
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - audio_url: The URL of the audio or video file to transcribe.
                public init(audio_url: Swift.String) {
                    self.audio_url = audio_url
                }
                public enum CodingKeys: String, CodingKey {
                    case audio_url
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.audio_url = try container.decode(
                        Swift.String.self,
                        forKey: .audio_url
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "audio_url"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value1`.
            public var value1: Components.Schemas.TranscriptParams.Value1Payload
            /// - Remark: Generated from `#/components/schemas/TranscriptParams/value2`.
            public var value2: Components.Schemas.TranscriptOptionalParams
            /// Creates a new `TranscriptParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.TranscriptParams.Value1Payload,
                value2: Components.Schemas.TranscriptOptionalParams
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// The model to summarize the transcript
        ///
        /// - Remark: Generated from `#/components/schemas/SummaryModel`.
        @frozen public enum SummaryModel: String, Codable, Hashable, Sendable, CaseIterable {
            case informative = "informative"
            case conversational = "conversational"
            case catchy = "catchy"
        }
        /// The type of summary
        ///
        /// - Remark: Generated from `#/components/schemas/SummaryType`.
        @frozen public enum SummaryType: String, Codable, Hashable, Sendable, CaseIterable {
            case bullets = "bullets"
            case bullets_verbose = "bullets_verbose"
            case gist = "gist"
            case headline = "headline"
            case paragraph = "paragraph"
        }
        /// How much to boost specified words
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptBoostParam`.
        @frozen public enum TranscriptBoostParam: String, Codable, Hashable, Sendable, CaseIterable {
            case low = "low"
            case _default = "default"
            case high = "high"
        }
        /// Object containing words or phrases to replace, and the word or phrase to replace with
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling`.
        public struct TranscriptCustomSpelling: Codable, Hashable, Sendable {
            /// Words or phrases to replace
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling/from`.
            public var from: [Swift.String]
            /// Word to replace with
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptCustomSpelling/to`.
            public var to: Swift.String
            /// Creates a new `TranscriptCustomSpelling`.
            ///
            /// - Parameters:
            ///   - from: Words or phrases to replace
            ///   - to: Word to replace with
            public init(
                from: [Swift.String],
                to: Swift.String
            ) {
                self.from = from
                self.to = to
            }
            public enum CodingKeys: String, CodingKey {
                case from
                case to
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.from = try container.decode(
                    [Swift.String].self,
                    forKey: .from
                )
                self.to = try container.decode(
                    Swift.String.self,
                    forKey: .to
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "from",
                    "to"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptUtterance`.
        public struct TranscriptUtterance: Codable, Hashable, Sendable {
            /// The confidence score for the transcript of this utterance
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/confidence`.
            public var confidence: Swift.Double
            /// The starting time, in milliseconds, of the utterance in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the utterance in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/end`.
            public var end: Swift.Int
            /// The text for this utterance
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/text`.
            public var text: Swift.String
            /// The words in the utterance.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/channel`.
            public var channel: Swift.String?
            /// The speaker of this utterance, where each speaker is assigned a sequential capital letter - e.g. "A" for Speaker A, "B" for Speaker B, etc.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptUtterance/speaker`.
            public var speaker: Swift.String
            /// Creates a new `TranscriptUtterance`.
            ///
            /// - Parameters:
            ///   - confidence: The confidence score for the transcript of this utterance
            ///   - start: The starting time, in milliseconds, of the utterance in the audio file
            ///   - end: The ending time, in milliseconds, of the utterance in the audio file
            ///   - text: The text for this utterance
            ///   - words: The words in the utterance.
            ///   - channel: The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of this utterance, where each speaker is assigned a sequential capital letter - e.g. "A" for Speaker A, "B" for Speaker B, etc.
            public init(
                confidence: Swift.Double,
                start: Swift.Int,
                end: Swift.Int,
                text: Swift.String,
                words: [Components.Schemas.TranscriptWord],
                channel: Swift.String? = nil,
                speaker: Swift.String
            ) {
                self.confidence = confidence
                self.start = start
                self.end = end
                self.text = text
                self.words = words
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case confidence
                case start
                case end
                case text
                case words
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                self.channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                self.speaker = try container.decode(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "confidence",
                    "start",
                    "end",
                    "text",
                    "words",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// The replacement logic for detected PII, can be `entity_name` or `hash`. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
        ///
        /// - Remark: Generated from `#/components/schemas/SubstitutionPolicy`.
        @frozen public enum SubstitutionPolicy: String, Codable, Hashable, Sendable, CaseIterable {
            case entity_name = "entity_name"
            case hash = "hash"
        }
        /// Controls the filetype of the audio created by redact_pii_audio. Currently supports mp3 (default) and wav. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
        ///
        /// - Remark: Generated from `#/components/schemas/RedactPiiAudioQuality`.
        @frozen public enum RedactPiiAudioQuality: String, Codable, Hashable, Sendable, CaseIterable {
            case mp3 = "mp3"
            case wav = "wav"
        }
        /// The type of PII to redact
        ///
        /// - Remark: Generated from `#/components/schemas/PiiPolicy`.
        @frozen public enum PiiPolicy: String, Codable, Hashable, Sendable, CaseIterable {
            case account_number = "account_number"
            case banking_information = "banking_information"
            case blood_type = "blood_type"
            case credit_card_cvv = "credit_card_cvv"
            case credit_card_expiration = "credit_card_expiration"
            case credit_card_number = "credit_card_number"
            case date = "date"
            case date_interval = "date_interval"
            case date_of_birth = "date_of_birth"
            case drivers_license = "drivers_license"
            case drug = "drug"
            case duration = "duration"
            case email_address = "email_address"
            case event = "event"
            case filename = "filename"
            case gender_sexuality = "gender_sexuality"
            case healthcare_number = "healthcare_number"
            case injury = "injury"
            case ip_address = "ip_address"
            case language = "language"
            case location = "location"
            case marital_status = "marital_status"
            case medical_condition = "medical_condition"
            case medical_process = "medical_process"
            case money_amount = "money_amount"
            case nationality = "nationality"
            case number_sequence = "number_sequence"
            case occupation = "occupation"
            case organization = "organization"
            case passport_number = "passport_number"
            case password = "password"
            case person_age = "person_age"
            case person_name = "person_name"
            case phone_number = "phone_number"
            case physical_attribute = "physical_attribute"
            case political_affiliation = "political_affiliation"
            case religion = "religion"
            case statistics = "statistics"
            case time = "time"
            case url = "url"
            case us_social_security_number = "us_social_security_number"
            case username = "username"
            case vehicle_id = "vehicle_id"
            case zodiac_sign = "zodiac_sign"
        }
        /// The speech model to use for the transcription.
        ///
        /// - Remark: Generated from `#/components/schemas/SpeechModel`.
        @frozen public enum SpeechModel: String, Codable, Hashable, Sendable, CaseIterable {
            case best = "best"
            case slam_hyphen_1 = "slam-1"
            case universal = "universal"
        }
        /// The language of your audio file. Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
        /// The default value is 'en_us'.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptLanguageCode`.
        @frozen public enum TranscriptLanguageCode: String, Codable, Hashable, Sendable, CaseIterable {
            case en = "en"
            case en_au = "en_au"
            case en_uk = "en_uk"
            case en_us = "en_us"
            case es = "es"
            case fr = "fr"
            case de = "de"
            case it = "it"
            case pt = "pt"
            case nl = "nl"
            case af = "af"
            case sq = "sq"
            case am = "am"
            case ar = "ar"
            case hy = "hy"
            case _as = "as"
            case az = "az"
            case ba = "ba"
            case eu = "eu"
            case be = "be"
            case bn = "bn"
            case bs = "bs"
            case br = "br"
            case bg = "bg"
            case my = "my"
            case ca = "ca"
            case zh = "zh"
            case hr = "hr"
            case cs = "cs"
            case da = "da"
            case et = "et"
            case fo = "fo"
            case fi = "fi"
            case gl = "gl"
            case ka = "ka"
            case el = "el"
            case gu = "gu"
            case ht = "ht"
            case ha = "ha"
            case haw = "haw"
            case he = "he"
            case hi = "hi"
            case hu = "hu"
            case _is = "is"
            case id = "id"
            case ja = "ja"
            case jw = "jw"
            case kn = "kn"
            case kk = "kk"
            case km = "km"
            case ko = "ko"
            case lo = "lo"
            case la = "la"
            case lv = "lv"
            case ln = "ln"
            case lt = "lt"
            case lb = "lb"
            case mk = "mk"
            case mg = "mg"
            case ms = "ms"
            case ml = "ml"
            case mt = "mt"
            case mi = "mi"
            case mr = "mr"
            case mn = "mn"
            case ne = "ne"
            case _false = "false"
            case nn = "nn"
            case oc = "oc"
            case pa = "pa"
            case ps = "ps"
            case fa = "fa"
            case pl = "pl"
            case ro = "ro"
            case ru = "ru"
            case sa = "sa"
            case sr = "sr"
            case sn = "sn"
            case sd = "sd"
            case si = "si"
            case sk = "sk"
            case sl = "sl"
            case so = "so"
            case su = "su"
            case sw = "sw"
            case sv = "sv"
            case tl = "tl"
            case tg = "tg"
            case ta = "ta"
            case tt = "tt"
            case te = "te"
            case th = "th"
            case bo = "bo"
            case tr = "tr"
            case tk = "tk"
            case uk = "uk"
            case ur = "ur"
            case uz = "uz"
            case vi = "vi"
            case cy = "cy"
            case yi = "yi"
            case yo = "yo"
        }
        /// The status of your transcript. Possible values are queued, processing, completed, or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptStatus`.
        @frozen public enum TranscriptStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case queued = "queued"
            case processing = "processing"
            case completed = "completed"
            case error = "error"
        }
        /// The status of the transcript. Either completed or error.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptReadyStatus`.
        @frozen public enum TranscriptReadyStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case completed = "completed"
            case error = "error"
        }
        /// A transcript object
        ///
        /// - Remark: Generated from `#/components/schemas/Transcript`.
        public struct Transcript: Codable, Hashable, Sendable {
            /// The unique identifier of your transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/id`.
            public var id: Swift.String
            /// The URL of the media that was transcribed
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_url`.
            public var audio_url: Swift.String
            /// The status of your transcript. Possible values are queued, processing, completed, or error.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/status`.
            public var status: Components.Schemas.TranscriptStatus
            /// The language of your audio file.
            /// Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_code`.
            public struct language_codePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/Transcript/language_code/value1`.
                public var value1: Components.Schemas.TranscriptLanguageCode?
                /// - Remark: Generated from `#/components/schemas/Transcript/language_code/value2`.
                public var value2: Swift.String?
                /// Creates a new `language_codePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.TranscriptLanguageCode? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        self.value1,
                        self.value2
                    ])
                }
            }
            /// The language of your audio file.
            /// Possible values are found in [Supported Languages](https://www.assemblyai.com/docs/concepts/supported-languages).
            /// The default value is 'en_us'.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_code`.
            public var language_code: Components.Schemas.Transcript.language_codePayload?
            /// The language codes of your audio file. Used for [Code switching](/docs/speech-to-text/pre-recorded-audio/code-switching)
            /// One of the values specified must be `en`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_codes`.
            public var language_codes: [Components.Schemas.TranscriptLanguageCode]?
            /// Whether [Automatic language detection](/docs/pre-recorded-audio/automatic-language-detection) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_detection`.
            public var language_detection: Swift.Bool?
            /// Specify options for Automatic Language Detection.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options`.
            public struct language_detection_optionsPayload: Codable, Hashable, Sendable {
                /// List of languages expected in the audio file. Defaults to `["all"]` when unspecified.
                ///
                /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options/expected_languages`.
                public var expected_languages: [Swift.String]?
                /// If the detected language of the audio file is not in the list of expected languages, the `fallback_language` is used. Specify `["auto"]` to let our model choose the fallback language from `expected_languages` with the highest confidence score.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options/fallback_language`.
                public var fallback_language: Swift.String?
                /// Whether code switching should be detected.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options/code_switching`.
                public var code_switching: Swift.Bool?
                /// The confidence threshold for code switching detection. If the code switching confidence is below this threshold, the transcript will be processed in the language with the highest `language_detection_confidence` score.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options/code_switching_confidence_threshold`.
                public var code_switching_confidence_threshold: Swift.Float?
                /// Creates a new `language_detection_optionsPayload`.
                ///
                /// - Parameters:
                ///   - expected_languages: List of languages expected in the audio file. Defaults to `["all"]` when unspecified.
                ///   - fallback_language: If the detected language of the audio file is not in the list of expected languages, the `fallback_language` is used. Specify `["auto"]` to let our model choose the fallback language from `expected_languages` with the highest confidence score.
                ///   - code_switching: Whether code switching should be detected.
                ///   - code_switching_confidence_threshold: The confidence threshold for code switching detection. If the code switching confidence is below this threshold, the transcript will be processed in the language with the highest `language_detection_confidence` score.
                public init(
                    expected_languages: [Swift.String]? = nil,
                    fallback_language: Swift.String? = nil,
                    code_switching: Swift.Bool? = nil,
                    code_switching_confidence_threshold: Swift.Float? = nil
                ) {
                    self.expected_languages = expected_languages
                    self.fallback_language = fallback_language
                    self.code_switching = code_switching
                    self.code_switching_confidence_threshold = code_switching_confidence_threshold
                }
                public enum CodingKeys: String, CodingKey {
                    case expected_languages
                    case fallback_language
                    case code_switching
                    case code_switching_confidence_threshold
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.expected_languages = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .expected_languages
                    )
                    self.fallback_language = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .fallback_language
                    )
                    self.code_switching = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .code_switching
                    )
                    self.code_switching_confidence_threshold = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .code_switching_confidence_threshold
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "expected_languages",
                        "fallback_language",
                        "code_switching",
                        "code_switching_confidence_threshold"
                    ])
                }
            }
            /// Specify options for Automatic Language Detection.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_detection_options`.
            public var language_detection_options: Components.Schemas.Transcript.language_detection_optionsPayload?
            /// The confidence threshold for the automatically detected language.
            /// An error will be returned if the language confidence is below this threshold.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_confidence_threshold`.
            public var language_confidence_threshold: Swift.Float?
            /// The confidence score for the detected language, between 0.0 (low confidence) and 1.0 (high confidence)
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_confidence`.
            public var language_confidence: Swift.Double?
            /// The speech model used for the transcription. When `null`, the `universal` model is used.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_model`.
            @available(*, deprecated)
            public var speech_model: Components.Schemas.SpeechModel?
            /// List multiple speech models in priority order, allowing our system to automatically route your audio to the best available option.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_models`.
            public var speech_models: [Components.Schemas.SpeechModel]?
            /// The speech model that was actually used for the transcription.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_model_used`.
            public var speech_model_used: Components.Schemas.SpeechModel?
            /// The textual transcript of your media file
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/text`.
            public var text: Swift.String?
            /// An array of temporally-sequential word objects, one for each word in the transcript.
            /// See [Speech recognition](https://www.assemblyai.com/docs/models/speech-recognition) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/words`.
            public var words: [Components.Schemas.TranscriptWord]?
            /// When multichannel or speaker_labels is enabled, a list of turn-by-turn utterance objects.
            /// See [Speaker diarization](https://www.assemblyai.com/docs/speech-to-text/speaker-diarization) and [Multichannel transcription](https://www.assemblyai.com/docs/speech-to-text/speech-recognition#multichannel-transcription) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/utterances`.
            public var utterances: [Components.Schemas.TranscriptUtterance]?
            /// The confidence score for the transcript, between 0.0 (low confidence) and 1.0 (high confidence)
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/confidence`.
            public var confidence: Swift.Double?
            /// The duration of this transcript object's media file, in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_duration`.
            public var audio_duration: Swift.Int?
            /// Whether Automatic Punctuation is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/punctuate`.
            public var punctuate: Swift.Bool?
            /// Whether Text Formatting is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/format_text`.
            public var format_text: Swift.Bool?
            /// Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/disfluencies`.
            public var disfluencies: Swift.Bool?
            /// Whether [Multichannel transcription](https://www.assemblyai.com/docs/models/speech-recognition#multichannel-transcription) was enabled in the transcription request, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/multichannel`.
            public var multichannel: Swift.Bool?
            /// The number of audio channels in the audio file. This is only present when multichannel is enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_channels`.
            public var audio_channels: Swift.Int?
            /// The URL to which we send webhook requests.
            /// We sends two different types of webhook requests.
            /// One request when a transcript is completed or failed, and one request when the redacted audio is ready if redact_pii_audio is enabled.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_url`.
            public var webhook_url: Swift.String?
            /// The status code we received from your server when delivering the transcript completed or failed webhook request, if a webhook URL was provided
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_status_code`.
            public var webhook_status_code: Swift.Int?
            /// Whether webhook authentication details were provided
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_auth`.
            public var webhook_auth: Swift.Bool
            /// The header name to be sent with the transcript completed or failed webhook requests
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/webhook_auth_header_name`.
            public var webhook_auth_header_name: Swift.String?
            /// Whether speed boost is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speed_boost`.
            @available(*, deprecated)
            public var speed_boost: Swift.Bool?
            /// Whether Key Phrases is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_highlights`.
            public var auto_highlights: Swift.Bool
            /// An array of results for the Key Phrases model, if it is enabled.
            /// See [Key Phrases](https://www.assemblyai.com/docs/models/key-phrases) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_highlights_result`.
            public var auto_highlights_result: Components.Schemas.AutoHighlightsResult?
            /// The point in time, in milliseconds, in the file at which the transcription was started
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_start_from`.
            public var audio_start_from: Swift.Int?
            /// The point in time, in milliseconds, in the file at which the transcription was terminated
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/audio_end_at`.
            public var audio_end_at: Swift.Int?
            /// Whether [Profanity Filtering](https://www.assemblyai.com/docs/models/speech-recognition#profanity-filtering) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/filter_profanity`.
            public var filter_profanity: Swift.Bool?
            /// Whether [PII Redaction](https://www.assemblyai.com/docs/models/pii-redaction) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii`.
            public var redact_pii: Swift.Bool
            /// Whether a redacted version of the audio file was generated,
            /// either true or false. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_audio`.
            public var redact_pii_audio: Swift.Bool?
            /// The audio quality of the PII-redacted audio file, if redact_pii_audio is enabled.
            /// See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_audio_quality`.
            public var redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality?
            /// The list of PII Redaction policies that were enabled, if PII Redaction is enabled.
            /// See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_policies`.
            public var redact_pii_policies: [Components.Schemas.PiiPolicy]?
            /// The replacement logic for detected PII, can be `entity_type` or `hash`. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/redact_pii_sub`.
            public var redact_pii_sub: Components.Schemas.SubstitutionPolicy?
            /// Whether [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speaker_labels`.
            public var speaker_labels: Swift.Bool?
            /// Tell the speaker label model how many speakers it should attempt to identify. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speakers_expected`.
            public var speakers_expected: Swift.Int?
            /// Whether [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/content_safety`.
            public var content_safety: Swift.Bool?
            /// An array of results for the Content Moderation model, if it is enabled.
            /// See [Content moderation](https://www.assemblyai.com/docs/models/content-moderation) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/content_safety_labels`.
            public var content_safety_labels: Components.Schemas.ContentSafetyLabelsResult?
            /// Whether [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/iab_categories`.
            public var iab_categories: Swift.Bool?
            /// The result of the Topic Detection model, if it is enabled.
            /// See [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/iab_categories_result`.
            public var iab_categories_result: Components.Schemas.TopicDetectionModelResult?
            /// Customize how words are spelled and formatted using to and from values
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/custom_spelling`.
            public var custom_spelling: [Components.Schemas.TranscriptCustomSpelling]?
            /// Improve accuracy with up to 200 (for Universal) or 1000 (for Slam-1) domain-specific words or phrases (maximum 6 words per phrase).
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/keyterms_prompt`.
            public var keyterms_prompt: [Swift.String]?
            /// This parameter does not currently have any functionality attached to it.
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/prompt`.
            @available(*, deprecated)
            public var prompt: Swift.String?
            /// Whether [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/auto_chapters`.
            public var auto_chapters: Swift.Bool?
            /// An array of temporally sequential chapters for the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/chapters`.
            public var chapters: [Components.Schemas.Chapter]?
            /// Whether [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summarization`.
            public var summarization: Swift.Bool
            /// The type of summary generated, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary_type`.
            public var summary_type: Swift.String?
            /// The Summarization model used to generate the summary,
            /// if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary_model`.
            public var summary_model: Swift.String?
            /// The generated summary of the media file, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/summary`.
            public var summary: Swift.String?
            /// Whether custom topics is enabled, either true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/custom_topics`.
            @available(*, deprecated)
            public var custom_topics: Swift.Bool?
            /// The list of custom topics provided if custom topics is enabled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/topics`.
            @available(*, deprecated)
            public var topics: [Swift.String]?
            /// Whether [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/sentiment_analysis`.
            public var sentiment_analysis: Swift.Bool?
            /// An array of results for the Sentiment Analysis model, if it is enabled.
            /// See [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/sentiment_analysis_results`.
            public var sentiment_analysis_results: [Components.Schemas.SentimentAnalysisResult]?
            /// Whether [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection) is enabled, can be true or false
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/entity_detection`.
            public var entity_detection: Swift.Bool?
            /// An array of results for the Entity Detection model, if it is enabled.
            /// See [Entity detection](https://www.assemblyai.com/docs/models/entity-detection) for more information.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/entities`.
            public var entities: [Components.Schemas.Entity]?
            /// Defaults to null. Reject audio files that contain less than this fraction of speech.
            /// Valid values are in the range [0, 1] inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_threshold`.
            public var speech_threshold: Swift.Float?
            /// True while a request is throttled and false when a request is no longer throttled
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/throttled`.
            public var throttled: Swift.Bool?
            /// Error message of why the transcript failed
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/error`.
            public var error: Swift.String?
            /// The language model that was used for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/language_model`.
            @available(*, deprecated)
            public var language_model: Swift.String?
            /// The acoustic model that was used for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/acoustic_model`.
            @available(*, deprecated)
            public var acoustic_model: Swift.String?
            /// Enable speech understanding tasks like translation, speaker identification, and custom formatting
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding`.
            public struct speech_understandingPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/request`.
                @frozen public enum requestPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/request/case1`.
                    case TranslationRequestBody(Components.Schemas.TranslationRequestBody)
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/request/case2`.
                    case SpeakerIdentificationRequestBody(Components.Schemas.SpeakerIdentificationRequestBody)
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/request/case3`.
                    case CustomFormattingRequestBody(Components.Schemas.CustomFormattingRequestBody)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .TranslationRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .SpeakerIdentificationRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .CustomFormattingRequestBody(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .TranslationRequestBody(value):
                            try value.encode(to: encoder)
                        case let .SpeakerIdentificationRequestBody(value):
                            try value.encode(to: encoder)
                        case let .CustomFormattingRequestBody(value):
                            try value.encode(to: encoder)
                        }
                    }
                }
                /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/request`.
                public var request: Components.Schemas.Transcript.speech_understandingPayload.requestPayload
                /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/response`.
                @frozen public enum responsePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/response/case1`.
                    case TranslationResponse(Components.Schemas.TranslationResponse)
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/response/case2`.
                    case SpeakerIdentificationResponse(Components.Schemas.SpeakerIdentificationResponse)
                    /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/response/case3`.
                    case CustomFormattingResponse(Components.Schemas.CustomFormattingResponse)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .TranslationResponse(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .SpeakerIdentificationResponse(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .CustomFormattingResponse(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .TranslationResponse(value):
                            try value.encode(to: encoder)
                        case let .SpeakerIdentificationResponse(value):
                            try value.encode(to: encoder)
                        case let .CustomFormattingResponse(value):
                            try value.encode(to: encoder)
                        }
                    }
                }
                /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding/response`.
                public var response: Components.Schemas.Transcript.speech_understandingPayload.responsePayload?
                /// Creates a new `speech_understandingPayload`.
                ///
                /// - Parameters:
                ///   - request:
                ///   - response:
                public init(
                    request: Components.Schemas.Transcript.speech_understandingPayload.requestPayload,
                    response: Components.Schemas.Transcript.speech_understandingPayload.responsePayload? = nil
                ) {
                    self.request = request
                    self.response = response
                }
                public enum CodingKeys: String, CodingKey {
                    case request
                    case response
                }
            }
            /// Enable speech understanding tasks like translation, speaker identification, and custom formatting
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/speech_understanding`.
            public var speech_understanding: Components.Schemas.Transcript.speech_understandingPayload?
            /// Translated text keyed by language code
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/translated_texts`.
            public struct translated_textsPayload: Codable, Hashable, Sendable {
                /// Translated text for this language code
                ///
                /// - Remark: Generated from `#/components/schemas/Transcript/translated_texts/language_code`.
                public var language_code: Swift.String?
                /// Creates a new `translated_textsPayload`.
                ///
                /// - Parameters:
                ///   - language_code: Translated text for this language code
                public init(language_code: Swift.String? = nil) {
                    self.language_code = language_code
                }
                public enum CodingKeys: String, CodingKey {
                    case language_code
                }
            }
            /// Translated text keyed by language code
            ///
            /// - Remark: Generated from `#/components/schemas/Transcript/translated_texts`.
            public var translated_texts: Components.Schemas.Transcript.translated_textsPayload?
            /// A container of undocumented properties.
            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
            /// Creates a new `Transcript`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of your transcript
            ///   - audio_url: The URL of the media that was transcribed
            ///   - status: The status of your transcript. Possible values are queued, processing, completed, or error.
            ///   - language_code: The language of your audio file.
            ///   - language_codes: The language codes of your audio file. Used for [Code switching](/docs/speech-to-text/pre-recorded-audio/code-switching)
            ///   - language_detection: Whether [Automatic language detection](/docs/pre-recorded-audio/automatic-language-detection) is enabled, either true or false
            ///   - language_detection_options: Specify options for Automatic Language Detection.
            ///   - language_confidence_threshold: The confidence threshold for the automatically detected language.
            ///   - language_confidence: The confidence score for the detected language, between 0.0 (low confidence) and 1.0 (high confidence)
            ///   - speech_model: The speech model used for the transcription. When `null`, the `universal` model is used.
            ///   - speech_models: List multiple speech models in priority order, allowing our system to automatically route your audio to the best available option.
            ///   - speech_model_used: The speech model that was actually used for the transcription.
            ///   - text: The textual transcript of your media file
            ///   - words: An array of temporally-sequential word objects, one for each word in the transcript.
            ///   - utterances: When multichannel or speaker_labels is enabled, a list of turn-by-turn utterance objects.
            ///   - confidence: The confidence score for the transcript, between 0.0 (low confidence) and 1.0 (high confidence)
            ///   - audio_duration: The duration of this transcript object's media file, in seconds
            ///   - punctuate: Whether Automatic Punctuation is enabled, either true or false
            ///   - format_text: Whether Text Formatting is enabled, either true or false
            ///   - disfluencies: Transcribe Filler Words, like "umm", in your media file; can be true or false
            ///   - multichannel: Whether [Multichannel transcription](https://www.assemblyai.com/docs/models/speech-recognition#multichannel-transcription) was enabled in the transcription request, either true or false
            ///   - audio_channels: The number of audio channels in the audio file. This is only present when multichannel is enabled.
            ///   - webhook_url: The URL to which we send webhook requests.
            ///   - webhook_status_code: The status code we received from your server when delivering the transcript completed or failed webhook request, if a webhook URL was provided
            ///   - webhook_auth: Whether webhook authentication details were provided
            ///   - webhook_auth_header_name: The header name to be sent with the transcript completed or failed webhook requests
            ///   - speed_boost: Whether speed boost is enabled
            ///   - auto_highlights: Whether Key Phrases is enabled, either true or false
            ///   - auto_highlights_result: An array of results for the Key Phrases model, if it is enabled.
            ///   - audio_start_from: The point in time, in milliseconds, in the file at which the transcription was started
            ///   - audio_end_at: The point in time, in milliseconds, in the file at which the transcription was terminated
            ///   - filter_profanity: Whether [Profanity Filtering](https://www.assemblyai.com/docs/models/speech-recognition#profanity-filtering) is enabled, either true or false
            ///   - redact_pii: Whether [PII Redaction](https://www.assemblyai.com/docs/models/pii-redaction) is enabled, either true or false
            ///   - redact_pii_audio: Whether a redacted version of the audio file was generated,
            ///   - redact_pii_audio_quality: The audio quality of the PII-redacted audio file, if redact_pii_audio is enabled.
            ///   - redact_pii_policies: The list of PII Redaction policies that were enabled, if PII Redaction is enabled.
            ///   - redact_pii_sub: The replacement logic for detected PII, can be `entity_type` or `hash`. See [PII redaction](https://www.assemblyai.com/docs/models/pii-redaction) for more details.
            ///   - speaker_labels: Whether [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, can be true or false
            ///   - speakers_expected: Tell the speaker label model how many speakers it should attempt to identify. See [Speaker diarization](https://www.assemblyai.com/docs/models/speaker-diarization) for more details.
            ///   - content_safety: Whether [Content Moderation](https://www.assemblyai.com/docs/models/content-moderation) is enabled, can be true or false
            ///   - content_safety_labels: An array of results for the Content Moderation model, if it is enabled.
            ///   - iab_categories: Whether [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) is enabled, can be true or false
            ///   - iab_categories_result: The result of the Topic Detection model, if it is enabled.
            ///   - custom_spelling: Customize how words are spelled and formatted using to and from values
            ///   - keyterms_prompt: Improve accuracy with up to 200 (for Universal) or 1000 (for Slam-1) domain-specific words or phrases (maximum 6 words per phrase).
            ///   - prompt: This parameter does not currently have any functionality attached to it.
            ///   - auto_chapters: Whether [Auto Chapters](https://www.assemblyai.com/docs/models/auto-chapters) is enabled, can be true or false
            ///   - chapters: An array of temporally sequential chapters for the audio file
            ///   - summarization: Whether [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled, either true or false
            ///   - summary_type: The type of summary generated, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///   - summary_model: The Summarization model used to generate the summary,
            ///   - summary: The generated summary of the media file, if [Summarization](https://www.assemblyai.com/docs/models/summarization) is enabled
            ///   - custom_topics: Whether custom topics is enabled, either true or false
            ///   - topics: The list of custom topics provided if custom topics is enabled
            ///   - sentiment_analysis: Whether [Sentiment Analysis](https://www.assemblyai.com/docs/models/sentiment-analysis) is enabled, can be true or false
            ///   - sentiment_analysis_results: An array of results for the Sentiment Analysis model, if it is enabled.
            ///   - entity_detection: Whether [Entity Detection](https://www.assemblyai.com/docs/models/entity-detection) is enabled, can be true or false
            ///   - entities: An array of results for the Entity Detection model, if it is enabled.
            ///   - speech_threshold: Defaults to null. Reject audio files that contain less than this fraction of speech.
            ///   - throttled: True while a request is throttled and false when a request is no longer throttled
            ///   - error: Error message of why the transcript failed
            ///   - language_model: The language model that was used for the transcript
            ///   - acoustic_model: The acoustic model that was used for the transcript
            ///   - speech_understanding: Enable speech understanding tasks like translation, speaker identification, and custom formatting
            ///   - translated_texts: Translated text keyed by language code
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                id: Swift.String,
                audio_url: Swift.String,
                status: Components.Schemas.TranscriptStatus,
                language_code: Components.Schemas.Transcript.language_codePayload? = nil,
                language_codes: [Components.Schemas.TranscriptLanguageCode]? = nil,
                language_detection: Swift.Bool? = nil,
                language_detection_options: Components.Schemas.Transcript.language_detection_optionsPayload? = nil,
                language_confidence_threshold: Swift.Float? = nil,
                language_confidence: Swift.Double? = nil,
                speech_model: Components.Schemas.SpeechModel? = nil,
                speech_models: [Components.Schemas.SpeechModel]? = nil,
                speech_model_used: Components.Schemas.SpeechModel? = nil,
                text: Swift.String? = nil,
                words: [Components.Schemas.TranscriptWord]? = nil,
                utterances: [Components.Schemas.TranscriptUtterance]? = nil,
                confidence: Swift.Double? = nil,
                audio_duration: Swift.Int? = nil,
                punctuate: Swift.Bool? = nil,
                format_text: Swift.Bool? = nil,
                disfluencies: Swift.Bool? = nil,
                multichannel: Swift.Bool? = nil,
                audio_channels: Swift.Int? = nil,
                webhook_url: Swift.String? = nil,
                webhook_status_code: Swift.Int? = nil,
                webhook_auth: Swift.Bool,
                webhook_auth_header_name: Swift.String? = nil,
                speed_boost: Swift.Bool? = nil,
                auto_highlights: Swift.Bool,
                auto_highlights_result: Components.Schemas.AutoHighlightsResult? = nil,
                audio_start_from: Swift.Int? = nil,
                audio_end_at: Swift.Int? = nil,
                filter_profanity: Swift.Bool? = nil,
                redact_pii: Swift.Bool,
                redact_pii_audio: Swift.Bool? = nil,
                redact_pii_audio_quality: Components.Schemas.RedactPiiAudioQuality? = nil,
                redact_pii_policies: [Components.Schemas.PiiPolicy]? = nil,
                redact_pii_sub: Components.Schemas.SubstitutionPolicy? = nil,
                speaker_labels: Swift.Bool? = nil,
                speakers_expected: Swift.Int? = nil,
                content_safety: Swift.Bool? = nil,
                content_safety_labels: Components.Schemas.ContentSafetyLabelsResult? = nil,
                iab_categories: Swift.Bool? = nil,
                iab_categories_result: Components.Schemas.TopicDetectionModelResult? = nil,
                custom_spelling: [Components.Schemas.TranscriptCustomSpelling]? = nil,
                keyterms_prompt: [Swift.String]? = nil,
                prompt: Swift.String? = nil,
                auto_chapters: Swift.Bool? = nil,
                chapters: [Components.Schemas.Chapter]? = nil,
                summarization: Swift.Bool,
                summary_type: Swift.String? = nil,
                summary_model: Swift.String? = nil,
                summary: Swift.String? = nil,
                custom_topics: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                sentiment_analysis: Swift.Bool? = nil,
                sentiment_analysis_results: [Components.Schemas.SentimentAnalysisResult]? = nil,
                entity_detection: Swift.Bool? = nil,
                entities: [Components.Schemas.Entity]? = nil,
                speech_threshold: Swift.Float? = nil,
                throttled: Swift.Bool? = nil,
                error: Swift.String? = nil,
                language_model: Swift.String? = nil,
                acoustic_model: Swift.String? = nil,
                speech_understanding: Components.Schemas.Transcript.speech_understandingPayload? = nil,
                translated_texts: Components.Schemas.Transcript.translated_textsPayload? = nil,
                additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()
            ) {
                self.id = id
                self.audio_url = audio_url
                self.status = status
                self.language_code = language_code
                self.language_codes = language_codes
                self.language_detection = language_detection
                self.language_detection_options = language_detection_options
                self.language_confidence_threshold = language_confidence_threshold
                self.language_confidence = language_confidence
                self.speech_model = speech_model
                self.speech_models = speech_models
                self.speech_model_used = speech_model_used
                self.text = text
                self.words = words
                self.utterances = utterances
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.punctuate = punctuate
                self.format_text = format_text
                self.disfluencies = disfluencies
                self.multichannel = multichannel
                self.audio_channels = audio_channels
                self.webhook_url = webhook_url
                self.webhook_status_code = webhook_status_code
                self.webhook_auth = webhook_auth
                self.webhook_auth_header_name = webhook_auth_header_name
                self.speed_boost = speed_boost
                self.auto_highlights = auto_highlights
                self.auto_highlights_result = auto_highlights_result
                self.audio_start_from = audio_start_from
                self.audio_end_at = audio_end_at
                self.filter_profanity = filter_profanity
                self.redact_pii = redact_pii
                self.redact_pii_audio = redact_pii_audio
                self.redact_pii_audio_quality = redact_pii_audio_quality
                self.redact_pii_policies = redact_pii_policies
                self.redact_pii_sub = redact_pii_sub
                self.speaker_labels = speaker_labels
                self.speakers_expected = speakers_expected
                self.content_safety = content_safety
                self.content_safety_labels = content_safety_labels
                self.iab_categories = iab_categories
                self.iab_categories_result = iab_categories_result
                self.custom_spelling = custom_spelling
                self.keyterms_prompt = keyterms_prompt
                self.prompt = prompt
                self.auto_chapters = auto_chapters
                self.chapters = chapters
                self.summarization = summarization
                self.summary_type = summary_type
                self.summary_model = summary_model
                self.summary = summary
                self.custom_topics = custom_topics
                self.topics = topics
                self.sentiment_analysis = sentiment_analysis
                self.sentiment_analysis_results = sentiment_analysis_results
                self.entity_detection = entity_detection
                self.entities = entities
                self.speech_threshold = speech_threshold
                self.throttled = throttled
                self.error = error
                self.language_model = language_model
                self.acoustic_model = acoustic_model
                self.speech_understanding = speech_understanding
                self.translated_texts = translated_texts
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case audio_url
                case status
                case language_code
                case language_codes
                case language_detection
                case language_detection_options
                case language_confidence_threshold
                case language_confidence
                case speech_model
                case speech_models
                case speech_model_used
                case text
                case words
                case utterances
                case confidence
                case audio_duration
                case punctuate
                case format_text
                case disfluencies
                case multichannel
                case audio_channels
                case webhook_url
                case webhook_status_code
                case webhook_auth
                case webhook_auth_header_name
                case speed_boost
                case auto_highlights
                case auto_highlights_result
                case audio_start_from
                case audio_end_at
                case filter_profanity
                case redact_pii
                case redact_pii_audio
                case redact_pii_audio_quality
                case redact_pii_policies
                case redact_pii_sub
                case speaker_labels
                case speakers_expected
                case content_safety
                case content_safety_labels
                case iab_categories
                case iab_categories_result
                case custom_spelling
                case keyterms_prompt
                case prompt
                case auto_chapters
                case chapters
                case summarization
                case summary_type
                case summary_model
                case summary
                case custom_topics
                case topics
                case sentiment_analysis
                case sentiment_analysis_results
                case entity_detection
                case entities
                case speech_threshold
                case throttled
                case error
                case language_model
                case acoustic_model
                case speech_understanding
                case translated_texts
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                self.audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .audio_url
                )
                self.status = try container.decode(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                self.language_code = try container.decodeIfPresent(
                    Components.Schemas.Transcript.language_codePayload.self,
                    forKey: .language_code
                )
                self.language_codes = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptLanguageCode].self,
                    forKey: .language_codes
                )
                self.language_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .language_detection
                )
                self.language_detection_options = try container.decodeIfPresent(
                    Components.Schemas.Transcript.language_detection_optionsPayload.self,
                    forKey: .language_detection_options
                )
                self.language_confidence_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .language_confidence_threshold
                )
                self.language_confidence = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .language_confidence
                )
                self.speech_model = try container.decodeIfPresent(
                    Components.Schemas.SpeechModel.self,
                    forKey: .speech_model
                )
                self.speech_models = try container.decodeIfPresent(
                    [Components.Schemas.SpeechModel].self,
                    forKey: .speech_models
                )
                self.speech_model_used = try container.decodeIfPresent(
                    Components.Schemas.SpeechModel.self,
                    forKey: .speech_model_used
                )
                self.text = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .text
                )
                self.words = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                self.utterances = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptUtterance].self,
                    forKey: .utterances
                )
                self.confidence = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.audio_duration = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_duration
                )
                self.punctuate = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .punctuate
                )
                self.format_text = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .format_text
                )
                self.disfluencies = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .disfluencies
                )
                self.multichannel = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .multichannel
                )
                self.audio_channels = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_channels
                )
                self.webhook_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_url
                )
                self.webhook_status_code = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .webhook_status_code
                )
                self.webhook_auth = try container.decode(
                    Swift.Bool.self,
                    forKey: .webhook_auth
                )
                self.webhook_auth_header_name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .webhook_auth_header_name
                )
                self.speed_boost = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speed_boost
                )
                self.auto_highlights = try container.decode(
                    Swift.Bool.self,
                    forKey: .auto_highlights
                )
                self.auto_highlights_result = try container.decodeIfPresent(
                    Components.Schemas.AutoHighlightsResult.self,
                    forKey: .auto_highlights_result
                )
                self.audio_start_from = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_start_from
                )
                self.audio_end_at = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .audio_end_at
                )
                self.filter_profanity = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .filter_profanity
                )
                self.redact_pii = try container.decode(
                    Swift.Bool.self,
                    forKey: .redact_pii
                )
                self.redact_pii_audio = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .redact_pii_audio
                )
                self.redact_pii_audio_quality = try container.decodeIfPresent(
                    Components.Schemas.RedactPiiAudioQuality.self,
                    forKey: .redact_pii_audio_quality
                )
                self.redact_pii_policies = try container.decodeIfPresent(
                    [Components.Schemas.PiiPolicy].self,
                    forKey: .redact_pii_policies
                )
                self.redact_pii_sub = try container.decodeIfPresent(
                    Components.Schemas.SubstitutionPolicy.self,
                    forKey: .redact_pii_sub
                )
                self.speaker_labels = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .speaker_labels
                )
                self.speakers_expected = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .speakers_expected
                )
                self.content_safety = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .content_safety
                )
                self.content_safety_labels = try container.decodeIfPresent(
                    Components.Schemas.ContentSafetyLabelsResult.self,
                    forKey: .content_safety_labels
                )
                self.iab_categories = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .iab_categories
                )
                self.iab_categories_result = try container.decodeIfPresent(
                    Components.Schemas.TopicDetectionModelResult.self,
                    forKey: .iab_categories_result
                )
                self.custom_spelling = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptCustomSpelling].self,
                    forKey: .custom_spelling
                )
                self.keyterms_prompt = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .keyterms_prompt
                )
                self.prompt = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .prompt
                )
                self.auto_chapters = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .auto_chapters
                )
                self.chapters = try container.decodeIfPresent(
                    [Components.Schemas.Chapter].self,
                    forKey: .chapters
                )
                self.summarization = try container.decode(
                    Swift.Bool.self,
                    forKey: .summarization
                )
                self.summary_type = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary_type
                )
                self.summary_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary_model
                )
                self.summary = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .summary
                )
                self.custom_topics = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .custom_topics
                )
                self.topics = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .topics
                )
                self.sentiment_analysis = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .sentiment_analysis
                )
                self.sentiment_analysis_results = try container.decodeIfPresent(
                    [Components.Schemas.SentimentAnalysisResult].self,
                    forKey: .sentiment_analysis_results
                )
                self.entity_detection = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .entity_detection
                )
                self.entities = try container.decodeIfPresent(
                    [Components.Schemas.Entity].self,
                    forKey: .entities
                )
                self.speech_threshold = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .speech_threshold
                )
                self.throttled = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .throttled
                )
                self.error = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .error
                )
                self.language_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .language_model
                )
                self.acoustic_model = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .acoustic_model
                )
                self.speech_understanding = try container.decodeIfPresent(
                    Components.Schemas.Transcript.speech_understandingPayload.self,
                    forKey: .speech_understanding
                )
                self.translated_texts = try container.decodeIfPresent(
                    Components.Schemas.Transcript.translated_textsPayload.self,
                    forKey: .translated_texts
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "id",
                    "audio_url",
                    "status",
                    "language_code",
                    "language_codes",
                    "language_detection",
                    "language_detection_options",
                    "language_confidence_threshold",
                    "language_confidence",
                    "speech_model",
                    "speech_models",
                    "speech_model_used",
                    "text",
                    "words",
                    "utterances",
                    "confidence",
                    "audio_duration",
                    "punctuate",
                    "format_text",
                    "disfluencies",
                    "multichannel",
                    "audio_channels",
                    "webhook_url",
                    "webhook_status_code",
                    "webhook_auth",
                    "webhook_auth_header_name",
                    "speed_boost",
                    "auto_highlights",
                    "auto_highlights_result",
                    "audio_start_from",
                    "audio_end_at",
                    "filter_profanity",
                    "redact_pii",
                    "redact_pii_audio",
                    "redact_pii_audio_quality",
                    "redact_pii_policies",
                    "redact_pii_sub",
                    "speaker_labels",
                    "speakers_expected",
                    "content_safety",
                    "content_safety_labels",
                    "iab_categories",
                    "iab_categories_result",
                    "custom_spelling",
                    "keyterms_prompt",
                    "prompt",
                    "auto_chapters",
                    "chapters",
                    "summarization",
                    "summary_type",
                    "summary_model",
                    "summary",
                    "custom_topics",
                    "topics",
                    "sentiment_analysis",
                    "sentiment_analysis_results",
                    "entity_detection",
                    "entities",
                    "speech_threshold",
                    "throttled",
                    "error",
                    "language_model",
                    "acoustic_model",
                    "speech_understanding",
                    "translated_texts"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(
                    self.id,
                    forKey: .id
                )
                try container.encode(
                    self.audio_url,
                    forKey: .audio_url
                )
                try container.encode(
                    self.status,
                    forKey: .status
                )
                try container.encodeIfPresent(
                    self.language_code,
                    forKey: .language_code
                )
                try container.encodeIfPresent(
                    self.language_codes,
                    forKey: .language_codes
                )
                try container.encodeIfPresent(
                    self.language_detection,
                    forKey: .language_detection
                )
                try container.encodeIfPresent(
                    self.language_detection_options,
                    forKey: .language_detection_options
                )
                try container.encodeIfPresent(
                    self.language_confidence_threshold,
                    forKey: .language_confidence_threshold
                )
                try container.encodeIfPresent(
                    self.language_confidence,
                    forKey: .language_confidence
                )
                try container.encodeIfPresent(
                    self.speech_model,
                    forKey: .speech_model
                )
                try container.encodeIfPresent(
                    self.speech_models,
                    forKey: .speech_models
                )
                try container.encodeIfPresent(
                    self.speech_model_used,
                    forKey: .speech_model_used
                )
                try container.encodeIfPresent(
                    self.text,
                    forKey: .text
                )
                try container.encodeIfPresent(
                    self.words,
                    forKey: .words
                )
                try container.encodeIfPresent(
                    self.utterances,
                    forKey: .utterances
                )
                try container.encodeIfPresent(
                    self.confidence,
                    forKey: .confidence
                )
                try container.encodeIfPresent(
                    self.audio_duration,
                    forKey: .audio_duration
                )
                try container.encodeIfPresent(
                    self.punctuate,
                    forKey: .punctuate
                )
                try container.encodeIfPresent(
                    self.format_text,
                    forKey: .format_text
                )
                try container.encodeIfPresent(
                    self.disfluencies,
                    forKey: .disfluencies
                )
                try container.encodeIfPresent(
                    self.multichannel,
                    forKey: .multichannel
                )
                try container.encodeIfPresent(
                    self.audio_channels,
                    forKey: .audio_channels
                )
                try container.encodeIfPresent(
                    self.webhook_url,
                    forKey: .webhook_url
                )
                try container.encodeIfPresent(
                    self.webhook_status_code,
                    forKey: .webhook_status_code
                )
                try container.encode(
                    self.webhook_auth,
                    forKey: .webhook_auth
                )
                try container.encodeIfPresent(
                    self.webhook_auth_header_name,
                    forKey: .webhook_auth_header_name
                )
                try container.encodeIfPresent(
                    self.speed_boost,
                    forKey: .speed_boost
                )
                try container.encode(
                    self.auto_highlights,
                    forKey: .auto_highlights
                )
                try container.encodeIfPresent(
                    self.auto_highlights_result,
                    forKey: .auto_highlights_result
                )
                try container.encodeIfPresent(
                    self.audio_start_from,
                    forKey: .audio_start_from
                )
                try container.encodeIfPresent(
                    self.audio_end_at,
                    forKey: .audio_end_at
                )
                try container.encodeIfPresent(
                    self.filter_profanity,
                    forKey: .filter_profanity
                )
                try container.encode(
                    self.redact_pii,
                    forKey: .redact_pii
                )
                try container.encodeIfPresent(
                    self.redact_pii_audio,
                    forKey: .redact_pii_audio
                )
                try container.encodeIfPresent(
                    self.redact_pii_audio_quality,
                    forKey: .redact_pii_audio_quality
                )
                try container.encodeIfPresent(
                    self.redact_pii_policies,
                    forKey: .redact_pii_policies
                )
                try container.encodeIfPresent(
                    self.redact_pii_sub,
                    forKey: .redact_pii_sub
                )
                try container.encodeIfPresent(
                    self.speaker_labels,
                    forKey: .speaker_labels
                )
                try container.encodeIfPresent(
                    self.speakers_expected,
                    forKey: .speakers_expected
                )
                try container.encodeIfPresent(
                    self.content_safety,
                    forKey: .content_safety
                )
                try container.encodeIfPresent(
                    self.content_safety_labels,
                    forKey: .content_safety_labels
                )
                try container.encodeIfPresent(
                    self.iab_categories,
                    forKey: .iab_categories
                )
                try container.encodeIfPresent(
                    self.iab_categories_result,
                    forKey: .iab_categories_result
                )
                try container.encodeIfPresent(
                    self.custom_spelling,
                    forKey: .custom_spelling
                )
                try container.encodeIfPresent(
                    self.keyterms_prompt,
                    forKey: .keyterms_prompt
                )
                try container.encodeIfPresent(
                    self.prompt,
                    forKey: .prompt
                )
                try container.encodeIfPresent(
                    self.auto_chapters,
                    forKey: .auto_chapters
                )
                try container.encodeIfPresent(
                    self.chapters,
                    forKey: .chapters
                )
                try container.encode(
                    self.summarization,
                    forKey: .summarization
                )
                try container.encodeIfPresent(
                    self.summary_type,
                    forKey: .summary_type
                )
                try container.encodeIfPresent(
                    self.summary_model,
                    forKey: .summary_model
                )
                try container.encodeIfPresent(
                    self.summary,
                    forKey: .summary
                )
                try container.encodeIfPresent(
                    self.custom_topics,
                    forKey: .custom_topics
                )
                try container.encodeIfPresent(
                    self.topics,
                    forKey: .topics
                )
                try container.encodeIfPresent(
                    self.sentiment_analysis,
                    forKey: .sentiment_analysis
                )
                try container.encodeIfPresent(
                    self.sentiment_analysis_results,
                    forKey: .sentiment_analysis_results
                )
                try container.encodeIfPresent(
                    self.entity_detection,
                    forKey: .entity_detection
                )
                try container.encodeIfPresent(
                    self.entities,
                    forKey: .entities
                )
                try container.encodeIfPresent(
                    self.speech_threshold,
                    forKey: .speech_threshold
                )
                try container.encodeIfPresent(
                    self.throttled,
                    forKey: .throttled
                )
                try container.encodeIfPresent(
                    self.error,
                    forKey: .error
                )
                try container.encodeIfPresent(
                    self.language_model,
                    forKey: .language_model
                )
                try container.encodeIfPresent(
                    self.acoustic_model,
                    forKey: .acoustic_model
                )
                try container.encodeIfPresent(
                    self.speech_understanding,
                    forKey: .speech_understanding
                )
                try container.encodeIfPresent(
                    self.translated_texts,
                    forKey: .translated_texts
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// The result of the Topic Detection model, if it is enabled.
        /// See [Topic Detection](https://www.assemblyai.com/docs/models/topic-detection) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult`.
        public struct TopicDetectionModelResult: Codable, Hashable, Sendable {
            /// The status of the Topic Detection model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus?
            /// An array of results for the Topic Detection model
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/results`.
            public var results: [Components.Schemas.TopicDetectionResult]?
            /// The overall relevance of topic to the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/summary`.
            public struct summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.Double]
                /// Creates a new `summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.Double] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// The overall relevance of topic to the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionModelResult/summary`.
            public var summary: Components.Schemas.TopicDetectionModelResult.summaryPayload?
            /// Creates a new `TopicDetectionModelResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Topic Detection model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: An array of results for the Topic Detection model
            ///   - summary: The overall relevance of topic to the entire audio file
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus? = nil,
                results: [Components.Schemas.TopicDetectionResult]? = nil,
                summary: Components.Schemas.TopicDetectionModelResult.summaryPayload? = nil
            ) {
                self.status = status
                self.results = results
                self.summary = summary
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
                case summary
            }
        }
        /// An array of results for the Content Moderation model, if it is enabled.
        /// See [Content moderation](https://www.assemblyai.com/docs/models/content-moderation) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult`.
        public struct ContentSafetyLabelsResult: Codable, Hashable, Sendable {
            /// The status of the Content Moderation model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus?
            /// An array of results for the Content Moderation model
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/results`.
            public var results: [Components.Schemas.ContentSafetyLabelResult]?
            /// A summary of the Content Moderation confidence results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/summary`.
            public struct summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.Double]
                /// Creates a new `summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.Double] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A summary of the Content Moderation confidence results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/summary`.
            public var summary: Components.Schemas.ContentSafetyLabelsResult.summaryPayload?
            /// A summary of the Content Moderation severity results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/severity_score_summary`.
            public struct severity_score_summaryPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.SeverityScoreSummary]
                /// Creates a new `severity_score_summaryPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.SeverityScoreSummary] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A summary of the Content Moderation severity results for the entire audio file
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelsResult/severity_score_summary`.
            public var severity_score_summary: Components.Schemas.ContentSafetyLabelsResult.severity_score_summaryPayload?
            /// Creates a new `ContentSafetyLabelsResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Content Moderation model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: An array of results for the Content Moderation model
            ///   - summary: A summary of the Content Moderation confidence results for the entire audio file
            ///   - severity_score_summary: A summary of the Content Moderation severity results for the entire audio file
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus? = nil,
                results: [Components.Schemas.ContentSafetyLabelResult]? = nil,
                summary: Components.Schemas.ContentSafetyLabelsResult.summaryPayload? = nil,
                severity_score_summary: Components.Schemas.ContentSafetyLabelsResult.severity_score_summaryPayload? = nil
            ) {
                self.status = status
                self.results = results
                self.summary = summary
                self.severity_score_summary = severity_score_summary
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
                case summary
                case severity_score_summary
            }
        }
        /// Chapter of the audio file
        ///
        /// - Remark: Generated from `#/components/schemas/Chapter`.
        public struct Chapter: Codable, Hashable, Sendable {
            /// An ultra-short summary (just a few words) of the content spoken in the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/gist`.
            public var gist: Swift.String
            /// A single sentence summary of the content spoken during the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/headline`.
            public var headline: Swift.String
            /// A one paragraph summary of the content spoken during the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/summary`.
            public var summary: Swift.String
            /// The starting time, in milliseconds, for the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/start`.
            public var start: Swift.Int
            /// The starting time, in milliseconds, for the chapter
            ///
            /// - Remark: Generated from `#/components/schemas/Chapter/end`.
            public var end: Swift.Int
            /// Creates a new `Chapter`.
            ///
            /// - Parameters:
            ///   - gist: An ultra-short summary (just a few words) of the content spoken in the chapter
            ///   - headline: A single sentence summary of the content spoken during the chapter
            ///   - summary: A one paragraph summary of the content spoken during the chapter
            ///   - start: The starting time, in milliseconds, for the chapter
            ///   - end: The starting time, in milliseconds, for the chapter
            public init(
                gist: Swift.String,
                headline: Swift.String,
                summary: Swift.String,
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.gist = gist
                self.headline = headline
                self.summary = summary
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case gist
                case headline
                case summary
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.gist = try container.decode(
                    Swift.String.self,
                    forKey: .gist
                )
                self.headline = try container.decode(
                    Swift.String.self,
                    forKey: .headline
                )
                self.summary = try container.decode(
                    Swift.String.self,
                    forKey: .summary
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "gist",
                    "headline",
                    "summary",
                    "start",
                    "end"
                ])
            }
        }
        /// A detected entity
        ///
        /// - Remark: Generated from `#/components/schemas/Entity`.
        public struct Entity: Codable, Hashable, Sendable {
            /// The type of entity for the detected entity
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/entity_type`.
            public var entity_type: Components.Schemas.EntityType
            /// The text for the detected entity
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, at which the detected entity appears in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the detected entity in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/Entity/end`.
            public var end: Swift.Int
            /// Creates a new `Entity`.
            ///
            /// - Parameters:
            ///   - entity_type: The type of entity for the detected entity
            ///   - text: The text for the detected entity
            ///   - start: The starting time, in milliseconds, at which the detected entity appears in the audio file
            ///   - end: The ending time, in milliseconds, for the detected entity in the audio file
            public init(
                entity_type: Components.Schemas.EntityType,
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int
            ) {
                self.entity_type = entity_type
                self.text = text
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case entity_type
                case text
                case start
                case end
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.entity_type = try container.decode(
                    Components.Schemas.EntityType.self,
                    forKey: .entity_type
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "entity_type",
                    "text",
                    "start",
                    "end"
                ])
            }
        }
        /// The type of entity for the detected entity
        ///
        /// - Remark: Generated from `#/components/schemas/EntityType`.
        @frozen public enum EntityType: String, Codable, Hashable, Sendable, CaseIterable {
            case account_number = "account_number"
            case banking_information = "banking_information"
            case blood_type = "blood_type"
            case credit_card_cvv = "credit_card_cvv"
            case credit_card_expiration = "credit_card_expiration"
            case credit_card_number = "credit_card_number"
            case date = "date"
            case date_interval = "date_interval"
            case date_of_birth = "date_of_birth"
            case drivers_license = "drivers_license"
            case drug = "drug"
            case duration = "duration"
            case email_address = "email_address"
            case event = "event"
            case filename = "filename"
            case gender_sexuality = "gender_sexuality"
            case healthcare_number = "healthcare_number"
            case injury = "injury"
            case ip_address = "ip_address"
            case language = "language"
            case location = "location"
            case marital_status = "marital_status"
            case medical_condition = "medical_condition"
            case medical_process = "medical_process"
            case money_amount = "money_amount"
            case nationality = "nationality"
            case number_sequence = "number_sequence"
            case occupation = "occupation"
            case organization = "organization"
            case passport_number = "passport_number"
            case password = "password"
            case person_age = "person_age"
            case person_name = "person_name"
            case phone_number = "phone_number"
            case physical_attribute = "physical_attribute"
            case political_affiliation = "political_affiliation"
            case religion = "religion"
            case statistics = "statistics"
            case time = "time"
            case url = "url"
            case us_social_security_number = "us_social_security_number"
            case username = "username"
            case vehicle_id = "vehicle_id"
            case zodiac_sign = "zodiac_sign"
        }
        /// The result of the Sentiment Analysis model
        ///
        /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult`.
        public struct SentimentAnalysisResult: Codable, Hashable, Sendable {
            /// The transcript of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/end`.
            public var end: Swift.Int
            /// The detected sentiment for the sentence, one of POSITIVE, NEUTRAL, NEGATIVE
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/sentiment`.
            public var sentiment: Components.Schemas.Sentiment
            /// The confidence score for the detected sentiment of the sentence, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/confidence`.
            public var confidence: Swift.Double
            /// The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/channel`.
            public var channel: Swift.String?
            /// The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/SentimentAnalysisResult/speaker`.
            public var speaker: Swift.String?
            /// Creates a new `SentimentAnalysisResult`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the sentence
            ///   - start: The starting time, in milliseconds, of the sentence
            ///   - end: The ending time, in milliseconds, of the sentence
            ///   - sentiment: The detected sentiment for the sentence, one of POSITIVE, NEUTRAL, NEGATIVE
            ///   - confidence: The confidence score for the detected sentiment of the sentence, from 0 to 1
            ///   - channel: The channel of this utterance. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                sentiment: Components.Schemas.Sentiment,
                confidence: Swift.Double,
                channel: Swift.String? = nil,
                speaker: Swift.String? = nil
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.sentiment = sentiment
                self.confidence = confidence
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case sentiment
                case confidence
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                self.sentiment = try container.decode(
                    Components.Schemas.Sentiment.self,
                    forKey: .sentiment
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                self.speaker = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "sentiment",
                    "confidence",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/Sentiment`.
        public typealias Sentiment = OpenAPIRuntime.OpenAPIValueContainer
        /// The result of the topic detection model
        ///
        /// - Remark: Generated from `#/components/schemas/TopicDetectionResult`.
        public struct TopicDetectionResult: Codable, Hashable, Sendable {
            /// The text in the transcript in which a detected topic occurs
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload`.
            public struct labelsPayloadPayload: Codable, Hashable, Sendable {
                /// How relevant the detected topic is of a detected topic
                ///
                /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload/relevance`.
                public var relevance: Swift.Double
                /// The IAB taxonomical label for the label of the detected topic, where > denotes supertopic/subtopic relationship
                ///
                /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labelsPayload/label`.
                public var label: Swift.String
                /// Creates a new `labelsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - relevance: How relevant the detected topic is of a detected topic
                ///   - label: The IAB taxonomical label for the label of the detected topic, where > denotes supertopic/subtopic relationship
                public init(
                    relevance: Swift.Double,
                    label: Swift.String
                ) {
                    self.relevance = relevance
                    self.label = label
                }
                public enum CodingKeys: String, CodingKey {
                    case relevance
                    case label
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.relevance = try container.decode(
                        Swift.Double.self,
                        forKey: .relevance
                    )
                    self.label = try container.decode(
                        Swift.String.self,
                        forKey: .label
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "relevance",
                        "label"
                    ])
                }
            }
            /// An array of detected topics in the text
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labels`.
            public typealias labelsPayload = [Components.Schemas.TopicDetectionResult.labelsPayloadPayload]
            /// An array of detected topics in the text
            ///
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/labels`.
            public var labels: Components.Schemas.TopicDetectionResult.labelsPayload?
            /// - Remark: Generated from `#/components/schemas/TopicDetectionResult/timestamp`.
            public var timestamp: Components.Schemas.Timestamp?
            /// Creates a new `TopicDetectionResult`.
            ///
            /// - Parameters:
            ///   - text: The text in the transcript in which a detected topic occurs
            ///   - labels: An array of detected topics in the text
            ///   - timestamp:
            public init(
                text: Swift.String,
                labels: Components.Schemas.TopicDetectionResult.labelsPayload? = nil,
                timestamp: Components.Schemas.Timestamp? = nil
            ) {
                self.text = text
                self.labels = labels
                self.timestamp = timestamp
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case labels
                case timestamp
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.labels = try container.decodeIfPresent(
                    Components.Schemas.TopicDetectionResult.labelsPayload.self,
                    forKey: .labels
                )
                self.timestamp = try container.decodeIfPresent(
                    Components.Schemas.Timestamp.self,
                    forKey: .timestamp
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "labels",
                    "timestamp"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel`.
        public struct ContentSafetyLabel: Codable, Hashable, Sendable {
            /// The label of the sensitive topic
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/label`.
            public var label: Swift.String
            /// The confidence score for the topic being discussed, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/confidence`.
            public var confidence: Swift.Double
            /// How severely the topic is discussed in the section, from 0 to 1
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabel/severity`.
            public var severity: Swift.Double
            /// Creates a new `ContentSafetyLabel`.
            ///
            /// - Parameters:
            ///   - label: The label of the sensitive topic
            ///   - confidence: The confidence score for the topic being discussed, from 0 to 1
            ///   - severity: How severely the topic is discussed in the section, from 0 to 1
            public init(
                label: Swift.String,
                confidence: Swift.Double,
                severity: Swift.Double
            ) {
                self.label = label
                self.confidence = confidence
                self.severity = severity
            }
            public enum CodingKeys: String, CodingKey {
                case label
                case confidence
                case severity
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.label = try container.decode(
                    Swift.String.self,
                    forKey: .label
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.severity = try container.decode(
                    Swift.Double.self,
                    forKey: .severity
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "label",
                    "confidence",
                    "severity"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult`.
        public struct ContentSafetyLabelResult: Codable, Hashable, Sendable {
            /// The transcript of the section flagged by the Content Moderation model
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/text`.
            public var text: Swift.String
            /// An array of safety labels, one per sensitive topic that was detected in the section
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/labels`.
            public var labels: [Components.Schemas.ContentSafetyLabel]
            /// The sentence index at which the section begins
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/sentences_idx_start`.
            public var sentences_idx_start: Swift.Int
            /// The sentence index at which the section ends
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/sentences_idx_end`.
            public var sentences_idx_end: Swift.Int
            /// Timestamp information for the section
            ///
            /// - Remark: Generated from `#/components/schemas/ContentSafetyLabelResult/timestamp`.
            public var timestamp: Components.Schemas.Timestamp
            /// Creates a new `ContentSafetyLabelResult`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the section flagged by the Content Moderation model
            ///   - labels: An array of safety labels, one per sensitive topic that was detected in the section
            ///   - sentences_idx_start: The sentence index at which the section begins
            ///   - sentences_idx_end: The sentence index at which the section ends
            ///   - timestamp: Timestamp information for the section
            public init(
                text: Swift.String,
                labels: [Components.Schemas.ContentSafetyLabel],
                sentences_idx_start: Swift.Int,
                sentences_idx_end: Swift.Int,
                timestamp: Components.Schemas.Timestamp
            ) {
                self.text = text
                self.labels = labels
                self.sentences_idx_start = sentences_idx_start
                self.sentences_idx_end = sentences_idx_end
                self.timestamp = timestamp
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case labels
                case sentences_idx_start
                case sentences_idx_end
                case timestamp
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.labels = try container.decode(
                    [Components.Schemas.ContentSafetyLabel].self,
                    forKey: .labels
                )
                self.sentences_idx_start = try container.decode(
                    Swift.Int.self,
                    forKey: .sentences_idx_start
                )
                self.sentences_idx_end = try container.decode(
                    Swift.Int.self,
                    forKey: .sentences_idx_end
                )
                self.timestamp = try container.decode(
                    Components.Schemas.Timestamp.self,
                    forKey: .timestamp
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "labels",
                    "sentences_idx_start",
                    "sentences_idx_end",
                    "timestamp"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary`.
        public struct SeverityScoreSummary: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/low`.
            public var low: Swift.Double
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/medium`.
            public var medium: Swift.Double
            /// - Remark: Generated from `#/components/schemas/SeverityScoreSummary/high`.
            public var high: Swift.Double
            /// Creates a new `SeverityScoreSummary`.
            ///
            /// - Parameters:
            ///   - low:
            ///   - medium:
            ///   - high:
            public init(
                low: Swift.Double,
                medium: Swift.Double,
                high: Swift.Double
            ) {
                self.low = low
                self.medium = medium
                self.high = high
            }
            public enum CodingKeys: String, CodingKey {
                case low
                case medium
                case high
            }
        }
        /// An array of results for the Key Phrases model, if it is enabled.
        /// See [Key phrases](https://www.assemblyai.com/docs/models/key-phrases) for more information.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult`.
        public struct AutoHighlightsResult: Codable, Hashable, Sendable {
            /// The status of the Key Phrases model. Either success, or unavailable in the rare case that the model failed.
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult/status`.
            public var status: Components.Schemas.AudioIntelligenceModelStatus
            /// A temporally-sequential array of Key Phrases
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightsResult/results`.
            public var results: [Components.Schemas.AutoHighlightResult]
            /// Creates a new `AutoHighlightsResult`.
            ///
            /// - Parameters:
            ///   - status: The status of the Key Phrases model. Either success, or unavailable in the rare case that the model failed.
            ///   - results: A temporally-sequential array of Key Phrases
            public init(
                status: Components.Schemas.AudioIntelligenceModelStatus,
                results: [Components.Schemas.AutoHighlightResult]
            ) {
                self.status = status
                self.results = results
            }
            public enum CodingKeys: String, CodingKey {
                case status
                case results
            }
        }
        /// - Remark: Generated from `#/components/schemas/AutoHighlightResult`.
        public struct AutoHighlightResult: Codable, Hashable, Sendable {
            /// The total number of times the key phrase appears in the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/count`.
            public var count: Swift.Int
            /// The total relevancy to the overall audio file of this key phrase - a greater number means more relevant
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/rank`.
            public var rank: Swift.Float
            /// The text itself of the key phrase
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/text`.
            public var text: Swift.String
            /// The timestamp of the of the key phrase
            ///
            /// - Remark: Generated from `#/components/schemas/AutoHighlightResult/timestamps`.
            public var timestamps: [Components.Schemas.Timestamp]
            /// Creates a new `AutoHighlightResult`.
            ///
            /// - Parameters:
            ///   - count: The total number of times the key phrase appears in the audio file
            ///   - rank: The total relevancy to the overall audio file of this key phrase - a greater number means more relevant
            ///   - text: The text itself of the key phrase
            ///   - timestamps: The timestamp of the of the key phrase
            public init(
                count: Swift.Int,
                rank: Swift.Float,
                text: Swift.String,
                timestamps: [Components.Schemas.Timestamp]
            ) {
                self.count = count
                self.rank = rank
                self.text = text
                self.timestamps = timestamps
            }
            public enum CodingKeys: String, CodingKey {
                case count
                case rank
                case text
                case timestamps
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.count = try container.decode(
                    Swift.Int.self,
                    forKey: .count
                )
                self.rank = try container.decode(
                    Swift.Float.self,
                    forKey: .rank
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.timestamps = try container.decode(
                    [Components.Schemas.Timestamp].self,
                    forKey: .timestamps
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "count",
                    "rank",
                    "text",
                    "timestamps"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptWord`.
        public struct TranscriptWord: Codable, Hashable, Sendable {
            /// The confidence score for the transcript of this word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/confidence`.
            public var confidence: Swift.Double
            /// The starting time, in milliseconds, for the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/end`.
            public var end: Swift.Int
            /// The text of the word
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/text`.
            public var text: Swift.String
            /// The channel of the word. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/channel`.
            public var channel: Swift.String?
            /// The speaker of the word if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptWord/speaker`.
            public var speaker: Swift.String?
            /// Creates a new `TranscriptWord`.
            ///
            /// - Parameters:
            ///   - confidence: The confidence score for the transcript of this word
            ///   - start: The starting time, in milliseconds, for the word
            ///   - end: The ending time, in milliseconds, for the word
            ///   - text: The text of the word
            ///   - channel: The channel of the word. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the word if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                confidence: Swift.Double,
                start: Swift.Int,
                end: Swift.Int,
                text: Swift.String,
                channel: Swift.String? = nil,
                speaker: Swift.String? = nil
            ) {
                self.confidence = confidence
                self.start = start
                self.end = end
                self.text = text
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case confidence
                case start
                case end
                case text
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                self.speaker = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "confidence",
                    "start",
                    "end",
                    "text",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptSentence`.
        public struct TranscriptSentence: Codable, Hashable, Sendable {
            /// The transcript of the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, for the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, for the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/end`.
            public var end: Swift.Int
            /// The confidence score for the transcript of this sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/confidence`.
            public var confidence: Swift.Double
            /// An array of words in the sentence
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// The channel of the sentence. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/channel`.
            public var channel: Swift.String?
            /// The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptSentence/speaker`.
            public var speaker: Swift.String?
            /// Creates a new `TranscriptSentence`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the sentence
            ///   - start: The starting time, in milliseconds, for the sentence
            ///   - end: The ending time, in milliseconds, for the sentence
            ///   - confidence: The confidence score for the transcript of this sentence
            ///   - words: An array of words in the sentence
            ///   - channel: The channel of the sentence. The left and right channels are channels 1 and 2. Additional channels increment the channel number sequentially.
            ///   - speaker: The speaker of the sentence if [Speaker Diarization](https://www.assemblyai.com/docs/models/speaker-diarization) is enabled, else null
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                confidence: Swift.Double,
                words: [Components.Schemas.TranscriptWord],
                channel: Swift.String? = nil,
                speaker: Swift.String? = nil
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.confidence = confidence
                self.words = words
                self.channel = channel
                self.speaker = speaker
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case confidence
                case words
                case channel
                case speaker
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                self.channel = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .channel
                )
                self.speaker = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .speaker
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "confidence",
                    "words",
                    "channel",
                    "speaker"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/SentencesResponse`.
        public struct SentencesResponse: Codable, Hashable, Sendable {
            /// The unique identifier for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/id`.
            public var id: Swift.String
            /// The confidence score for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/confidence`.
            public var confidence: Swift.Double
            /// The duration of the audio file in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/audio_duration`.
            public var audio_duration: Swift.Double
            /// An array of sentences in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/SentencesResponse/sentences`.
            public var sentences: [Components.Schemas.TranscriptSentence]
            /// Creates a new `SentencesResponse`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier for the transcript
            ///   - confidence: The confidence score for the transcript
            ///   - audio_duration: The duration of the audio file in seconds
            ///   - sentences: An array of sentences in the transcript
            public init(
                id: Swift.String,
                confidence: Swift.Double,
                audio_duration: Swift.Double,
                sentences: [Components.Schemas.TranscriptSentence]
            ) {
                self.id = id
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.sentences = sentences
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case confidence
                case audio_duration
                case sentences
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.audio_duration = try container.decode(
                    Swift.Double.self,
                    forKey: .audio_duration
                )
                self.sentences = try container.decode(
                    [Components.Schemas.TranscriptSentence].self,
                    forKey: .sentences
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "confidence",
                    "audio_duration",
                    "sentences"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptParagraph`.
        public struct TranscriptParagraph: Codable, Hashable, Sendable {
            /// The transcript of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/text`.
            public var text: Swift.String
            /// The starting time, in milliseconds, of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/start`.
            public var start: Swift.Int
            /// The ending time, in milliseconds, of the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/end`.
            public var end: Swift.Int
            /// The confidence score for the transcript of this paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/confidence`.
            public var confidence: Swift.Double
            /// An array of words in the paragraph
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptParagraph/words`.
            public var words: [Components.Schemas.TranscriptWord]
            /// Creates a new `TranscriptParagraph`.
            ///
            /// - Parameters:
            ///   - text: The transcript of the paragraph
            ///   - start: The starting time, in milliseconds, of the paragraph
            ///   - end: The ending time, in milliseconds, of the paragraph
            ///   - confidence: The confidence score for the transcript of this paragraph
            ///   - words: An array of words in the paragraph
            public init(
                text: Swift.String,
                start: Swift.Int,
                end: Swift.Int,
                confidence: Swift.Double,
                words: [Components.Schemas.TranscriptWord]
            ) {
                self.text = text
                self.start = start
                self.end = end
                self.confidence = confidence
                self.words = words
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case confidence
                case words
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Int.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Int.self,
                    forKey: .end
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.words = try container.decode(
                    [Components.Schemas.TranscriptWord].self,
                    forKey: .words
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "confidence",
                    "words"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ParagraphsResponse`.
        public struct ParagraphsResponse: Codable, Hashable, Sendable {
            /// The unique identifier of your transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/id`.
            public var id: Swift.String
            /// The confidence score for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/confidence`.
            public var confidence: Swift.Double
            /// The duration of the audio file in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/audio_duration`.
            public var audio_duration: Swift.Double
            /// An array of paragraphs in the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/ParagraphsResponse/paragraphs`.
            public var paragraphs: [Components.Schemas.TranscriptParagraph]
            /// Creates a new `ParagraphsResponse`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of your transcript
            ///   - confidence: The confidence score for the transcript
            ///   - audio_duration: The duration of the audio file in seconds
            ///   - paragraphs: An array of paragraphs in the transcript
            public init(
                id: Swift.String,
                confidence: Swift.Double,
                audio_duration: Swift.Double,
                paragraphs: [Components.Schemas.TranscriptParagraph]
            ) {
                self.id = id
                self.confidence = confidence
                self.audio_duration = audio_duration
                self.paragraphs = paragraphs
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case confidence
                case audio_duration
                case paragraphs
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                self.confidence = try container.decode(
                    Swift.Double.self,
                    forKey: .confidence
                )
                self.audio_duration = try container.decode(
                    Swift.Double.self,
                    forKey: .audio_duration
                )
                self.paragraphs = try container.decode(
                    [Components.Schemas.TranscriptParagraph].self,
                    forKey: .paragraphs
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "confidence",
                    "audio_duration",
                    "paragraphs"
                ])
            }
        }
        /// Details of the transcript page. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
        ///
        /// - Remark: Generated from `#/components/schemas/PageDetails`.
        public struct PageDetails: Codable, Hashable, Sendable {
            /// The number of results this page is limited to
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/limit`.
            public var limit: Swift.Int
            /// The actual number of results in the page
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/result_count`.
            public var result_count: Swift.Int
            /// The URL used to retrieve the current page of transcripts
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/current_url`.
            public var current_url: Swift.String
            /// The URL to the next page of transcripts. The previous URL always points to a page with older transcripts.
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/prev_url`.
            public var prev_url: Swift.String?
            /// The URL to the next page of transcripts. The next URL always points to a page with newer transcripts.
            ///
            /// - Remark: Generated from `#/components/schemas/PageDetails/next_url`.
            public var next_url: Swift.String?
            /// Creates a new `PageDetails`.
            ///
            /// - Parameters:
            ///   - limit: The number of results this page is limited to
            ///   - result_count: The actual number of results in the page
            ///   - current_url: The URL used to retrieve the current page of transcripts
            ///   - prev_url: The URL to the next page of transcripts. The previous URL always points to a page with older transcripts.
            ///   - next_url: The URL to the next page of transcripts. The next URL always points to a page with newer transcripts.
            public init(
                limit: Swift.Int,
                result_count: Swift.Int,
                current_url: Swift.String,
                prev_url: Swift.String? = nil,
                next_url: Swift.String? = nil
            ) {
                self.limit = limit
                self.result_count = result_count
                self.current_url = current_url
                self.prev_url = prev_url
                self.next_url = next_url
            }
            public enum CodingKeys: String, CodingKey {
                case limit
                case result_count
                case current_url
                case prev_url
                case next_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.limit = try container.decode(
                    Swift.Int.self,
                    forKey: .limit
                )
                self.result_count = try container.decode(
                    Swift.Int.self,
                    forKey: .result_count
                )
                self.current_url = try container.decode(
                    Swift.String.self,
                    forKey: .current_url
                )
                self.prev_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .prev_url
                )
                self.next_url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .next_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "limit",
                    "result_count",
                    "current_url",
                    "prev_url",
                    "next_url"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ListTranscriptParams`.
        public struct ListTranscriptParams: Codable, Hashable, Sendable {
            /// Maximum amount of transcripts to retrieve
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/limit`.
            public var limit: Swift.Int?
            /// Filter by transcript status
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/status`.
            public var status: Components.Schemas.TranscriptStatus?
            /// Only get transcripts created on this date
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/created_on`.
            public var created_on: Swift.String?
            /// Get transcripts that were created before this transcript ID
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/before_id`.
            public var before_id: Swift.String?
            /// Get transcripts that were created after this transcript ID
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/after_id`.
            public var after_id: Swift.String?
            /// Only get throttled transcripts, overrides the status filter
            ///
            /// - Remark: Generated from `#/components/schemas/ListTranscriptParams/throttled_only`.
            public var throttled_only: Swift.Bool?
            /// Creates a new `ListTranscriptParams`.
            ///
            /// - Parameters:
            ///   - limit: Maximum amount of transcripts to retrieve
            ///   - status: Filter by transcript status
            ///   - created_on: Only get transcripts created on this date
            ///   - before_id: Get transcripts that were created before this transcript ID
            ///   - after_id: Get transcripts that were created after this transcript ID
            ///   - throttled_only: Only get throttled transcripts, overrides the status filter
            public init(
                limit: Swift.Int? = nil,
                status: Components.Schemas.TranscriptStatus? = nil,
                created_on: Swift.String? = nil,
                before_id: Swift.String? = nil,
                after_id: Swift.String? = nil,
                throttled_only: Swift.Bool? = nil
            ) {
                self.limit = limit
                self.status = status
                self.created_on = created_on
                self.before_id = before_id
                self.after_id = after_id
                self.throttled_only = throttled_only
            }
            public enum CodingKeys: String, CodingKey {
                case limit
                case status
                case created_on
                case before_id
                case after_id
                case throttled_only
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.limit = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .limit
                )
                self.status = try container.decodeIfPresent(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                self.created_on = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .created_on
                )
                self.before_id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .before_id
                )
                self.after_id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .after_id
                )
                self.throttled_only = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .throttled_only
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "limit",
                    "status",
                    "created_on",
                    "before_id",
                    "after_id",
                    "throttled_only"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptListItem`.
        public struct TranscriptListItem: Codable, Hashable, Sendable {
            /// The unique identifier for the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/id`.
            public var id: Swift.String
            /// The URL to retrieve the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/resource_url`.
            public var resource_url: Swift.String
            /// The status of the transcript
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/status`.
            public var status: Components.Schemas.TranscriptStatus
            /// The date and time the transcript was created
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/created`.
            public var created: Swift.String
            /// The date and time the transcript was completed
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/completed`.
            public var completed: Swift.String?
            /// The URL to the audio file
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/audio_url`.
            public var audio_url: Swift.String
            /// Error message of why the transcript failed
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptListItem/error`.
            public var error: Swift.String?
            /// Creates a new `TranscriptListItem`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier for the transcript
            ///   - resource_url: The URL to retrieve the transcript
            ///   - status: The status of the transcript
            ///   - created: The date and time the transcript was created
            ///   - completed: The date and time the transcript was completed
            ///   - audio_url: The URL to the audio file
            ///   - error: Error message of why the transcript failed
            public init(
                id: Swift.String,
                resource_url: Swift.String,
                status: Components.Schemas.TranscriptStatus,
                created: Swift.String,
                completed: Swift.String? = nil,
                audio_url: Swift.String,
                error: Swift.String? = nil
            ) {
                self.id = id
                self.resource_url = resource_url
                self.status = status
                self.created = created
                self.completed = completed
                self.audio_url = audio_url
                self.error = error
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case resource_url
                case status
                case created
                case completed
                case audio_url
                case error
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.id = try container.decode(
                    Swift.String.self,
                    forKey: .id
                )
                self.resource_url = try container.decode(
                    Swift.String.self,
                    forKey: .resource_url
                )
                self.status = try container.decode(
                    Components.Schemas.TranscriptStatus.self,
                    forKey: .status
                )
                self.created = try container.decode(
                    Swift.String.self,
                    forKey: .created
                )
                self.completed = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .completed
                )
                self.audio_url = try container.decode(
                    Swift.String.self,
                    forKey: .audio_url
                )
                self.error = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .error
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "id",
                    "resource_url",
                    "status",
                    "created",
                    "completed",
                    "audio_url",
                    "error"
                ])
            }
        }
        /// A list of transcripts. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptList`.
        public struct TranscriptList: Codable, Hashable, Sendable {
            /// Details of the transcript page
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptList/page_details`.
            public var page_details: Components.Schemas.PageDetails
            /// An array of transcripts
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptList/transcripts`.
            public var transcripts: [Components.Schemas.TranscriptListItem]
            /// Creates a new `TranscriptList`.
            ///
            /// - Parameters:
            ///   - page_details: Details of the transcript page
            ///   - transcripts: An array of transcripts
            public init(
                page_details: Components.Schemas.PageDetails,
                transcripts: [Components.Schemas.TranscriptListItem]
            ) {
                self.page_details = page_details
                self.transcripts = transcripts
            }
            public enum CodingKeys: String, CodingKey {
                case page_details
                case transcripts
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.page_details = try container.decode(
                    Components.Schemas.PageDetails.self,
                    forKey: .page_details
                )
                self.transcripts = try container.decode(
                    [Components.Schemas.TranscriptListItem].self,
                    forKey: .transcripts
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "page_details",
                    "transcripts"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/UploadedFile`.
        public struct UploadedFile: Codable, Hashable, Sendable {
            /// A URL that points to your audio file, accessible only by AssemblyAI's servers
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/UploadedFile/upload_url`.
            public var upload_url: Swift.String
            /// Creates a new `UploadedFile`.
            ///
            /// - Parameters:
            ///   - upload_url: A URL that points to your audio file, accessible only by AssemblyAI's servers
            public init(upload_url: Swift.String) {
                self.upload_url = upload_url
            }
            public enum CodingKeys: String, CodingKey {
                case upload_url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.upload_url = try container.decode(
                    Swift.String.self,
                    forKey: .upload_url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "upload_url"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/CreateRealtimeTemporaryTokenParams`.
        public struct CreateRealtimeTemporaryTokenParams: Codable, Hashable, Sendable {
            /// The amount of time until the token expires in seconds
            ///
            /// - Remark: Generated from `#/components/schemas/CreateRealtimeTemporaryTokenParams/expires_in`.
            public var expires_in: Swift.Int
            /// Creates a new `CreateRealtimeTemporaryTokenParams`.
            ///
            /// - Parameters:
            ///   - expires_in: The amount of time until the token expires in seconds
            public init(expires_in: Swift.Int) {
                self.expires_in = expires_in
            }
            public enum CodingKeys: String, CodingKey {
                case expires_in
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.expires_in = try container.decode(
                    Swift.Int.self,
                    forKey: .expires_in
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "expires_in"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/RealtimeTemporaryTokenResponse`.
        public struct RealtimeTemporaryTokenResponse: Codable, Hashable, Sendable {
            /// The temporary authentication token for Streaming Speech-to-Text
            ///
            /// - Remark: Generated from `#/components/schemas/RealtimeTemporaryTokenResponse/token`.
            public var token: Swift.String
            /// Creates a new `RealtimeTemporaryTokenResponse`.
            ///
            /// - Parameters:
            ///   - token: The temporary authentication token for Streaming Speech-to-Text
            public init(token: Swift.String) {
                self.token = token
            }
            public enum CodingKeys: String, CodingKey {
                case token
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.token = try container.decode(
                    Swift.String.self,
                    forKey: .token
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "token"
                ])
            }
        }
        /// Either success, or unavailable in the rare case that the model failed
        ///
        /// - Remark: Generated from `#/components/schemas/AudioIntelligenceModelStatus`.
        @frozen public enum AudioIntelligenceModelStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case success = "success"
            case unavailable = "unavailable"
        }
        /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse`.
        public struct PurgeLemurRequestDataResponse: Codable, Hashable, Sendable {
            /// The ID of the deletion request of the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/request_id`.
            public var request_id: Swift.String
            /// The ID of the LeMUR request to purge the data for
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/request_id_to_purge`.
            public var request_id_to_purge: Swift.String
            /// Whether the request data was deleted
            ///
            /// - Remark: Generated from `#/components/schemas/PurgeLemurRequestDataResponse/deleted`.
            public var deleted: Swift.Bool
            /// Creates a new `PurgeLemurRequestDataResponse`.
            ///
            /// - Parameters:
            ///   - request_id: The ID of the deletion request of the LeMUR request
            ///   - request_id_to_purge: The ID of the LeMUR request to purge the data for
            ///   - deleted: Whether the request data was deleted
            public init(
                request_id: Swift.String,
                request_id_to_purge: Swift.String,
                deleted: Swift.Bool
            ) {
                self.request_id = request_id
                self.request_id_to_purge = request_id_to_purge
                self.deleted = deleted
            }
            public enum CodingKeys: String, CodingKey {
                case request_id
                case request_id_to_purge
                case deleted
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.request_id = try container.decode(
                    Swift.String.self,
                    forKey: .request_id
                )
                self.request_id_to_purge = try container.decode(
                    Swift.String.self,
                    forKey: .request_id_to_purge
                )
                self.deleted = try container.decode(
                    Swift.Bool.self,
                    forKey: .deleted
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "request_id",
                    "request_id_to_purge",
                    "deleted"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurBaseResponse`.
        public struct LemurBaseResponse: Codable, Hashable, Sendable {
            /// The ID of the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseResponse/request_id`.
            public var request_id: Swift.String
            /// The usage numbers for the LeMUR request
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseResponse/usage`.
            public var usage: Components.Schemas.LemurUsage
            /// Creates a new `LemurBaseResponse`.
            ///
            /// - Parameters:
            ///   - request_id: The ID of the LeMUR request
            ///   - usage: The usage numbers for the LeMUR request
            public init(
                request_id: Swift.String,
                usage: Components.Schemas.LemurUsage
            ) {
                self.request_id = request_id
                self.usage = usage
            }
            public enum CodingKeys: String, CodingKey {
                case request_id
                case usage
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.request_id = try container.decode(
                    Swift.String.self,
                    forKey: .request_id
                )
                self.usage = try container.decode(
                    Components.Schemas.LemurUsage.self,
                    forKey: .usage
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "request_id",
                    "usage"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurStringResponse`.
        public struct LemurStringResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// The response generated by LeMUR.
                ///
                /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1/response`.
                public var response: Swift.String
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - response: The response generated by LeMUR.
                public init(response: Swift.String) {
                    self.response = response
                }
                public enum CodingKeys: String, CodingKey {
                    case response
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.response = try container.decode(
                        Swift.String.self,
                        forKey: .response
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "response"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse.Value1Payload
            /// - Remark: Generated from `#/components/schemas/LemurStringResponse/value2`.
            public var value2: Components.Schemas.LemurBaseResponse
            /// Creates a new `LemurStringResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurStringResponse.Value1Payload,
                value2: Components.Schemas.LemurBaseResponse
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurTaskResponse`.
        public struct LemurTaskResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurTaskResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurTaskResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurSummaryResponse`.
        public struct LemurSummaryResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurSummaryResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurSummaryResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurActionItemsResponse`.
        public struct LemurActionItemsResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsResponse/value1`.
            public var value1: Components.Schemas.LemurStringResponse
            /// Creates a new `LemurActionItemsResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurStringResponse) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse`.
        public struct LemurQuestionAnswerResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value1`.
            public var value1: Components.Schemas.LemurBaseResponse
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// The answers generated by LeMUR and their questions
                ///
                /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2/response`.
                public var response: [Components.Schemas.LemurQuestionAnswer]
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - response: The answers generated by LeMUR and their questions
                public init(response: [Components.Schemas.LemurQuestionAnswer]) {
                    self.response = response
                }
                public enum CodingKeys: String, CodingKey {
                    case response
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.response = try container.decode(
                        [Components.Schemas.LemurQuestionAnswer].self,
                        forKey: .response
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "response"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerResponse/value2`.
            public var value2: Components.Schemas.LemurQuestionAnswerResponse.Value2Payload
            /// Creates a new `LemurQuestionAnswerResponse`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseResponse,
                value2: Components.Schemas.LemurQuestionAnswerResponse.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// An answer generated by LeMUR and its question
        ///
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer`.
        public struct LemurQuestionAnswer: Codable, Hashable, Sendable {
            /// The question for LeMUR to answer
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer/question`.
            public var question: Swift.String
            /// The answer generated by LeMUR
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswer/answer`.
            public var answer: Swift.String
            /// Creates a new `LemurQuestionAnswer`.
            ///
            /// - Parameters:
            ///   - question: The question for LeMUR to answer
            ///   - answer: The answer generated by LeMUR
            public init(
                question: Swift.String,
                answer: Swift.String
            ) {
                self.question = question
                self.answer = answer
            }
            public enum CodingKeys: String, CodingKey {
                case question
                case answer
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.question = try container.decode(
                    Swift.String.self,
                    forKey: .question
                )
                self.answer = try container.decode(
                    Swift.String.self,
                    forKey: .answer
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "question",
                    "answer"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurResponse`.
        @frozen public enum LemurResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurResponse/case1`.
            case LemurStringResponse(Components.Schemas.LemurStringResponse)
            /// - Remark: Generated from `#/components/schemas/LemurResponse/case2`.
            case LemurQuestionAnswerResponse(Components.Schemas.LemurQuestionAnswerResponse)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .LemurStringResponse(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .LemurQuestionAnswerResponse(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .LemurStringResponse(value):
                    try value.encode(to: encoder)
                case let .LemurQuestionAnswerResponse(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurBaseParams`.
        public struct LemurBaseParams: Codable, Hashable, Sendable {
            /// A list of completed transcripts with text. Up to a maximum of 100 hours of audio.
            /// Use either transcript_ids or input_text as input into LeMUR.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/transcript_ids`.
            public var transcript_ids: [Swift.String]?
            /// Custom formatted transcript data. Maximum size is the context limit of the selected model.
            /// Use either transcript_ids or input_text as input into LeMUR.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/input_text`.
            public var input_text: Swift.String?
            /// Context to provide the model. This can be a string or a free-form JSON value.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context`.
            @frozen public enum contextPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case1`.
                case case1(Swift.String)
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case2`.
                public struct Case2Payload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `Case2Payload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context/case2`.
                case case2(Components.Schemas.LemurBaseParams.contextPayload.Case2Payload)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// Context to provide the model. This can be a string or a free-form JSON value.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/context`.
            public var context: Components.Schemas.LemurBaseParams.contextPayload?
            /// The model that is used for the final prompt after compression is performed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model`.
            public struct final_modelPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model/value1`.
                public var value1: Components.Schemas.LemurModel?
                /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model/value2`.
                public var value2: Swift.String?
                /// Creates a new `final_modelPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.LemurModel? = nil,
                    value2: Swift.String? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        self.value1,
                        self.value2
                    ])
                }
            }
            /// The model that is used for the final prompt after compression is performed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/final_model`.
            public var final_model: Components.Schemas.LemurBaseParams.final_modelPayload
            /// Maximum output size in tokens, up to the `final_model`'s max [(see chart)](/docs/lemur/customize-parameters#change-the-maximum-output-size).
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/max_output_size`.
            public var max_output_size: Swift.Int?
            /// The temperature to use for the model.
            /// Higher values result in answers that are more creative, lower values are more conservative.
            /// Can be any value between 0.0 and 1.0 inclusive.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurBaseParams/temperature`.
            public var temperature: Swift.Float?
            /// Creates a new `LemurBaseParams`.
            ///
            /// - Parameters:
            ///   - transcript_ids: A list of completed transcripts with text. Up to a maximum of 100 hours of audio.
            ///   - input_text: Custom formatted transcript data. Maximum size is the context limit of the selected model.
            ///   - context: Context to provide the model. This can be a string or a free-form JSON value.
            ///   - final_model: The model that is used for the final prompt after compression is performed.
            ///   - max_output_size: Maximum output size in tokens, up to the `final_model`'s max [(see chart)](/docs/lemur/customize-parameters#change-the-maximum-output-size).
            ///   - temperature: The temperature to use for the model.
            public init(
                transcript_ids: [Swift.String]? = nil,
                input_text: Swift.String? = nil,
                context: Components.Schemas.LemurBaseParams.contextPayload? = nil,
                final_model: Components.Schemas.LemurBaseParams.final_modelPayload,
                max_output_size: Swift.Int? = nil,
                temperature: Swift.Float? = nil
            ) {
                self.transcript_ids = transcript_ids
                self.input_text = input_text
                self.context = context
                self.final_model = final_model
                self.max_output_size = max_output_size
                self.temperature = temperature
            }
            public enum CodingKeys: String, CodingKey {
                case transcript_ids
                case input_text
                case context
                case final_model
                case max_output_size
                case temperature
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.transcript_ids = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .transcript_ids
                )
                self.input_text = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .input_text
                )
                self.context = try container.decodeIfPresent(
                    Components.Schemas.LemurBaseParams.contextPayload.self,
                    forKey: .context
                )
                self.final_model = try container.decode(
                    Components.Schemas.LemurBaseParams.final_modelPayload.self,
                    forKey: .final_model
                )
                self.max_output_size = try container.decodeIfPresent(
                    Swift.Int.self,
                    forKey: .max_output_size
                )
                self.temperature = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .temperature
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "transcript_ids",
                    "input_text",
                    "context",
                    "final_model",
                    "max_output_size",
                    "temperature"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurTaskParams`.
        public struct LemurTaskParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1`.
            public struct Value1Payload: Codable, Hashable, Sendable {
                /// Your text to prompt the model to produce a desired output, including any context you want to pass into the model.
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/prompt`.
                public var prompt: Swift.String
                /// A list of completed transcripts with text. Up to a maximum of 100 hours of audio.
                /// Use either transcript_ids or input_text as input into LeMUR.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/transcript_ids`.
                public var transcript_ids: [Swift.String]?
                /// Custom formatted transcript data. Maximum size is the context limit of the selected model.
                /// Use either transcript_ids or input_text as input into LeMUR.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/input_text`.
                public var input_text: Swift.String?
                /// The model that is used for the final prompt after compression is performed.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/final_model`.
                public var final_model: Components.Schemas.LemurModel
                /// Maximum output size in tokens, up to the `final_model`'s max [(see chart)](/docs/lemur/customize-parameters#change-the-maximum-output-size).
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/max_output_size`.
                public var max_output_size: Swift.Int?
                /// The temperature to use for the model.
                /// Higher values result in answers that are more creative, lower values are more conservative.
                /// Can be any value between 0.0 and 1.0 inclusive.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1/temperature`.
                public var temperature: Swift.Float?
                /// Creates a new `Value1Payload`.
                ///
                /// - Parameters:
                ///   - prompt: Your text to prompt the model to produce a desired output, including any context you want to pass into the model.
                ///   - transcript_ids: A list of completed transcripts with text. Up to a maximum of 100 hours of audio.
                ///   - input_text: Custom formatted transcript data. Maximum size is the context limit of the selected model.
                ///   - final_model: The model that is used for the final prompt after compression is performed.
                ///   - max_output_size: Maximum output size in tokens, up to the `final_model`'s max [(see chart)](/docs/lemur/customize-parameters#change-the-maximum-output-size).
                ///   - temperature: The temperature to use for the model.
                public init(
                    prompt: Swift.String,
                    transcript_ids: [Swift.String]? = nil,
                    input_text: Swift.String? = nil,
                    final_model: Components.Schemas.LemurModel,
                    max_output_size: Swift.Int? = nil,
                    temperature: Swift.Float? = nil
                ) {
                    self.prompt = prompt
                    self.transcript_ids = transcript_ids
                    self.input_text = input_text
                    self.final_model = final_model
                    self.max_output_size = max_output_size
                    self.temperature = temperature
                }
                public enum CodingKeys: String, CodingKey {
                    case prompt
                    case transcript_ids
                    case input_text
                    case final_model
                    case max_output_size
                    case temperature
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.prompt = try container.decode(
                        Swift.String.self,
                        forKey: .prompt
                    )
                    self.transcript_ids = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .transcript_ids
                    )
                    self.input_text = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .input_text
                    )
                    self.final_model = try container.decode(
                        Components.Schemas.LemurModel.self,
                        forKey: .final_model
                    )
                    self.max_output_size = try container.decodeIfPresent(
                        Swift.Int.self,
                        forKey: .max_output_size
                    )
                    self.temperature = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .temperature
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "prompt",
                        "transcript_ids",
                        "input_text",
                        "final_model",
                        "max_output_size",
                        "temperature"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurTaskParams/value1`.
            public var value1: Components.Schemas.LemurTaskParams.Value1Payload
            /// Creates a new `LemurTaskParams`.
            ///
            /// - Parameters:
            ///   - value1:
            public init(value1: Components.Schemas.LemurTaskParams.Value1Payload) {
                self.value1 = value1
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurSummaryParams`.
        public struct LemurSummaryParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// How you want the summary to be returned. This can be any text. Examples: "TLDR", "bullet points"
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2/answer_format`.
                public var answer_format: Swift.String?
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - answer_format: How you want the summary to be returned. This can be any text. Examples: "TLDR", "bullet points"
                public init(answer_format: Swift.String? = nil) {
                    self.answer_format = answer_format
                }
                public enum CodingKeys: String, CodingKey {
                    case answer_format
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.answer_format = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .answer_format
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "answer_format"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurSummaryParams/value2`.
            public var value2: Components.Schemas.LemurSummaryParams.Value2Payload
            /// Creates a new `LemurSummaryParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurSummaryParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams`.
        public struct LemurQuestionAnswerParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// A list of questions to ask
                ///
                /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2/questions`.
                public var questions: [Components.Schemas.LemurQuestion]
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - questions: A list of questions to ask
                public init(questions: [Components.Schemas.LemurQuestion]) {
                    self.questions = questions
                }
                public enum CodingKeys: String, CodingKey {
                    case questions
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.questions = try container.decode(
                        [Components.Schemas.LemurQuestion].self,
                        forKey: .questions
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "questions"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurQuestionAnswerParams/value2`.
            public var value2: Components.Schemas.LemurQuestionAnswerParams.Value2Payload
            /// Creates a new `LemurQuestionAnswerParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurQuestionAnswerParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurQuestion`.
        public struct LemurQuestion: Codable, Hashable, Sendable {
            /// The question you wish to ask. For more complex questions use default model.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/question`.
            public var question: Swift.String
            /// Any context about the transcripts you wish to provide. This can be a string or any object.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/context`.
            @frozen public enum contextPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case1`.
                case case1(Swift.String)
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case2`.
                public struct Case2Payload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `Case2Payload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/LemurQuestion/context/case2`.
                case case2(Components.Schemas.LemurQuestion.contextPayload.Case2Payload)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// Any context about the transcripts you wish to provide. This can be a string or any object.
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/context`.
            public var context: Components.Schemas.LemurQuestion.contextPayload?
            /// How you want the answer to be returned. This can be any text. Can't be used with answer_options. Examples: "short sentence", "bullet points"
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/answer_format`.
            public var answer_format: Swift.String?
            /// What discrete options to return. Useful for precise responses. Can't be used with answer_format. Example: ["Yes", "No"]
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/LemurQuestion/answer_options`.
            public var answer_options: [Swift.String]?
            /// Creates a new `LemurQuestion`.
            ///
            /// - Parameters:
            ///   - question: The question you wish to ask. For more complex questions use default model.
            ///   - context: Any context about the transcripts you wish to provide. This can be a string or any object.
            ///   - answer_format: How you want the answer to be returned. This can be any text. Can't be used with answer_options. Examples: "short sentence", "bullet points"
            ///   - answer_options: What discrete options to return. Useful for precise responses. Can't be used with answer_format. Example: ["Yes", "No"]
            public init(
                question: Swift.String,
                context: Components.Schemas.LemurQuestion.contextPayload? = nil,
                answer_format: Swift.String? = nil,
                answer_options: [Swift.String]? = nil
            ) {
                self.question = question
                self.context = context
                self.answer_format = answer_format
                self.answer_options = answer_options
            }
            public enum CodingKeys: String, CodingKey {
                case question
                case context
                case answer_format
                case answer_options
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.question = try container.decode(
                    Swift.String.self,
                    forKey: .question
                )
                self.context = try container.decodeIfPresent(
                    Components.Schemas.LemurQuestion.contextPayload.self,
                    forKey: .context
                )
                self.answer_format = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .answer_format
                )
                self.answer_options = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .answer_options
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "question",
                    "context",
                    "answer_format",
                    "answer_options"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams`.
        public struct LemurActionItemsParams: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value1`.
            public var value1: Components.Schemas.LemurBaseParams
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// How you want the action items to be returned. This can be any text.
                /// Defaults to "Bullet Points".
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2/answer_format`.
                public var answer_format: Swift.String?
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - answer_format: How you want the action items to be returned. This can be any text.
                public init(answer_format: Swift.String? = nil) {
                    self.answer_format = answer_format
                }
                public enum CodingKeys: String, CodingKey {
                    case answer_format
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.answer_format = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .answer_format
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "answer_format"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/LemurActionItemsParams/value2`.
            public var value2: Components.Schemas.LemurActionItemsParams.Value2Payload
            /// Creates a new `LemurActionItemsParams`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.LemurBaseParams,
                value2: Components.Schemas.LemurActionItemsParams.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// The model that is used for the final prompt after compression is performed.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/LemurModel`.
        @frozen public enum LemurModel: String, Codable, Hashable, Sendable, CaseIterable {
            case anthropic_sol_claude_hyphen_sonnet_hyphen_4_hyphen_20250514 = "anthropic/claude-sonnet-4-20250514"
            case anthropic_sol_claude_hyphen_opus_hyphen_4_hyphen_20250514 = "anthropic/claude-opus-4-20250514"
            case anthropic_sol_claude_hyphen_3_hyphen_7_hyphen_sonnet_hyphen_20250219 = "anthropic/claude-3-7-sonnet-20250219"
            case anthropic_sol_claude_hyphen_3_hyphen_5_hyphen_sonnet = "anthropic/claude-3-5-sonnet"
            case anthropic_sol_claude_hyphen_3_hyphen_5_hyphen_haiku_hyphen_20241022 = "anthropic/claude-3-5-haiku-20241022"
            case anthropic_sol_claude_hyphen_3_hyphen_opus = "anthropic/claude-3-opus"
            case anthropic_sol_claude_hyphen_3_hyphen_haiku = "anthropic/claude-3-haiku"
        }
        /// The usage numbers for the LeMUR request
        ///
        /// - Remark: Generated from `#/components/schemas/LemurUsage`.
        public struct LemurUsage: Codable, Hashable, Sendable {
            /// The number of input tokens used by the model
            ///
            /// - Remark: Generated from `#/components/schemas/LemurUsage/input_tokens`.
            public var input_tokens: Swift.Int
            /// The number of output tokens generated by the model
            ///
            /// - Remark: Generated from `#/components/schemas/LemurUsage/output_tokens`.
            public var output_tokens: Swift.Int
            /// Creates a new `LemurUsage`.
            ///
            /// - Parameters:
            ///   - input_tokens: The number of input tokens used by the model
            ///   - output_tokens: The number of output tokens generated by the model
            public init(
                input_tokens: Swift.Int,
                output_tokens: Swift.Int
            ) {
                self.input_tokens = input_tokens
                self.output_tokens = output_tokens
            }
            public enum CodingKeys: String, CodingKey {
                case input_tokens
                case output_tokens
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.input_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .input_tokens
                )
                self.output_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .output_tokens
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "input_tokens",
                    "output_tokens"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/Error`.
        public struct _Error: Codable, Hashable, Sendable {
            /// Error message
            ///
            /// - Remark: Generated from `#/components/schemas/Error/error`.
            public var error: Swift.String
            /// - Remark: Generated from `#/components/schemas/Error/status`.
            @frozen public enum statusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case error = "error"
            }
            /// - Remark: Generated from `#/components/schemas/Error/status`.
            public var status: Components.Schemas._Error.statusPayload?
            /// A container of undocumented properties.
            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
            /// Creates a new `_Error`.
            ///
            /// - Parameters:
            ///   - error: Error message
            ///   - status:
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                error: Swift.String,
                status: Components.Schemas._Error.statusPayload? = nil,
                additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()
            ) {
                self.error = error
                self.status = status
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case error
                case status
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.error = try container.decode(
                    Swift.String.self,
                    forKey: .error
                )
                self.status = try container.decodeIfPresent(
                    Components.Schemas._Error.statusPayload.self,
                    forKey: .status
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "error",
                    "status"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(
                    self.error,
                    forKey: .error
                )
                try container.encodeIfPresent(
                    self.status,
                    forKey: .status
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranslationRequestBody`.
        public struct TranslationRequestBody: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranslationRequestBody/translation`.
            public struct translationPayload: Codable, Hashable, Sendable {
                /// List of target language codes (e.g., `["es", "de"]`)
                ///
                /// - Remark: Generated from `#/components/schemas/TranslationRequestBody/translation/target_languages`.
                public var target_languages: [Swift.String]
                /// Use formal language style
                ///
                /// - Remark: Generated from `#/components/schemas/TranslationRequestBody/translation/formal`.
                public var formal: Swift.Bool?
                /// Creates a new `translationPayload`.
                ///
                /// - Parameters:
                ///   - target_languages: List of target language codes (e.g., `["es", "de"]`)
                ///   - formal: Use formal language style
                public init(
                    target_languages: [Swift.String],
                    formal: Swift.Bool? = nil
                ) {
                    self.target_languages = target_languages
                    self.formal = formal
                }
                public enum CodingKeys: String, CodingKey {
                    case target_languages
                    case formal
                }
            }
            /// - Remark: Generated from `#/components/schemas/TranslationRequestBody/translation`.
            public var translation: Components.Schemas.TranslationRequestBody.translationPayload
            /// Creates a new `TranslationRequestBody`.
            ///
            /// - Parameters:
            ///   - translation:
            public init(translation: Components.Schemas.TranslationRequestBody.translationPayload) {
                self.translation = translation
            }
            public enum CodingKeys: String, CodingKey {
                case translation
            }
        }
        /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody`.
        public struct SpeakerIdentificationRequestBody: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody/speaker_identification`.
            public struct speaker_identificationPayload: Codable, Hashable, Sendable {
                /// Type of speaker identification
                ///
                /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody/speaker_identification/speaker_type`.
                @frozen public enum speaker_typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case role = "role"
                    case name = "name"
                }
                /// Type of speaker identification
                ///
                /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody/speaker_identification/speaker_type`.
                public var speaker_type: Components.Schemas.SpeakerIdentificationRequestBody.speaker_identificationPayload.speaker_typePayload
                /// Required if speaker_type is "role". Each value must be 35 characters or less.
                ///
                /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody/speaker_identification/known_values`.
                public var known_values: [Swift.String]?
                /// Creates a new `speaker_identificationPayload`.
                ///
                /// - Parameters:
                ///   - speaker_type: Type of speaker identification
                ///   - known_values: Required if speaker_type is "role". Each value must be 35 characters or less.
                public init(
                    speaker_type: Components.Schemas.SpeakerIdentificationRequestBody.speaker_identificationPayload.speaker_typePayload,
                    known_values: [Swift.String]? = nil
                ) {
                    self.speaker_type = speaker_type
                    self.known_values = known_values
                }
                public enum CodingKeys: String, CodingKey {
                    case speaker_type
                    case known_values
                }
            }
            /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationRequestBody/speaker_identification`.
            public var speaker_identification: Components.Schemas.SpeakerIdentificationRequestBody.speaker_identificationPayload
            /// Creates a new `SpeakerIdentificationRequestBody`.
            ///
            /// - Parameters:
            ///   - speaker_identification:
            public init(speaker_identification: Components.Schemas.SpeakerIdentificationRequestBody.speaker_identificationPayload) {
                self.speaker_identification = speaker_identification
            }
            public enum CodingKeys: String, CodingKey {
                case speaker_identification
            }
        }
        /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody`.
        public struct CustomFormattingRequestBody: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting`.
            public struct custom_formattingPayload: Codable, Hashable, Sendable {
                /// Date format pattern (e.g., `"mm/dd/yyyy"`)
                ///
                /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting/date`.
                public var date: Swift.String?
                /// Phone number format pattern (e.g., `"(xxx)xxx-xxxx"`)
                ///
                /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting/phone_number`.
                public var phone_number: Swift.String?
                /// Email format pattern (e.g., `"username@domain.com"`)
                ///
                /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting/email`.
                public var email: Swift.String?
                /// Whether to format utterances
                ///
                /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting/format_utterances`.
                public var format_utterances: Swift.Bool?
                /// Creates a new `custom_formattingPayload`.
                ///
                /// - Parameters:
                ///   - date: Date format pattern (e.g., `"mm/dd/yyyy"`)
                ///   - phone_number: Phone number format pattern (e.g., `"(xxx)xxx-xxxx"`)
                ///   - email: Email format pattern (e.g., `"username@domain.com"`)
                ///   - format_utterances: Whether to format utterances
                public init(
                    date: Swift.String? = nil,
                    phone_number: Swift.String? = nil,
                    email: Swift.String? = nil,
                    format_utterances: Swift.Bool? = nil
                ) {
                    self.date = date
                    self.phone_number = phone_number
                    self.email = email
                    self.format_utterances = format_utterances
                }
                public enum CodingKeys: String, CodingKey {
                    case date
                    case phone_number
                    case email
                    case format_utterances
                }
            }
            /// - Remark: Generated from `#/components/schemas/CustomFormattingRequestBody/custom_formatting`.
            public var custom_formatting: Components.Schemas.CustomFormattingRequestBody.custom_formattingPayload
            /// Creates a new `CustomFormattingRequestBody`.
            ///
            /// - Parameters:
            ///   - custom_formatting:
            public init(custom_formatting: Components.Schemas.CustomFormattingRequestBody.custom_formattingPayload) {
                self.custom_formatting = custom_formatting
            }
            public enum CodingKeys: String, CodingKey {
                case custom_formatting
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranslationResponse`.
        public struct TranslationResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranslationResponse/translation`.
            public struct translationPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranslationResponse/translation/status`.
                public var status: Swift.String?
                /// Creates a new `translationPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Swift.String? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/TranslationResponse/translation`.
            public var translation: Components.Schemas.TranslationResponse.translationPayload?
            /// Creates a new `TranslationResponse`.
            ///
            /// - Parameters:
            ///   - translation:
            public init(translation: Components.Schemas.TranslationResponse.translationPayload? = nil) {
                self.translation = translation
            }
            public enum CodingKeys: String, CodingKey {
                case translation
            }
        }
        /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationResponse`.
        public struct SpeakerIdentificationResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationResponse/speaker_identification`.
            public struct speaker_identificationPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationResponse/speaker_identification/status`.
                public var status: Swift.String?
                /// Creates a new `speaker_identificationPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Swift.String? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/SpeakerIdentificationResponse/speaker_identification`.
            public var speaker_identification: Components.Schemas.SpeakerIdentificationResponse.speaker_identificationPayload?
            /// Creates a new `SpeakerIdentificationResponse`.
            ///
            /// - Parameters:
            ///   - speaker_identification:
            public init(speaker_identification: Components.Schemas.SpeakerIdentificationResponse.speaker_identificationPayload? = nil) {
                self.speaker_identification = speaker_identification
            }
            public enum CodingKeys: String, CodingKey {
                case speaker_identification
            }
        }
        /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse`.
        public struct CustomFormattingResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse/custom_formatting`.
            public struct custom_formattingPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse/custom_formatting/mapping`.
                public struct mappingPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `mappingPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse/custom_formatting/mapping`.
                public var mapping: Components.Schemas.CustomFormattingResponse.custom_formattingPayload.mappingPayload?
                /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse/custom_formatting/formatted_text`.
                public var formatted_text: Swift.String?
                /// Creates a new `custom_formattingPayload`.
                ///
                /// - Parameters:
                ///   - mapping:
                ///   - formatted_text:
                public init(
                    mapping: Components.Schemas.CustomFormattingResponse.custom_formattingPayload.mappingPayload? = nil,
                    formatted_text: Swift.String? = nil
                ) {
                    self.mapping = mapping
                    self.formatted_text = formatted_text
                }
                public enum CodingKeys: String, CodingKey {
                    case mapping
                    case formatted_text
                }
            }
            /// - Remark: Generated from `#/components/schemas/CustomFormattingResponse/custom_formatting`.
            public var custom_formatting: Components.Schemas.CustomFormattingResponse.custom_formattingPayload?
            /// Creates a new `CustomFormattingResponse`.
            ///
            /// - Parameters:
            ///   - custom_formatting:
            public init(custom_formatting: Components.Schemas.CustomFormattingResponse.custom_formattingPayload? = nil) {
                self.custom_formatting = custom_formatting
            }
            public enum CodingKeys: String, CodingKey {
                case custom_formatting
            }
        }
        /// - Remark: Generated from `#/components/schemas/StreamingTokenError`.
        public struct StreamingTokenError: Codable, Hashable, Sendable {
            /// Error message describing what went wrong
            ///
            /// - Remark: Generated from `#/components/schemas/StreamingTokenError/error`.
            public var error: Swift.String
            /// Error code for programmatic handling
            ///
            /// - Remark: Generated from `#/components/schemas/StreamingTokenError/code`.
            public var code: Swift.String?
            /// Additional error details if available
            ///
            /// - Remark: Generated from `#/components/schemas/StreamingTokenError/details`.
            public var details: OpenAPIRuntime.OpenAPIObjectContainer?
            /// Creates a new `StreamingTokenError`.
            ///
            /// - Parameters:
            ///   - error: Error message describing what went wrong
            ///   - code: Error code for programmatic handling
            ///   - details: Additional error details if available
            public init(
                error: Swift.String,
                code: Swift.String? = nil,
                details: OpenAPIRuntime.OpenAPIObjectContainer? = nil
            ) {
                self.error = error
                self.code = code
                self.details = details
            }
            public enum CodingKeys: String, CodingKey {
                case error
                case code
                case details
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {
        public struct BadRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/BadRequest/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/BadRequest/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/BadRequest/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.BadRequest.Body
            /// Creates a new `BadRequest`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.BadRequest.Body) {
                self.body = body
            }
        }
        public struct Unauthorized: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/Unauthorized/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/Unauthorized/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/Unauthorized/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Unauthorized.Body
            /// Creates a new `Unauthorized`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Unauthorized.Body) {
                self.body = body
            }
        }
        public struct CannotAccessUploadedFile: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/CannotAccessUploadedFile/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/CannotAccessUploadedFile/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/CannotAccessUploadedFile/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.CannotAccessUploadedFile.Body
            /// Creates a new `CannotAccessUploadedFile`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.CannotAccessUploadedFile.Body) {
                self.body = body
            }
        }
        public struct NotFound: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/NotFound/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/NotFound/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/NotFound/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.NotFound.Body
            /// Creates a new `NotFound`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.NotFound.Body) {
                self.body = body
            }
        }
        public struct TooManyRequests: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/TooManyRequests/headers`.
            public struct Headers: Sendable, Hashable {
                /// The number of seconds to wait before retrying the request
                ///
                /// - Remark: Generated from `#/components/responses/TooManyRequests/headers/Retry-After`.
                public var Retry_hyphen_After: Swift.Int?
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - Retry_hyphen_After: The number of seconds to wait before retrying the request
                public init(Retry_hyphen_After: Swift.Int? = nil) {
                    self.Retry_hyphen_After = Retry_hyphen_After
                }
            }
            /// Received HTTP response headers
            public var headers: Components.Responses.TooManyRequests.Headers
            /// - Remark: Generated from `#/components/responses/TooManyRequests/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/TooManyRequests/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/TooManyRequests/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.TooManyRequests.Body
            /// Creates a new `TooManyRequests`.
            ///
            /// - Parameters:
            ///   - headers: Received HTTP response headers
            ///   - body: Received HTTP response body
            public init(
                headers: Components.Responses.TooManyRequests.Headers = .init(),
                body: Components.Responses.TooManyRequests.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        public struct InternalServerError: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/InternalServerError/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/InternalServerError/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/InternalServerError/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.InternalServerError.Body
            /// Creates a new `InternalServerError`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.InternalServerError.Body) {
                self.body = body
            }
        }
        public struct ServiceUnavailable: Sendable, Hashable {
            /// Creates a new `ServiceUnavailable`.
            public init() {}
        }
        public struct GatewayTimeout: Sendable, Hashable {
            /// Creates a new `GatewayTimeout`.
            public init() {}
        }
        public struct UnprocessableContent: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/UnprocessableContent/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/UnprocessableContent/content/application\/json`.
                case json(Components.Schemas._Error)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas._Error {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/UnprocessableContent/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.UnprocessableContent.Body
            /// Creates a new `UnprocessableContent`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.UnprocessableContent.Body) {
                self.body = body
            }
        }
    }
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Upload a media file
    ///
    /// Upload a media file to AssemblyAI's servers.
    ///
    /// <Note>To upload a media file to our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// <Warning>Requests to transcribe uploaded files must use an API key from the same project as the key that was used to upload the file. If you use an API key from a different project you will get a `403` error and "Cannot access uploaded file" message.</Warning>
    ///
    ///
    /// - Remark: HTTP `POST /v2/upload`.
    /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)`.
    public enum uploadFile {
        public static let id: Swift.String = "uploadFile"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/upload/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.uploadFile.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.uploadFile.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.uploadFile.Input.Headers
            /// - Remark: Generated from `#/paths/v2/upload/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/upload/POST/requestBody/content/application\/octet-stream`.
                case binary(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.uploadFile.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.uploadFile.Input.Headers = .init(),
                body: Operations.uploadFile.Input.Body? = nil
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/upload/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/upload/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.UploadedFile)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UploadedFile {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.uploadFile.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.uploadFile.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Media file uploaded successfully
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.uploadFile.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.uploadFile.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Cannot access uploaded file
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.CannotAccessUploadedFile)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.CannotAccessUploadedFile {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/upload/post(uploadFile)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// List transcripts
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Retrieve a list of transcripts you created.
    /// Transcripts are sorted from newest to oldest and can be retrieved for the last 90 days of usage. The previous URL always points to a page with older transcripts.
    ///
    /// If you need to retrieve transcripts from more than 90 days ago please reach out to our Support team at support@assemblyai.com.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)`.
    public enum listTranscripts {
        public static let id: Swift.String = "listTranscripts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Maximum amount of transcripts to retrieve
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/limit`.
                public var limit: OpenAPIRuntime.OpenAPIValueContainer?
                /// Filter by transcript status
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/status`.
                public var status: Components.Schemas.TranscriptStatus?
                /// Only get transcripts created on this date
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/created_on`.
                public var created_on: OpenAPIRuntime.OpenAPIValueContainer?
                /// Get transcripts that were created before this transcript ID
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/before_id`.
                public var before_id: OpenAPIRuntime.OpenAPIValueContainer?
                /// Get transcripts that were created after this transcript ID
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/after_id`.
                public var after_id: OpenAPIRuntime.OpenAPIValueContainer?
                /// Only get throttled transcripts, overrides the status filter
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/GET/query/throttled_only`.
                @available(*, deprecated)
                public var throttled_only: OpenAPIRuntime.OpenAPIValueContainer?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - limit: Maximum amount of transcripts to retrieve
                ///   - status: Filter by transcript status
                ///   - created_on: Only get transcripts created on this date
                ///   - before_id: Get transcripts that were created before this transcript ID
                ///   - after_id: Get transcripts that were created after this transcript ID
                ///   - throttled_only: Only get throttled transcripts, overrides the status filter
                public init(
                    limit: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    status: Components.Schemas.TranscriptStatus? = nil,
                    created_on: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    before_id: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    after_id: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                    throttled_only: OpenAPIRuntime.OpenAPIValueContainer? = nil
                ) {
                    self.limit = limit
                    self.status = status
                    self.created_on = created_on
                    self.before_id = before_id
                    self.after_id = after_id
                    self.throttled_only = throttled_only
                }
            }
            public var query: Operations.listTranscripts.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listTranscripts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listTranscripts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.listTranscripts.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.listTranscripts.Input.Query = .init(),
                headers: Operations.listTranscripts.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TranscriptList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TranscriptList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.listTranscripts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.listTranscripts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// A list of transcripts. Transcripts are sorted from newest to oldest. The previous URL always points to a page with older transcripts.
            ///
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.listTranscripts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.listTranscripts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/get(listTranscripts)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Transcribe audio
    ///
    /// <Note>To use our EU server for transcription, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Create a transcript from a media file that is accessible via a URL.
    ///
    ///
    /// - Remark: HTTP `POST /v2/transcript`.
    /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)`.
    public enum createTranscript {
        public static let id: Swift.String = "createTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createTranscript.Input.Headers
            /// - Remark: Generated from `#/paths/v2/transcript/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.TranscriptParams)
            }
            public var body: Operations.createTranscript.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createTranscript.Input.Headers = .init(),
                body: Operations.createTranscript.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Transcript created and queued for processing
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.createTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.createTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/post(createTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Get transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript resource. The transcript is ready when the "status" is "completed".
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)`.
    public enum getTranscript {
        public static let id: Swift.String = "getTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscript.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscript.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscript.Input.Path,
                headers: Operations.getTranscript.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The transcript resource
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/get(getTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Delete transcript
    ///
    /// <Note>To delete your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Remove the data from the transcript and mark it as deleted.
    ///
    ///
    /// - Remark: HTTP `DELETE /v2/transcript/{transcript_id}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)`.
    public enum deleteTranscript {
        public static let id: Swift.String = "deleteTranscript"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.deleteTranscript.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.deleteTranscript.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.deleteTranscript.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.deleteTranscript.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.deleteTranscript.Input.Path,
                headers: Operations.deleteTranscript.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/DELETE/responses/200/content/application\/json`.
                    case json(Components.Schemas.Transcript)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Transcript {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.deleteTranscript.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.deleteTranscript.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The deleted transcript response
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.deleteTranscript.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.deleteTranscript.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/delete(deleteTranscript)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Get subtitles for transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/{subtitle_format}`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)`.
    public enum getSubtitles {
        public static let id: Swift.String = "getSubtitles"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// The format of the captions
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/path/subtitle_format`.
                public var subtitle_format: Components.Schemas.SubtitleFormat
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                ///   - subtitle_format: The format of the captions
                public init(
                    transcript_id: Swift.String,
                    subtitle_format: Components.Schemas.SubtitleFormat
                ) {
                    self.transcript_id = transcript_id
                    self.subtitle_format = subtitle_format
                }
            }
            public var path: Operations.getSubtitles.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The maximum number of characters per caption
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/query/chars_per_caption`.
                public var chars_per_caption: Swift.Int?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - chars_per_caption: The maximum number of characters per caption
                public init(chars_per_caption: Swift.Int? = nil) {
                    self.chars_per_caption = chars_per_caption
                }
            }
            public var query: Operations.getSubtitles.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSubtitles.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getSubtitles.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getSubtitles.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.getSubtitles.Input.Path,
                query: Operations.getSubtitles.Input.Query = .init(),
                headers: Operations.getSubtitles.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/responses/200/content/text\/plain`.
                    case plainText(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.plainText`.
                    ///
                    /// - Throws: An error if `self` is not `.plainText`.
                    /// - SeeAlso: `.plainText`.
                    public var plainText: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .plainText(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "text/plain",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/{subtitle_format}/GET/responses/200/content/text\/html`.
                    case html(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.html`.
                    ///
                    /// - Throws: An error if `self` is not `.html`.
                    /// - SeeAlso: `.html`.
                    public var html: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .html(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "text/html",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getSubtitles.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getSubtitles.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The exported captions as text
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getSubtitles.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getSubtitles.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/{subtitle_format}/get(getSubtitles)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case plainText
            case html
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "text/plain":
                    self = .plainText
                case "text/html":
                    self = .html
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .plainText:
                    return "text/plain"
                case .html:
                    return "text/html"
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .plainText,
                    .html,
                    .json
                ]
            }
        }
    }
    /// Get sentences in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/sentences`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)`.
    public enum getTranscriptSentences {
        public static let id: Swift.String = "getTranscriptSentences"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscriptSentences.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptSentences.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptSentences.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscriptSentences.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscriptSentences.Input.Path,
                headers: Operations.getTranscriptSentences.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/sentences/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.SentencesResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.SentencesResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscriptSentences.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscriptSentences.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Exported sentences
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscriptSentences.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscriptSentences.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/sentences/get(getTranscriptSentences)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Get paragraphs in transcript
    ///
    /// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/paragraphs`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)`.
    public enum getTranscriptParagraphs {
        public static let id: Swift.String = "getTranscriptParagraphs"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getTranscriptParagraphs.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptParagraphs.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getTranscriptParagraphs.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getTranscriptParagraphs.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getTranscriptParagraphs.Input.Path,
                headers: Operations.getTranscriptParagraphs.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/paragraphs/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ParagraphsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ParagraphsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getTranscriptParagraphs.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getTranscriptParagraphs.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Exported paragraphs
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getTranscriptParagraphs.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getTranscriptParagraphs.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/paragraphs/get(getTranscriptParagraphs)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Search words in transcript
    ///
    /// <Note>To search through a transcription created on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note>
    /// Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/word-search`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)`.
    public enum wordSearch {
        public static let id: Swift.String = "wordSearch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.wordSearch.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Keywords to search for
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/query/words`.
                public var words: [Swift.String]
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - words: Keywords to search for
                public init(words: [Swift.String]) {
                    self.words = words
                }
            }
            public var query: Operations.wordSearch.Input.Query
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.wordSearch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.wordSearch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.wordSearch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.wordSearch.Input.Path,
                query: Operations.wordSearch.Input.Query,
                headers: Operations.wordSearch.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/word-search/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.WordSearchResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.WordSearchResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.wordSearch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.wordSearch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Word search response
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.wordSearch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.wordSearch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/word-search/get(wordSearch)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Get redacted audio
    ///
    /// <Note>To retrieve the redacted audio on the EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com` in the `GET` request above.</Note>
    /// Retrieve the redacted audio object containing the status and URL to the redacted audio.
    ///
    ///
    /// - Remark: HTTP `GET /v2/transcript/{transcript_id}/redacted-audio`.
    /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)`.
    public enum getRedactedAudio {
        public static let id: Swift.String = "getRedactedAudio"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/path`.
            public struct Path: Sendable, Hashable {
                /// ID of the transcript
                ///
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/path/transcript_id`.
                public var transcript_id: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - transcript_id: ID of the transcript
                public init(transcript_id: Swift.String) {
                    self.transcript_id = transcript_id
                }
            }
            public var path: Operations.getRedactedAudio.Input.Path
            /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getRedactedAudio.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.getRedactedAudio.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.getRedactedAudio.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.getRedactedAudio.Input.Path,
                headers: Operations.getRedactedAudio.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v2/transcript/{transcript_id}/redacted-audio/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RedactedAudioResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RedactedAudioResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.getRedactedAudio.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.getRedactedAudio.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The redacted audio object containing the status and URL to the redacted audio
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.getRedactedAudio.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.getRedactedAudio.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not found
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Bad request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Too many requests
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// An error occurred while processing the request
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            public static var serviceUnavailable: Self {
                .serviceUnavailable(.init())
            }
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// Gateway timeout
            ///
            /// - Remark: Generated from `#/paths//v2/transcript/{transcript_id}/redacted-audio/get(getRedactedAudio)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            public static var gatewayTimeout: Self {
                .gatewayTimeout(.init())
            }
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Generate temporary streaming token
    ///
    /// Generates a temporary authentication token for use with streaming services.
    ///
    ///
    /// - Remark: HTTP `GET /v3/token`.
    /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)`.
    public enum generateStreamingToken {
        public static let id: Swift.String = "generateStreamingToken"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v3/token/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The desired expiration time for the token in seconds.
                ///
                ///
                /// - Remark: Generated from `#/paths/v3/token/GET/query/expires_in_seconds`.
                public var expires_in_seconds: Swift.Int
                /// The desired maximum duration for the session started using this token in seconds.
                ///
                ///
                /// - Remark: Generated from `#/paths/v3/token/GET/query/max_session_duration_seconds`.
                public var max_session_duration_seconds: Swift.Int?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - expires_in_seconds: The desired expiration time for the token in seconds.
                ///   - max_session_duration_seconds: The desired maximum duration for the session started using this token in seconds.
                public init(
                    expires_in_seconds: Swift.Int,
                    max_session_duration_seconds: Swift.Int? = nil
                ) {
                    self.expires_in_seconds = expires_in_seconds
                    self.max_session_duration_seconds = max_session_duration_seconds
                }
            }
            public var query: Operations.generateStreamingToken.Input.Query
            /// - Remark: Generated from `#/paths/v3/token/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.generateStreamingToken.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.generateStreamingToken.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.generateStreamingToken.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.generateStreamingToken.Input.Query,
                headers: Operations.generateStreamingToken.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v3/token/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/200/content/json`.
                    public struct jsonPayload: Codable, Hashable, Sendable {
                        /// The temporary authentication token
                        ///
                        /// - Remark: Generated from `#/paths/v3/token/GET/responses/200/content/json/token`.
                        public var token: Swift.String
                        /// The actual expiration time of the token in seconds.
                        ///
                        ///
                        /// - Remark: Generated from `#/paths/v3/token/GET/responses/200/content/json/expires_in_seconds`.
                        public var expires_in_seconds: Swift.Int
                        /// Creates a new `jsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - token: The temporary authentication token
                        ///   - expires_in_seconds: The actual expiration time of the token in seconds.
                        public init(
                            token: Swift.String,
                            expires_in_seconds: Swift.Int
                        ) {
                            self.token = token
                            self.expires_in_seconds = expires_in_seconds
                        }
                        public enum CodingKeys: String, CodingKey {
                            case token
                            case expires_in_seconds
                        }
                    }
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/200/content/application\/json`.
                    case json(Operations.generateStreamingToken.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.generateStreamingToken.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.generateStreamingToken.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.generateStreamingToken.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successfully generated temporary token
            ///
            /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.generateStreamingToken.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.generateStreamingToken.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct BadRequest: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v3/token/GET/responses/400/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/400/content/application\/json`.
                    case json(Components.Schemas.StreamingTokenError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StreamingTokenError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.generateStreamingToken.Output.BadRequest.Body
                /// Creates a new `BadRequest`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.generateStreamingToken.Output.BadRequest.Body) {
                    self.body = body
                }
            }
            /// Bad Request - Invalid parameters
            ///
            /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Operations.generateStreamingToken.Output.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Operations.generateStreamingToken.Output.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v3/token/GET/responses/401/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/401/content/application\/json`.
                    case json(Components.Schemas.StreamingTokenError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StreamingTokenError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.generateStreamingToken.Output.Unauthorized.Body
                /// Creates a new `Unauthorized`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.generateStreamingToken.Output.Unauthorized.Body) {
                    self.body = body
                }
            }
            /// Unauthorized - Invalid or missing API key
            ///
            /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.generateStreamingToken.Output.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.generateStreamingToken.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct TooManyRequests: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v3/token/GET/responses/429/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/429/content/application\/json`.
                    case json(Components.Schemas.StreamingTokenError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StreamingTokenError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.generateStreamingToken.Output.TooManyRequests.Body
                /// Creates a new `TooManyRequests`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.generateStreamingToken.Output.TooManyRequests.Body) {
                    self.body = body
                }
            }
            /// Too Many Requests - Rate limit exceeded
            ///
            /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Operations.generateStreamingToken.Output.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Operations.generateStreamingToken.Output.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            public struct InternalServerError: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v3/token/GET/responses/500/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v3/token/GET/responses/500/content/application\/json`.
                    case json(Components.Schemas.StreamingTokenError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StreamingTokenError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.generateStreamingToken.Output.InternalServerError.Body
                /// Creates a new `InternalServerError`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.generateStreamingToken.Output.InternalServerError.Body) {
                    self.body = body
                }
            }
            /// Internal Server Error
            ///
            /// - Remark: Generated from `#/paths//v3/token/get(generateStreamingToken)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Operations.generateStreamingToken.Output.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Operations.generateStreamingToken.Output.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
